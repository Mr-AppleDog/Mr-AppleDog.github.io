<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>概述(一)</title>
    <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>这是对作为一个互联网（网中网）的 Internet 进行概述，讨论 Internet 的组成部分。这个目标的部分内容为介绍协议分层和 TCP&#x2F;IP 协议簇</p><span id="more"></span><h3 id="计算机网络在信息时代中的作用"><a href="#计算机网络在信息时代中的作用" class="headerlink" title="计算机网络在信息时代中的作用"></a>计算机网络在信息时代中的作用</h3><p>Internet的中文译名并不统一。现有的Internet译名有两种：<br>        因特网，这个译名是全国科学技术名词审定委员会推荐的。虽然因特网这个译名较为准确，但却长期未得到推广。本书的前几版都采用因特网这个译名。<br>        互联网，这是目前流行最广的、事实上的标准译名。现在我国的各种报刊杂志、政府文件以及电视节目中都毫无例外地使用这个译名。Internet是由数量极大的各种计算机网络互连起来的，采用互联网这个译名能够体现出Internet最主要的特征。本书从第7版开始，改用“互联网”作为Internet的译名。</p><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>计算机网络（简称为<strong>网络</strong>）由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成。网络中的节点可以是计算机、集线器、交换机或路由器等（在后续的两章我们将会介绍集线器、交换机和路由器等设备的作用)。下图给出了一个具有四个节点和三条链路的网络。我们看到，有三台计算机通过三条链路连接到一个集线器上。这是一个非常简单的计算机网终（可简称为网终)又加在下图中，有多个网悠通过二些路由器相互连接起来，构成了一个覆盖范围更大的计算机网络。这样的网铭称为互连网internetwork或internet)。因此互连网是“网络的网络”(network of networks)甲一朵云表示一个网络的好处，就是可以先不考虑每一个网络中的细节，而是集中精力讨论与这个互连网有关的一些问题。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171508256.png" class="" title="image-20230829171508256"><p>请读者注意，当我们使用一朵云来表示网络时，可能会有两种不同的情况。一种情况如图(a)所示，用云表示的网络已经包含了网络中的计算机。但有时为了讨论问题的方便例如，要讨论几个计算机之间如何进行通信)，也可以把有关的计算机画在云的外面，如下图所示。习惯上，与网络相连的计算机常称为主机（host)。在互连网中不可缺少的路由器，是一种特殊的计筒机（有中央处理器、存储器、操作系统等），但不能称为主机。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171654918.png" class="" title="image-20230829171654918"><p>这样，我们初步建立了下面的基本概念：<br>网络把许多计算机连接在一起，而互连网则把许多网络通过一些路由器连接在一起。与网络相连的计算机常称为主机。</p><h4 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h4><ol><li>第一阶段是从单个网络ARPANET向互连网发展的过程</li><li>第二阶段的特点是建成了三级结构的互联网</li><li>第三阶段的特点是逐渐形成了全球范围的多层次ISP结沟的旦肤网。</li></ol><h4 id="互联网的标准化工作"><a href="#互联网的标准化工作" class="headerlink" title="互联网的标准化工作"></a>互联网的标准化工作</h4><p>制定互联网的正式标准要经过以下三个阶段：</p><ul><li>互联网草案(nternet Draft)一互联网草案的有效期只有六个月。在这个阶段还不能算是RFC文档。</li><li>建议标准(Proposed Standard)一从这个阶段开始就成为RFC文档。</li><li>互联网标准(nternet Standard)一如果经过长期的检验，证明了某个建议标准可以成为互联网标准时，就给它分配一个标准编号，记为STDxx,这里STD是“Standard”的英文缩写，而“xx”是标准的编号（有时也写成4位数编号，如STD0005)。一个互联网标准可以和多个RFC文档关联。</li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul><li>边缘部分:由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829172920816.png" class="" title="image-20230829172920816"><ul><li>核心部分:由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换)</li></ul><h4 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h4><p>我们先要明确下面的概念。我们说：“主机A和主机B进行通信”，实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式(C&#x2F;S方式)和对等方式(P2P方式)下面分别对这两种方式进行介绍。</p><p>1.客户-服务器方式</p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服多和被服务的关系。在下图中，主机A运行客户程序而主机B运行服务器程序。在这种情况下，A是客户而B是服务器。客户A向服务器B发出请求服务，而服务器B向客户A提供服务。这里最主要的特征就是：客户是服务请求方，服务器是服务提供方。<br>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829173123722.png" class="" title="image-20230829173123722">在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点。<p>客户程序：</p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p>服务器程序：</p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般需要有强大的硬件和高级的操作系统支持。客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</li></ul><p>2.对等连接方式</p><p>是指两台主机在通信时，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件(P2P软件)，它们就可以进行平等的对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为P2P方式。</p><p>在下图中，主机C,D,E和F都运行了P2P程序，因此这几台主机都可进行对等通信（如C和D,E和F,以及C和F)。实际上，对等连接方式从本质上看仍然使用客户服务器方式，只是对等连接中的每一台主机既是客户同时又是服务器。例如主机C,当C请求D的服务时，C是客户，D是服务器。但如果C又同时向F提供服务，那么C又同时起着服务器的作用。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174035901.png" class="" title="image-20230829174035901"><h4 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h4><p>网络核心部分是互联网中最复杂的部分，因为网络中的核心部分要向网络边缘部分中的大量主机提供连通性，使边缘部分中的任何一台主机都能够与其他主机通信。在网络核心部分起特殊作用的是<strong>路由器</strong>(router),它是一种专用计算机（但不叫作主机)。路由器是实现<strong>分组交换</strong>(packet switching)的关键构件，其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能。</p><p>1、电路交换的特点</p><p>从通信资源的分配角度来看，<strong>交换</strong>(switching)就是按照某种方式动态地分配传输线路的资源。在使用电路交换打电话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条<strong>专用的物理通路</strong>。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的<br>物理通路（即把刚才占用的所有通信资源归还给电信网）。这种必须经过“<strong>建立连接（占用通信资源)→通适（一直占用通信贪源→释放连接（归还通信资源）</strong>”三个步骤的交换方式称为电路交换。如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后再重新拨号。</p><p>2、分组交换的特点</p><p>分组交换则采用存储转发技术。下图表示把一个报文划分为几个分组后再进行传送。通常我们把要发送的整块数据称为一个<strong>报文</strong>(message)。在发送报文之前，先把较长的报文划分为一个个更小的等长数据段，例如，视频讲解每个数据段为1024bit。在每一个数据段前面，加上一些必要的控制信息组成的首部(header)后，就构成了一个<strong>分组</strong>(packet)。分组又称为“包”，而分组的首部也可称为“包头”。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174914172.png" class="" title="image-20230829174914172"><p>位于<strong>网络边缘部分的主机</strong>和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器则用来转发分组，即进行分组交换。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地（有时会经过几十个不同的路由器）以存储转发的方式，把分组交付最终的<br>目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175504654.png" class="" title="image-20230829175504654"><p>图的最下方归纳了三种交换方式在数据传送阶段的主要特点：</p><ul><li>电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换—整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。</li><li>分组交换—单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175607493.png" class="" title="image-20230829175607493"><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><h4 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h4><p>关于计算机网络的较好的定义是这样的[PETE12]1:计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h4 id="几种不同类别的计算机网络"><a href="#几种不同类别的计算机网络" class="headerlink" title="几种不同类别的计算机网络"></a>几种不同类别的计算机网络</h4><ul><li>按照网络的作用范围进行分类</li></ul><p>广域网WAN(Wide Area Network)广域网的作用范围通常为几十到几千公里，因而有时也称为远程网(long haul network)</p><p>城域网MAN(Metropolitan Area Network)城域网的作用范围一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5~50km。</p><p>局域网LAN(Local Area Network)局域网一般用微型计算机或工作站通过高速通信线路相连（速率通常在10Mbit&#x2F;s以上），但地理上则局限在较小的范围（如1km左右）。</p><p>个人区域网PAN(Personal Area Network)个人区域网就是在个人工作的地方把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络，因此也常称为无线个人区域网WPAN(Wireless PAN),其范围很小，大约在I0m左右。</p><ul><li>按照网络的使用者进行分类</li></ul><p>公用网(public network)这是指电信公司（国有或私有）出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为公众网。</p><p>专用网(private network)这是某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</p><ul><li>用来把用户接入到互联网的网络</li></ul><p>这种网络就是接入网AN(Access Network),它又称为本地接入网或居民接入网</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><ul><li>速率</li></ul><p>计算机发送的信号都是数字形式的。比特(bit)来源于binary digit,意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率,它也称为数据率(data rate)或比特率(bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit&#x2F;s(比特每秒)</p><ul><li>带宽</li></ul><p>“带宽”(bandwidth)有以下两种不同的意义：</p><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。例如，在传统的通信线路上传送的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,即话音的主要成分的频率范围)。这种意义的带宽的单位是赫(或千赫、兆赫、吉赫等)。在过去很长的一段时间，通信的主干线路传送的是模拟信号(即连续变化的信号)。因此，表示某信道允许通过的信号频带范围就称为该信道的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”。在本书中提到“带宽”时，主要是指这个意思。这种意义的带宽的单位就是数据率的单位bit&#x2F;s,是“比特每秒”。</li></ol><ul><li>吞吐量</li><li>时延</li></ul><p>时延(delay或latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或迟延。</p><p>发送时延：发送时延(transmission delay)是主机或路由器发送数据帧所需要的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182020809.png" class="" title="image-20230829182020809"><p>传播时延：是电磁波在信道中传播一定的距离需要花费的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182128702.png" class="" title="image-20230829182128702"><p>处理时延：处理时延主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找转发表等，这就产生了处理时延</p><p>排队时延：排队时延分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><ul><li>时延带宽积</li></ul><p>时延带宽积&#x3D;传播时延×带宽</p><ul><li>往返时间PTT</li></ul><p>在计算机网络中，往返时间RTT(Round-Trip Time)也是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。例如，A向B发送数据。如果数据长度是100MB,发送速率是1O0Mhit&#x2F;s.那么</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194040018.png" class=""><p>假定B正确收完100MB的数据后，就立即向A发送确认。再假定A只有在收到B的确认信息后，才能继续向B发送数据。显然，这就要等待一个往返时间RTT(这里假定确认信息很短，可忽略B发送确认的发送时延)。如果RTT&#x3D;2s,那么可以算出A向B发送数据的有效数据率。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194236316.png" class="" title="image-20230829194236316"><ul><li>利用率</li></ul><h4 id="计算机网络的非性能特征"><a href="#计算机网络的非性能特征" class="headerlink" title="计算机网络的非性能特征"></a>计算机网络的非性能特征</h4><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于维护和管理</li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h4><h6 id="网络协议三个要素组成："><a href="#网络协议三个要素组成：" class="headerlink" title="网络协议三个要素组成："></a>网络协议三个要素组成：</h6><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：即事件实现顺序的详细说明</li></ul><h6 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h6><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194710875.png" class="" title="image-20230829194710875"><ul><li>应用层(application layer)</li></ul><p>应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程就是指主机中正在运行的程序。对于不同的网络应用需要有不同的应用层协议。互联网中的应用层协议很多，如域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议，等等。我们把应用层交互的数据单元称为报文(message)。</p><ul><li>运输层(transport layer)</li></ul><p>运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。所谓“通用的”，是指并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议：</p><ol><li>传输控制协议TCP(Transmission Control Protocol)提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。</li><li>用户数据报协议UDP(User Datagram Protocol)—提供无连接的尽最大努力(besteffort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。</li></ol><ul><li>网络层(network layer)</li></ul><p>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用P协议，因此分组也叫作P数据报，或简称为数据报。本书把“分组”和“数据报”作为同义词使用。请注意：不要将运输层的“用户数据报协议UDP”和网络层的“IP数据报”弄混。此外，无论在哪一层传送的数据单元，都可笼统地用“分组”来表示。</p><ul><li>数据链路层(data link layer)</li></ul><p>数据链路层常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing),在两个相邻节点间的链路上传送帧(frame)。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p><ul><li>物理层(physical layer)</li></ul><p>在物理层上所传数据的单位是比特。发送方发送1（或0）时，接收方应当收到1（或0)而不是0（或1）。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。当然，解释比特代表的意思，不是物理层的任务。请注意，传递信息所利用的一些物理传输媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而是在物理层协议的下面。因此也有人把物理层下面的物理传输媒体当作第0层。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829195444407.png" class="" title="image-20230829195444407"> <h4 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h4><ul><li>实体：实体(entity)这一较为抽象的名词表示任何可发送或接收信息的硬件或软件进程。在许多情况下，实体就是一个特定的软件模块。</li><li>协议：协议是控制两个对等实体（或多个实体)进行通信的规则的集合。</li></ul><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</p><p>首先，协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。也就是说，下面的协议对上面的实体是透明的。其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体“看得见”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>在同一系统中相邻两层的实体进行交互（即交换信息）的地方，通常称为服务访问点SAP(Service Access Point)。服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口，有点像邮政信箱（可以把邮件放入信箱和从信箱中取走邮件），但这种层间接口和两个设备之间的硬件接口（并行的或串行的）并不一样。OSI把层与层之间交换的数据的单位称为服务数据单元SDU(Service Data Unit),它可以与PDU不一样。例如，可以是多个SDU合成为一个PDU,也可以是一个SDU划分为几个PDU。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200113587.png" class="" title="image-20230829200113587"><h4 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP&#x2F;IP的体系结构"></a>TCP&#x2F;IP的体系结构</h4><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200230496.png" class="" title="image-20230829200230496">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(六)</title>
    <link href="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍参与运算的各类数据（包括无符号数和有符号数、定点数和浮点数等)，以及它们在计算机中的算术运算方法。</p><span id="more"></span><h3 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h3><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>测试</p><h4 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h4>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器(三)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此<br>外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。</p><span id="more"></span><h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><h5 id="3-1-1存储器的分类"><a href="#3-1-1存储器的分类" class="headerlink" title="3.1.1存储器的分类"></a>3.1.1存储器的分类</h5><p>按存储介质分类：</p><ul><li>半导体存储器TTL 、MOS</li><li>磁表面存储器    磁头、磁载体</li><li>磁芯存储器        硬磁材料、环中元件</li><li>光盘存储器        激光、磁光材料</li></ul><p>按存取方式分类：</p><p>​存取时间与物理地址无关（随机访问）</p><ul><li>随机存取器       在程序的执行过程中可读可写</li><li>只读存储器       在程序的执行过程中只读</li></ul><p>​存取时间与物理地址有关（串行访问）</p><ul><li>顺序存取存储器     磁带</li><li>直接存取存储器     磁盘</li></ul><p>按在计算机中的作用分类：</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114021837.png" class="" title="image-20230828114021837"><h5 id="3-1-2存储器的层次结构"><a href="#3-1-2存储器的层次结构" class="headerlink" title="3.1.2存储器的层次结构"></a>3.1.2存储器的层次结构</h5><ul><li>存储器三个主要特性的关系</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114241506.png" class="" title="image-20230828114241506"><ul><li>缓存 -主存层次和主存 -辅存层次</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114428289.png" class="" title="image-20230828114428289"><h4 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h4><h5 id="3-2-1概述"><a href="#3-2-1概述" class="headerlink" title="3.2.1概述"></a>3.2.1概述</h5><p>主存储器（简称主存）的基本结构已在第1章介绍过。实际上，根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p><h6 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114829534.png" class="" title="image-20230828114829534"><h6 id="主存与CPU的联系"><a href="#主存与CPU的联系" class="headerlink" title="主存与CPU的联系"></a>主存与CPU的联系</h6><p>现代计算机的主存都由半导体集成电路构成，图中的驱动器、译码器和读写电路均制作在存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和CPU芯片可通过总线连接</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115057618.png" class="" title="image-20230828115057618"><p>当要从存储器读出某一信息字时，首先由CPU将该字的地址送到MAR,经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读至数据总线上，至于该信息由MDR送至什么地方，这已不是主存的任务，而是由CPU决定的。若要向主存存入一个信息字时，首先CPU将该字所在主存单元的地址经MAR到地址总线，并将信息字送入MDR,然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写人到对应地址线指出的主存单元中。</p><h6 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h6><p>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写人一个存储字。不同的机器存储字长也不同，为了满足字符处理的需要，常用8位二进制数表示一个字节，因此存储字长都取8的倍数。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370机的字长为32位，它可按字节寻址，即它的每一个存储字包含4个可独立寻址的字节，其地址分配如图所示。字地址是用该字高位字节的地址来表示，故其字地址是4的整数倍，正好用地址码的末两位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115954328.png" class="" title="image-20230828115954328"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120051543.png" class="" title="image-20230828120051543"><p>由图所示，对24位地址线的主存而言，按字节寻址的范围是16M,按字寻址的范围<br>为4M。由图所示，对24位地址线而言，按字节寻址的范围仍为16M,但按字寻址的范<br>围为8M。</p><h6 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h6><ul><li>存储容量：主存 存放二进制代码的总位数<ul><li>存储容量&#x3D;存储单元个数 ×存储字长</li></ul></li><li>存储速度<ul><li>存取时间：存储器的访问时间、读出时间、写入时间</li><li>存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间读周期 写周期</li></ul></li><li>存储器带宽：位&#x2F;秒</li></ul><h5 id="3-2-2半导体存储芯片介绍"><a href="#3-2-2半导体存储芯片介绍" class="headerlink" title="3.2.2半导体存储芯片介绍"></a>3.2.2半导体存储芯片介绍</h5><h6 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120855844.png" class="" title="image-20230828120855844"><ul><li><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读&#x2F;写电路的配合下完成对被选中单元的读&#x2F;写操作。</p></li><li><p>读&#x2F;写电路包括读出放大器和写人电路，用来完成读&#x2F;写操作。</p></li><li><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p></li><li><p>地址线是单向输入的，其位数与芯片容量有关。</p></li><li><p>数据线是双向的（有的芯片可用成对出现的数据线分别作为输入或输出），其位数与芯片可<br>读出或写人的数据位数有关。数据线的位数与芯片容量有关。</p></li><li><p>地址线和数据线的位数共同反映存储芯片的容量。例如，地址线为10根，数据线为4根，测芯片容量为2×4&#x3D;4K位；又如地址线为14根，数据线为1根，则其容量为16K位。</p></li><li><p>控制线主要有读&#x2F;写控制线与片选线两种。不同存储芯片的读&#x2F;写控制线和片选线可以不同。有的芯片的读&#x2F;写控制线共用1根（如2114），有的分用两根（如6264）；有的芯片的片选线用1根（如2114），有的用2根（如6264)。读&#x2F;写控制线决定芯片进行读&#x2F;写操作，片选线用来选择存储芯片。由于半导体存储器是由许多芯片组成的，为此需用片选信号来确定哪个芯片被选中。例如，一个64K×8位的存储器可由32片16K×1位的存储芯片组成，如图所示。但每次读出一个存储字时，只需选中8片。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828122056796.png" class="" title="image-20230828122056796"></li></ul><h6 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h6><p>半导体存储芯片的译码驱动方式有两种：线选法和重合法</p><ul><li>线选法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123207033.png" class="" title="image-20230828123207033"><p>图是一个16×1字节线选法存储芯片的结构示意图。它的特点是用一根字选择线（字线)，直接选中一个存储单元的各位（如一个字节）。这种方式结构较简单，但只适于容量不大的存储芯片。如当地址线为1111时，则第15根字线被选中，对应图4.9中的最后一行8位代码便可直接读出或写人。</p><ul><li>重合法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123235418.png" class=""><p>图是一个1K×1位重合法结构示意图。显然，只要用64根选择线(X、Y两个方向各32根)，便可选择32×32矩阵中的任一位。例如，当地址线为全0时，译码输出X。和Y。有效，矩阵中第0行、第0列共同选中的那位即被选中。由于被选单元是由X、Y两个方向的地址决定的，故称为重合法。当欲构成1K×1字节的存储器时，只需用8片如图4.10所示的芯片即可。</p><h5 id="3-2-3随机存储器"><a href="#3-2-3随机存储器" class="headerlink" title="3.2.3随机存储器"></a>3.2.3随机存储器</h5><h6 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h6><p>存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路，图4.11是一个由6个MOS管组成的基本单元电路。</p><p>图中T1-T4是一个由MOS管组成的触发器基本电路，T5、T6犹如一个开关，受行地址选择信号控制。由T1~T6。这6个M0S管共同构成一个基本单元电路。T7、T8。受列地址选择控制，分别与位线A’和A相连，它们并不包含在基本单元电路内，而是芯片内同一列的各个基本单元电路所共有的。</p><p>假设触发器已存有“1”信号，即A点为高电平。当需读出时，只要使行、列地址选择信号均有效，则使T5、T6、T7、T8均导通，A点高电平通过T6后，再由位线A通过T8作为读出放大器的输入信号，在读选择有效时，将“1”信号读出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904132216809.png" class="" title="image-20230904132216809"><p>写入时不论触发器原状态如何，只要将写入代码送至图的D端，在写选择有效时，经两个写放大器，使两端输出为相反电平。当行、列地址选择有效时，使T5、T6、T7、T8导通，并将A与A’点置成完全相反的电平。这样，就把欲写人的信息写入到该基本单元电路中。如欲写人“1”,即D&#x3D;1,经两个写放大器使位线A为高电平，位线A’为低电平，结果使A点为高，A’点为低，即写人了“1”信息。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904133958930.png" class="" title="image-20230904133958930"><p>2114RAM芯片的结构示意图如图所示。图中存储矩阵由64×64个基本单元电路组成，列I&#x2F;0电路即读&#x2F;写电路。10根地址线分为行地址A8-A3和列地址A9、A2、A1、A0,4根数据线为I&#x2F;O4-I&#x2F;O0,,它们是受输入&#x2F;输出三态门控制的双向总线，当CS和WE均为低电平时，输人三态门打开，I&#x2F;O4-I&#x2F;O0,上的数据即写人到指定地址单元中。当CS为低电平、WE为高电平时，输出三态门打开，列1&#x2F;0电路的输出经片内总线输出至数据线I&#x2F;O4~I&#x2F;O0上。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904134637357.png" class="" title="image-20230904134637357"><p>2114RAM芯片内的存储矩阵结构如图所示。其中每一个小方块均为一个由6个M0S管组成的基本单元电路，排列成64×64矩阵，64列对应64对T7,、T8管。又将64列分成4组，每组包含16列，并与一个读&#x2F;写电路相连，读&#x2F;写电路受WE和CS控制，4个读&#x2F;写电路对应4根数据线I&#x2F;O0-I&#x2F;O4。由图中可见，行地址经译码后可选中某一行；列地址经译码后可选中4组中的对应列，共4列。当对某个基本单元电路进行读&#x2F;写操作时，必须被行、列地址共同选中。例如，当A9-A0为全0时，对应行地址A8-A3为000000，列地址A、A2、A,、A。也为0000，则第0行的第0、16、32、48这4个基本单元电路被选中。此刻，若做读操作，则CS为低电平，WE为高电平，在读&#x2F;写电路的输出端1&#x2F;O1-I&#x2F;O4便输出第0行的第0、16、32、48这4个基本单元电路所存的信息。若做写操作，将写人信息送至I&#x2F;O0-I&#x2F;O4端口，并使CS为低电平、WE为低电平，同样这4个输人信息将分别写入到第0行的第0、16、32、48这4个单元之中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135156790.png" class="" title="image-20230904135156790"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135227371.png" class="" title="image-20230904135227371"><h6 id="动态RAM-DRAM"><a href="#动态RAM-DRAM" class="headerlink" title="动态RAM(DRAM)"></a>动态RAM(DRAM)</h6><p>常见的动态RAM基本单元电路有三管式和单管式两种，它们的共同特点都是靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。电容上的电荷一般只能维持1~2s,因此即使电源不掉电，信息也会自动消失。为此，必须在2s内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。由于它与静态RAM相比，具有集成度更高、功耗更低等特点，目前被各类计算机广泛应用。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135533598.png" class="" title="image-20230904135533598"><p>读出时，先对预充电管T4置一预充电信号（在存储矩阵中，每一列共用一个T4管)，使读数据线达高电平VDD。然后由读选择线打开T2,若T1的极间电容Cg存有足够多的电荷（被认为原存“1”)，使T1导通，则因T2、T1导通接地，使读数据线降为零电平，读出“0”信息。若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，由读出线的高低电平可区分其是读“1”，还是读“0”，只是它与原存信息反相。写入时，将写人信号加到写数据线上，然后由写选择线打开T3,这样，C.便能随输入信息充电（写“1”）或放电（写“0”）。</p><p>为了提高集成度，将三管电路进一步简化，去掉T1,把信息存在电容Cs上，将T2、T3合并成一个管子T,便得到单管M0S动态RAM基本单元电路，如图4.18所示。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904140145043.png" class="" title="image-20230904140145043"><p>读出时，字线上的高电平使T导通，若C,有电荷，经T管在数据线上产生电流，可视为读出“1”。若Cs无电荷，则数据线上无电流，可视为读出“0”。读操作结束时，Cs的电荷已释放完毕，故是破坏性读出，必须再生。写人时，字线为高电平使T导通，若数据线上为高电平，经T管对0，充电，使其存“1”；若数据线为低电平，则C,经T放电，使其无电荷而存“0”。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164519993.png" class="" title="image-20230904164519993"><p>这是一个1K×1位的存储芯片，图中每一小方块代表由3个M0S管组成的动态RAM基本单元电路。它们排列成32×32的矩阵，每列都有一个刷新放大器(用来形成再生信息)和一个预充电管（图中未画），芯片有10根地址线，采用重合法选择基本单元电路。</p><p>读出时，先置以预充电信号，接着按行地址A9-A5经行译码器给出读选择信号，同时由列地址A4~A0。经列译码器给出列选择信号。只有在行、列选择信号共同作用下的基本单元电路才能将其信息经读数据线送到读&#x2F;写控制电路，并从数据线D输出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164942057.png" class="" title="image-20230904164942057"><p>写入时，在受行地址控制的行译码器给出的写选择信号的作用下；选中芯片的某一行，并在列地址的作用下，由列译码器的输出控制读&#x2F;写控制电路，只将数据线D的信息送到被选中列的写数据线上，信息即被写人到行列共同选中的基本单元电路中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165055182.png" class="" title="image-20230904165055182"><p>16K×1位的存储芯片共有16K个单管M0S基本单元电路，它们排列成128×128的矩阵，如图所示。图中的行线就是图4.18中的字线，列线就是图4.18中的数据线。128行分布在读放大器的左、右两侧（左侧为0<del>63行，右侧为64</del>127行）。每根行选择线与128个M0S管的栅极相连。128列共有128个读放大器，它的两侧又分别与64个M0S管相连，每根列线上都有一个列地址选择管。128个列地址选择管的输出又互相并接在一起与I&#x2F;0缓冲器相连，I&#x2F;0缓冲器的一端接输出驱动器，可输出数据；另一端接输入器，供数据输入</p><p>读出时，行、列地址受RAS和CAS控制，分两次分别存人行、列地址缓存器。行地址经行译码后选中一行，使该行上所有的M0S管均导通，并分别将其电容C,上的电荷反映到128个读放大器的某一侧（第0-63行反映到读放大器的左侧，第64-127行反映到读放大器的右侧）。读放大器的工作原理像一个撬撬板电路，类似于一个触发器，其左右两侧电平相反。此外列地址经列译码后选中某一列，该列上的列地址选择管导通，即可将读放大器右侧信号经读&#x2F;写线、I&#x2F;0缓冲器输出至Dout端。例如，选中第63行、第0列的单管MOS电路，若其C。有电荷为“1”状态，则反映到第0列读放大器的左侧为“1”，右侧为“0”，经列地址选择管输出至Dout为0，与原存信息反相。同理，第0-62行经读放大器至输出线Dout的信息与原存信息均反相。而读出第64~127行时，因它们的电容C。上的电荷均反映到读放大器的右侧，故经列地址选择管输出至Dout的信息均同相。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165802445.png" class="" title="image-20230904165802445"><p>写人时，行、列地址也要分别送人芯片内的行、列地址缓存器，经译码可选中某行、某列。输入信息D通过数据输人器，经I&#x2F;0缓冲器送至读&#x2F;写线上，但只有被选中的列地址选择管导通，可将读&#x2F;写线上的信息送至该列的读放大器右侧，破坏了读放大器的平衡，使读放大器的右侧与输人信息同相，左侧与输入信息反相，读放大器的信息便可写入到选中行的C,中。例如，选中第64行、第127列，输入信息为“1”，则第127列地址选择管导通，将“1”信息送至第127列的读放大器的右侧。虽然第64行上的128个M0S管均导通，但惟有第64行、第127列的M0S管能将读放大器的右侧信息“1”对C,充电，使其写入“1”。值得注意的是写人读放大器左侧行的信息与输入信息都是反相的，而由读出过程分析又知，对读放大器左侧行进行读操作时，读出的信息也是反相的，故最终结果是正确的。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165825227.png" class="" title="image-20230904165825227"><h6 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h6><p>由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的渎&#x2F;写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2s,这个时间称为刷新周期，又称再生周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证动态RAM内的信息不丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。</p><ul><li>集中刷新</li></ul><p>集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读&#x2F;写操作。例如，对128×128矩阵的存储芯片进行刷新时，若存取周期为0.55，刷新周期为2s(占4000个存取周期)，则对128行集中刷新共儒64us(占128个存取周期)，其余的1936s(共3872个存取周期)用来读&#x2F;写或维持信息，如图所示。由于在这64us时间内不能进行读&#x2F;写操作，故称为“死时间”，又称访存“死区”，所占比率28&#x2F;4000×100%&#x3D;3.2%,称为死时间率。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170137608.png" class="" title="image-20230904170137608"><ul><li>分散刷新</li></ul><p>分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期tc分成两段，前半段tm用来读&#x2F;写或维持信息，后半tr段用来刷新，即c&#x3D;tm+tr。若读&#x2F;写周期为0.5us,则存取周期为1s。仍以128×128矩阵的存储芯片为例，刷新按行进行，每隔128s就可将存储芯片全部刷新一遍，如图所示。这比允许的间隔2ms要短得多，而且也不存在停止读&#x2F;写操作的死时间，但存取周期长了，整个系统速度降低了。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170449800.png" class="" title="image-20230904170449800"><ul><li>异步刷新</li></ul><p>异步刷新是前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为2s的特点。例如，对于存取周期为0.5us,排列成128×128的存储芯片，可采取在2ms内对128行各刷新一遍，即每隔15.6s(2000s÷128≈15.6s)刷新一行，而每行刷新的时间仍为0.5s,如图所示。这样，刷新一行只停业一个存取周期，但对每行来说，刷新间隔时间仍为2ms,而“死时间”缩短为0.5心8。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170623026.png" class="" title="image-20230904170623026"><h6 id="动态RAM与静态RAM比较"><a href="#动态RAM与静态RAM比较" class="headerlink" title="动态RAM与静态RAM比较"></a>动态RAM与静态RAM比较</h6><p>目前，动态RAM的应用比静态RAM要广泛得多。其原因如下：</p><ul><li>在同样大小的芯片中，动态RAM的集成度远高于静态RAM,如动态RAM的基本单元电路为一个MOS管，静态RAM的基本单元电路可为4~6个MOS管。</li><li>动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少。</li><li>动态RAM的功耗比静态RAM小。</li><li>动态RAM的价格比静态RAM的价格便宜。当采用同一档次的实现技术时，动态RAM的容量大约是静态RAM容量的4-8倍，静态.RAM的存取周期比动态RAM的存取周期快8-16倍，但价格也贵8~16倍。.</li></ul><p>动态RAM也有缺点：</p><ul><li>由于使用动态元件（电容），因此它的速度比静态RAM低。</li><li>动态RAM需要再生，故需配置再生电路，也需要消耗一部分功率。通常，容量不大的高速缓冲存储器大多用静态RAM实现。</li></ul><h5 id="3-2-4只读存储器-ROM"><a href="#3-2-4只读存储器-ROM" class="headerlink" title="3.2.4只读存储器(ROM)"></a>3.2.4只读存储器(ROM)</h5><p>按R0M的原始定义，一且注入原始信息即不能改变，但随着用户的需要，总希望能任意修改ROM内的原始信息。这便出现了PROM、EPROM和EEPROM等。对半导体ROM而言，基本器件为两种：MOS型和TL型。</p><ul><li>掩模ROM(MROM)<ul><li>行列选择线交叉处有MOS管为“1”</li><li>行列选择线交叉处无MOS管为“0”</li></ul></li><li>PROM(一次性编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171603204.png" class="" title="image-20230904171603204"><ul><li>EPROM(多次编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171626849.png" class="" title="image-20230904171626849"><ul><li><p>EEPROM(多次性编程)</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul></li><li><p>Flash Memory(闪速型存储器)</p></li></ul><p>进入到20世纪.80年代，又出现了一种闪速存储器(lash Memory),又称快擦型存储器，它是在EPROM和EEPROM工艺基础上产生的一种新型的、具有性能价格比更好、可靠性更高的可擦写非易失性存储器。它既有EPROM的价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性。它具有整片擦除的特点，其擦除、重写的速度快。一块1M位的闪速存储芯片的擦除、重写时间小于5s,比一般标准的EEPROM快得多，已具备了RAM的功能，可与CPU直接连接。它还具有高速编程的特点，例如，采用快速脉冲编程算法对28256闪速存储芯片每字节的编程时间仅需100s。此外，该器件具有存储器访问周期短，功耗低及与计算机接口简单等优点。</p><h5 id="3-2-5存储器与CPU的连接"><a href="#3-2-5存储器与CPU的连接" class="headerlink" title="3.2.5存储器与CPU的连接"></a>3.2.5存储器与CPU的连接</h5><h6 id="存储芯片的扩展"><a href="#存储芯片的扩展" class="headerlink" title="存储芯片的扩展"></a>存储芯片的扩展</h6><ul><li>位扩展</li></ul><p>位扩展是指增加存储字长，例如，2片1K×4位的芯片可组成1K×8位的存储器，如图所示。图中2片2114的地址线A9-A0,、CS、WE都分别连在一起，其中一片的数据线作为高4位D7-D4,另一片的数据线作为低4位D3~D0。这样，便构成了一个1K×8位的存储器。（10根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172431505.png" class="" title="image-20230904172431505"><ul><li>字扩展</li></ul><p>字扩展是指增加存储器字的数量。例如，用2片1K×8位的存储芯片可组成一个2K×8位的存储器，即存储字增加了一倍，如图所示。在此，将A10用做片选信号。由于存储芯片的片选输入端要求低电平有效，故当A10为低电平时，CS0有效，选中左边的1K×8位芯片；当A10为高电平时，反相后CS1有效，选中右边的1K×8位芯片。（11根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172643451.png" class="" title="image-20230904172643451"><ul><li>位、字扩展</li></ul><p>字、位扩展是指既增加存储字的数量，又增加存储字长。图示意用8片1K×4位的芯片组成4K×8位的存储器。（12根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172920491.png" class="" title="image-20230904172920491"><p>由图中可见，每2片构成一组1K×8位的存储器，4组便构成4K×8位的存储器。地址线A11、A10经片选译码器得到4个片选信号CS0、CS1、CS2、CS3,分别选择其中1K×8位的存储芯片。WE为读&#x2F;写控制信号。</p><h6 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h6><p>存储芯片与CPU芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。</p><ul><li>地址线的连接</li></ul><p>存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU地址线的低位与存储芯片的地址线相连。CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。例如，设CPU地址线为16位A15-A0。,1K×4位的存储芯片仅有10根地址线A9-A0。,此时，可将CPU的低位地址A9-A0与存储芯片地址线A9-A0相连。又如，当用16K×1位存储芯片时，则其地址线有14根A13-A0。,此时，可将CPU的低位地址A13-A0。与存储芯片地址线A13~A0相连。</p><ul><li>数据线的连接</li></ul><p>同样，CPU的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p><ul><li>读&#x2F;写命令线的连接</li></ul><p>CPU读&#x2F;写命令线一般可直接与存储芯片的读&#x2F;写控制端相连，通常高电平为读，低电平为写。有些CPU的读&#x2F;写命令线是分开的，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p><ul><li>片选线的连接</li></ul><p>片选线的连接是CPU与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。片选有效信号与CPU的访存控制信号MREQ(低电平有效)有关，因为只有当CPU要求访存时，才需选择存储芯片。若CPU访问I&#x2F;O，则MRE0为高电平，表示不要求存储器工作。此外，片选有效信号还和地址有关，因为CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。通常需用到一些逻辑电路，如译码器及其他各种门电路，来产生片选有效信号。</p><ul><li>合理选择存储芯片</li></ul><p>合理选择存储芯片主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽重使连线简单方便。</p><h5 id="3-2-6存储器的校验"><a href="#3-2-6存储器的校验" class="headerlink" title="3.2.6存储器的校验"></a>3.2.6存储器的校验</h5><p>在计算机运行过程中，由于种种原因致使数据在存储过程中可能出现差错。为了能及时发现错误并及时纠正错误，通常可将原数据配成汉明编码。</p><h6 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h6><p>任意两组合法代码之间二进制位数的最少差异编码的纠错、检错能力与编码的最小距离有关</p><p>L-1&#x3D;D+C(D&gt;&#x3D;C)</p><ul><li>L:编码的最小距离  L&#x3D;3</li><li>D:检测错误的位数 具有一<strong>位</strong>纠错</li><li>C:纠正错误的位数</li></ul><p>汉明码是具有一位纠错能力的编码</p><h6 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h6><p>汉明码的三要素</p><ul><li>汉明码的组成需增添？位检测位</li></ul><p>$$<br>2^k&gt;&#x3D;n+k+1<br>$$</p><ul><li>检测位的位置?</li></ul><p>$$<br>2^i(i&#x3D;0,1,2,3,……)<br>$$</p><ul><li>检测为的取值？</li></ul><p>检测位的取值与该位所在的检测“小组”中承担的奇偶校验任务有关</p><h5 id="3-2-7提高访存速度的措施"><a href="#3-2-7提高访存速度的措施" class="headerlink" title="3.2.7提高访存速度的措施"></a>3.2.7提高访存速度的措施</h5><p>随着计算机应用领域的不断扩大，处理的信息量越来越多，对存储器的工作速度和容量要求也越来越高。此外，因CPU的功能不断增强，&#x2F;0设备的数量不断增多，致使主存的存取速度已成为计算机系统的瓶颈。可见，提高访存速度也成为迫不及待的任务。为了解决此问题，除了寻找高速元件和采用层次结构以外，调整主存的结构也可提高访存速度。</p><ul><li>单体多字系统</li></ul><p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可以在一个存取周期内，从同一地址取出4条指令，然后再逐条将指令送至CPU执行，即每隔1&#x2F;4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183437547.png" class="" title="image-20230904183437547"><p>图中示意了一个单体四字结构的存储器，每字W位。按地址在一个存取周期内可读出4×W位的指令或数据，使主存带宽提高到4倍。显然，采用这种办法的前提是：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p><ul><li>多体并行系统</li></ul><p>多体并行系统就是采用多体模块组成的存储器。每个模块有相同的容量和存取速度，各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读&#x2F;写电路，它们能并行工作，又能交叉工作。并行工作即同时访问N个模块，同时启动，同时读出，完全并行地工作（不过，同时读出的N个字在总线上需分时传送)。图4.42是适合于并行工作的高位交叉编址的多体存储器结构示意图，图中程序因按体内地址顺序存放（一个体存满后，再存人下一个体），故又有顺序存储之称。显然，高位地址可表示体号，低位地址为体内地址。按这种编址方式，只要合理调动，使不同的请求源同时访问不同的体，便可实现并行工作。例如，当一个体正与CPU交换信息时，另一个体可同时与外部设备进行直接存储器访问，实现两个体并行工作。这种编址方式由于一个体内的地址是连续的，有利于存储器的扩充。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183724260.png" class="" title="image-20230904183724260"><p>下图是按低位交叉编址的多体模块结构示意图。由于程序连续存放在相邻体中，故又有交叉存储之称。显然低位地址用来表示体号，高位地址为体内地址。这种编址方法又称为模M编址(M等于模块数)，表4.3列出了模4交叉编址的地址号。一般模块数M取2的方幂，使硬件电路比较简单。有的机器为了减少存储器冲突，采用质数个模块，例如，我国银河机的M为31,其硬件实现比较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183908836.png" class="" title="image-20230904183908836"><ul><li>高性能存储芯片<ul><li>SDRAM(同步DRAM):在系统时钟的控制下进行读入和写出，CPU无需等待</li><li>RDRAM:有Rambus开发，只要解决存储宽带问题</li><li>带Cache的DRAM:在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</li></ul></li></ul><h4 id="3-3高速缓冲存储器"><a href="#3-3高速缓冲存储器" class="headerlink" title="3.3高速缓冲存储器"></a>3.3高速缓冲存储器</h4><h5 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h5><p>在多体并行存储系统中，由于I&#x2F;O设备向主存请求的级别高于CPU访存，这就出现了CPU等待&#x2F;0设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU的工作效率。为了避免CPU与I&#x2F;O设备争抢访存，可在CPU与主存之间加一级缓存，这样，主存可将CPU要取的信息提前送至缓存，一旦主存在与&#x2F;0设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。从另一角度来看，主存速度的提高始终跟不上CPU的发展。据统计，CPU的速度平均每年改进60%，而组成主存的动态RAM速度平均每年只改进7%，结果是CPU和动态RAM之间的速度间隙平均每年增大50%。例如，100MHz的Pentium处理器平均每10ns就执行一条指令，而动态RAM的典型访问时间为60~120ns。这也希望由高速缓存Cache来解决主存与CPU速度的不匹配问题。</p><p>Cache的出现使CPU可以不直接访问主存，而与高速Cache交换信息。那么，这是否可能呢？通过大量典型程序的分析，发现CPU从主存取指令或取数据，在一定时间内，只是对主存局部地址区域的访问。这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用（如子程序、循环程序和一些常数），即指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性，这就称为程序访问的局部性原理。根据这一原理，很容易设想，只要将CPU近期要用到的程序和数据提前从主存送到Cache,那么就可以做到CPU在一定时间内只访问Cache.。一般Cache采用高速的SRAM制作，其价格比主存贵，但因其容量远小于主存，因此能很好地解决速度和成本的矛盾。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904184832650.png" class="" title="image-20230904184832650"><h6 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h6><p>任何时刻都有一些主存块处在缓存块中。CPU欲读取主存某字时，有两种可能：一种是所需要的字已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字)；另一种是所需的字不在Cache内，此时需将该字所在的主存整个字块一次调入Cache中(Cache与主存之间是字块传送)。如果主存块已调入缓存块，侧称该主存块与缓存块建立了对应关系。</p><p>上述第一种情况为CPU访问Cache命中，第二种情况为CPU访问Cache不命中。由于缓存的块数C远小于主存的块数M,因此，一个缓存块不能惟一地、永久地只对应一个主存块，故每个缓存块需设一个标记，用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位（或m位中的一部分）与缓存块的标记进行比较，以判断所读的信息是否已在缓存中。</p><p>Cache的容量与’块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。命中率是指CPU要访问的信息已在Cache内的比率。</p><h6 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904190947078.png" class="" title="image-20230904190947078"><ul><li>Cache存储体</li></ul><p>Cache存储体以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高。</p><ul><li>地址映射变换机构</li></ul><p>地址映射变换机构是将CPU送来的主存地址转换为Cache地址。由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。而地址变换又与主存地址以什么样的函数关系映射到Cache中（称为地址映射）有关</p><ul><li>替换机构</li></ul><p>当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache.。有关替换算法详见特别需指出的是，Cache对用户是透明的，即用户编程时所用到的地址是主存地址，用户根术不知道这些主存块是否已调入Cache内。因为，将主存块调入Cache的任务全由机器硬件自动完成。</p><ul><li>Cache的读写操作</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904195651008.png" class="" title="image-20230904195651008"><p>写操作比较复杂，因为对Cache块内写人的信息，必须与被映射的主存块内的信息完全一致。当程序运行过程中需对某个单元进行写操作时，会出现如何使Cache与主存内容保持一致的问题。目前主要采用以下几种方法。</p><ul><li>写直达法</li></ul><p>写直达法(Write-through),又称为存直达法（Store-through),即写操作时数据既写入Cache又写入主存。它能随时保证主存和Cache的数据始终一致，但增加了访存次数。</p><ul><li>写回法</li></ul><p>写回法(Write-back),又称为拷回法(Copy-back),即写操作时只把数据写入Cache而不写入主存，但当Cache数据被替换出去时才写回主存。可见写回法Cache中的数据会与主存中的不一致。为了识别Cache中的数据是否与主存一致，Cache中的每一块要增设一个标志位，该位有两个状态：“清”（表示未修改过，与主存一致）和“浊”（表示修改过，与主存不一致)。在Cache替换时，“清”的Cache块不必写回主存，因为此时主存中相应块的内容与Cache块是一致的。在写Cache时，要将该标志位设置为“浊”，替换时此Cache块要写回主存，同时要使标志位为“清”。</p><h6 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h6><p>Cache刚出现时，典型系统只有一个缓存，近年来普遍采用多个Cache。其含义.有两方面：一是增加Cache的级数；二是将统一的Cache变成分立的Cache</p><ul><li>单一缓存和二级缓存：片内Cache、片外Cache</li><li>统一缓存和分立缓存：统一缓存是指指令和数据都存放在同一缓存内的Cache;分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令Cache,一个称为数据Cache。.两种缓存的选用主要考虑如下两个因素。其一，它与主存结构有关，如果计算机的主存是统一的（指令、数据存储在同一主存内），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。其二，它与机器对指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般都采用分立缓存。</li></ul><h5 id="3-3-2-Cache——主存地址映射"><a href="#3-3-2-Cache——主存地址映射" class="headerlink" title="3.3.2 Cache——主存地址映射"></a>3.3.2 Cache——主存地址映射</h5><p>由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射（固定的映射关系)、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。</p><ul><li>直接映射</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201458711.png" class="" title="image-20230904201458711"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201608551.png" class="" title="image-20230904201608551"><p>这种方式的优点是实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。由图可见，主存地址高m位被分成两部分：低c位是指Cace的字块地址，高t位(t&#x3D;m一c)是指主存字块标记，它被记录在建立了对应关系的缓存块的“标记”位中。当缓存接到CPU送来的主存地址后，只儒根据中间c位字段（假设为00…01）找到Cache字块1，然后根据字块1的“标记”是否与主存地址的高t位相符来判断，若符合且有效位为“1”（有效位用来识别Cache存储块中的数据是否有效，因为有时Cache中的数据是无效的，例如，在初始时刻Cache应该是“空”的，其中的内容是无意义的)，表示该Cache块已和主存的某块建立了对应关系（即已命中)，则可根据b位地址从Cace中取得信息；若不符合，或有效位为“0”（即不命中)，则从主存读人新的字块来替代旧的字块，同时将信息送往CPU,并修改Cache“标记”。如果原来有效位为“0”，还得将有效位置成“1”。</p><p>直接映射方式的缺点是不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><ul><li>全相联映射</li></ul><p>全相联映射允许主存中每一字块映射到Cache中的任何一块位置上，如图所示。这种映射方式可以从已被占满的Cache中替换出任一旧字块。显然，这种方式灵活，命中率也更高，缩小了块冲突率。与直接映射相比，它的主存字块标记从t位增加到：t+c位，这就使Cache“标记”的位数增多，而且访问Cache时主存字块标记需要和Cache的全部“标记”位进行比较，才能判断出所访问主存地址的内容是否已在Cache内。这种比较通常采用“按内容寻址”的相联存储器（见附录4A)来完成。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904202232710.png" class="" title="image-20230904202232710"><p>总之，这种方式所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。</p><ul><li>组相联映射</li></ul><p>组相联映射是对直接映射和全相联映射的一种折中。它把Cache分为Q组，每组有R块，并有以下关系：</p><p>i&#x3D;j mod Q</p><p>其中，i为缓存的组好，j为主存的块号。某一主存块按模Q将其映射到级存的第i组内</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904203103631.png" class="" title="image-20230904203103631"><ul><li>直接 ：某一 主存块只能固定映射到某一缓存块 </li><li>全相联 ：某一主存块能映射到任一缓存块</li><li>组相联  ：某一主存块只能映射到某一缓存组中的任一块</li></ul><h5 id="3-3-3替换策略"><a href="#3-3-3替换策略" class="headerlink" title="3.3.3替换策略"></a>3.3.3替换策略</h5><ul><li>先进先出（First-In-First-Out,FIFO）</li></ul><p>FIF0算法选择最早调入Cache的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，开销小，但没有根据访存的局部性原理，故不能提高Cache的命中率。因为最早调人的信息可能以后还要用到，或者经常要用到，如循环程序。</p><ul><li>近期最少使用算法(Least Recently Used,LRU）</li></ul><p>LRU算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它需要随时记录Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU算法的平均命中率比FIFO的高。</p><ul><li>随机法</li></ul><p>随机法是随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块，但它也没有根据访存的局部性原理，故不能提高Cache的命中率。</p><h4 id="3-4辅助存储器"><a href="#3-4辅助存储器" class="headerlink" title="3.4辅助存储器"></a>3.4辅助存储器</h4><h5 id="3-4-1概述"><a href="#3-4-1概述" class="headerlink" title="3.4.1概述"></a>3.4.1概述</h5><p>辅助存储器作为主存的后援设备又称为外部存储器，简称外存，它与主存一起组成了存储器系统的主存一辅存层次。与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。而主存具有速度快、成本高、容量小等特点，而且大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。</p><p>目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。</p><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul><li>不能直接与CPU交换信息</li></ul><h6 id="磁表面存储技术"><a href="#磁表面存储技术" class="headerlink" title="磁表面存储技术"></a>磁表面存储技术</h6><ul><li>记录密度</li><li>存储容量</li><li>平均寻址时间 </li><li>数据传输率 </li><li>误码率 辅存的速</li></ul><h5 id="3-4-2磁记录原理和记录方式"><a href="#3-4-2磁记录原理和记录方式" class="headerlink" title="3.4.2磁记录原理和记录方式"></a>3.4.2磁记录原理和记录方式</h5><ul><li>磁记录原理</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204226140.png" class="" title="image-20230904204226140"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204245123.png" class="" title="image-20230904204245123"><ul><li>磁表面存储器的记录方式</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204359480.png" class="" title="image-20230904204359480"><h5 id="3-4-3硬度磁盘存储器"><a href="#3-4-3硬度磁盘存储器" class="headerlink" title="3.4.3硬度磁盘存储器"></a>3.4.3硬度磁盘存储器</h5><h6 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h6><ul><li>固定磁头和移动磁头 </li><li>可换盘和固定盘</li></ul><h6 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204604155.png" class="" title="image-20230904204604155"><p>硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片3大部分组成</p><ul><li>磁盘驱动器</li></ul><p>磁盘驱动器是主机外的一个独立装置，又称磁盘机。大型磁盘驱动器要占用一个或几个机柜，温盘只是一个比砖还小的小匣子。驱动器主要包括主轴、定位驱动及数据控制等3部分。图示意了磁盘驱动器的主轴系统和定位驱动系统。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204817860.png" class="" title="image-20230904204817860"><ul><li><p>磁盘控制器</p><ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令 </li><li>实现主机和驱动器之间的数据格式转换 </li><li>控制磁盘驱动器读写</li></ul><p>磁盘控制器是主机与磁盘驱动器之间的接口</p></li><li><p>盘片：由硬质铝合金材料制成</p></li></ul><h5 id="3-4-4软磁盘存储器"><a href="#3-4-4软磁盘存储器" class="headerlink" title="3.4.4软磁盘存储器"></a>3.4.4软磁盘存储器</h5><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>高</td><td>低</td></tr><tr><td>磁头</td><td>固定、活动、浮动</td><td>活动</td></tr><tr><td>盘片</td><td>固定盘、盘组 大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>环境</td><td>苛刻</td><td></td></tr></tbody></table><h5 id="3-4-7光盘存储器"><a href="#3-4-7光盘存储器" class="headerlink" title="3.4.7光盘存储器"></a>3.4.7光盘存储器</h5><p>采用光存储技术 采用非磁性介质 采用磁性介质 </p><p>第一代光存储技术 不可擦写</p><p>第二代光存储技术  可擦写</p><h6 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h6><p>只读型和只写一次型 热作用（物理或化学变化）</p><p>可擦写光盘  热磁效应 </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线(二)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章着重介绍系统总线的基本概念及其分类、结构和总线控制，逻辑。要求读者能对系统总<br>线在计算机硬件结构中的地位和作用有所了解。</p><span id="more"></span><h4 id="2-1系统总线的基本概念"><a href="#2-1系统总线的基本概念" class="headerlink" title="2.1系统总线的基本概念"></a>2.1系统总线的基本概念</h4><h5 id="2-1-1什么是总线？"><a href="#2-1-1什么是总线？" class="headerlink" title="2.1.1什么是总线？"></a>2.1.1什么是总线？</h5><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p><h5 id="2-1-2总线上的信息传送"><a href="#2-1-2总线上的信息传送" class="headerlink" title="2.1.2总线上的信息传送"></a>2.1.2总线上的信息传送</h5><p>串行</p><p>并行</p><h4 id="2-2-总线的分类"><a href="#2-2-总线的分类" class="headerlink" title="2.2 总线的分类"></a>2.2 总线的分类</h4><h5 id="2-2-1-片内总线"><a href="#2-2-1-片内总线" class="headerlink" title="2.2.1 片内总线"></a>2.2.1 片内总线</h5><p>片内总线：指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间，寄存器与算逻单元ALU之间都由片内总线连接</p><h5 id="2-2-2-系统总线"><a href="#2-2-2-系统总线" class="headerlink" title="2.2.2 系统总线"></a>2.2.2 系统总线</h5><p>系统总线分三类：数据总线、地址总线、控制总线</p><p>数据总线：用来传输各个功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关</p><p>地址总线：主要用来指出数据总线上的源数据或目的数据在主存单元的地址或I&#x2F;O设备地址，单项传输，与存储地址、I&#x2F;O地址有关</p><p>控制总线：用来发出各种控制信号的传输线，控制信号有输入（存储器读、存储器写、总线允许、中断确认）；控制信号有输出（中断请求、总线请求）</p><p>常见的控制型号如下：</p><ul><li>时钟：用来同步各个操作</li><li>复位：初始化所有部件</li><li>总线请求：表示某部件需获得总线使用权</li><li>总线允许：表示需要获得总线使用权的部件以获得控制权</li><li>中断请求：表示某部件提出中断请求</li><li>中断响应：表示中断请求已被接收</li><li>存储器写：将数据总线上的数据写至存储器的指定单元内</li><li>存储器读：将指定存储单元中的数据读到数据总线上</li><li>I&#x2F;O读：从指定的I&#x2F;O端口将数据读到数据总线上</li><li>I&#x2F;O写：将数据总线上的数据输出到指定的I&#x2F;O端口内</li><li>传输响应:表示数据应被接受，或已将数据送至数据总线上</li></ul><h5 id="2-2-3-通信总线"><a href="#2-2-3-通信总线" class="headerlink" title="2.2.3 通信总线"></a>2.2.3 通信总线</h5><p>通信总线：用于计算机系统之间或计算机系统与其他系统（控制仪表、移动通信等）之间的通信</p><p>传输方式：串行通信总线、并行同行总线</p><p>串行总线：是指数据在单条1位宽的传输线上，一位一位地按顺序分时传送，如1字节的数据，在串行传送中，1字节的数据要通过8此有地位到高位按顺序逐位传输</p><p>并行总线：是指数据在多条并行在1位宽的传输线上，同时由源传送到目的地，如1字节的数据，在并行传送中，要通过8条并行传输线同时由源传送到目的地。</p><h4 id="2-3总线特性及性能指标"><a href="#2-3总线特性及性能指标" class="headerlink" title="2.3总线特性及性能指标"></a>2.3总线特性及性能指标</h4><h5 id="2-3-1-总线的特征"><a href="#2-3-1-总线的特征" class="headerlink" title="2.3.1 总线的特征"></a>2.3.1 总线的特征</h5><ul><li>机型特性：尺寸、形状、管脚数 及排列顺序</li><li>电器特性：传输方向和有效的电平范围</li><li>功能特性：每根传输线的功能</li></ul><p>​功能分类：地址、数据、控制</p><p>​地址总线：用来指出地址码</p><p>​数据总线：用来传递数据</p><p>​控制总线：发出信号控制，既有从CPU发出的如存储器的读&#x2F;写、I&#x2F;O的读&#x2F;写，也有I&#x2F;O向CPU发来的，如中断请求、DMA请求</p><ul><li>时间特性：信号的时序关系</li></ul><h5 id="2-3-2-总线性能指标"><a href="#2-3-2-总线性能指标" class="headerlink" title="2.3.2 总线性能指标"></a>2.3.2 总线性能指标</h5><ul><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟同步&#x2F;异步：同步、不同步</li><li>总线复用：地址线与数据线复用</li><li>信号线数：地址线、数据线、控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、技术</li><li>其他指标：负载能力</li></ul><h5 id="2-3-3总线标准"><a href="#2-3-3总线标准" class="headerlink" title="2.3.3总线标准"></a>2.3.3总线标准</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110537846.png" class="" title="image-20230828110537846"><h4 id="2-4总线结构"><a href="#2-4总线结构" class="headerlink" title="2.4总线结构"></a>2.4总线结构</h4><h5 id="2-4-1-单总线结构"><a href="#2-4-1-单总线结构" class="headerlink" title="2.4.1 单总线结构"></a>2.4.1 单总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110613375.png" class="" title="image-20230828110613375"><h5 id="2-4-2多总线结构"><a href="#2-4-2多总线结构" class="headerlink" title="2.4.2多总线结构"></a>2.4.2多总线结构</h5><p>双总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110652825.png" class="" title="image-20230828110652825"><h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110711335.png" class="" title="image-20230828110711335"><p>三总线的另一结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110728329.png" class="" title="image-20230828110728329"><h5 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110750849.png" class="" title="image-20230828110750849"><h5 id="2-4-3总线结构举例"><a href="#2-4-3总线结构举例" class="headerlink" title="2.4.3总线结构举例"></a>2.4.3总线结构举例</h5><p>传统微型机总线</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110815002.png" class="" title="image-20230828110815002"><p>VL-BUS局部总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110840540.png" class="" title="image-20230828110840540"><p>PCI总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110904069.png" class="" title="image-20230828110904069"><p>多层 PCI 总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110922273.png" class="" title="image-20230828110922273"><h4 id="2-5总线控制"><a href="#2-5总线控制" class="headerlink" title="2.5总线控制"></a>2.5总线控制</h4><h5 id="2-5-1-总线判优控制"><a href="#2-5-1-总线判优控制" class="headerlink" title="2.5.1 总线判优控制"></a>2.5.1 总线判优控制</h5><p>基本概念：</p><ul><li><p>主模块对总线有控制权</p></li><li><p>从模块        响应从主设备发来的总线命令</p></li><li><p>总线判优控制：集中式、分布式</p><p>集中式包括：</p><ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li></ul><p>链式查询方式</p><p>下图为链式查询，图中控制总线有3根线用于总线控制（BS总线忙、BR总线请求、BG总线统一），其中总线同意是串行的一个I&#x2F;O接口送至下一个I&#x2F;O接口。如果BG达到的接口有请求，BG信号就不再往下传，意味着改接口获得了总线的使用全，并建立总线忙BS信号，表示它占用了总线，可见在链式查询中，离总线控制部件最近的设备具有最高的优先级。这种方式的特点是：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，！对电路故障很敏感，且优光级别低的设备可能很难获得请求。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111006976.png" class="" title="image-20230828111006976"><p>计数器定时查询方式</p><p>下图是计数器定时查询方式。与链式查询方式相比，多了一组设备地址线，少了一<br>根总线同意线BG。总线控制部件接到由BR送来的总线请求信号后，在总线未被使用(BS&#x3D;0)<br>的情况下，总线控制部件屮的计数器开始计数，并通过设备地址线.向各设备发出一组地址信号。<br>当某个请求占用总线的设备地址与计数值一致时，便获得总线使用权，此吋终止计数查询。这种<br>方式的特点是：计数可以从“0”开始，此时一且设备的优先次序被固定，设备的优先级就按<br>0,1,…,n的顺序降序排列，而且固定不变；计数也可以从上一次计数的终止点开始，即是一种循<br>环方法，此时设备使用总线的优先级相等；计数器的初始值还可由程序设置，战优先次序可以改变。<br>这种方式对电路故障不如链式查询方式敏感，但增加了控制线（设备地址）数，控制也较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111057390.png" class="" title="image-20230828111057390"><p>​独立亲求方式</p><p>下图是独立请求方式。由图中可见，每一台设备均有一对总线请求线BR,和总线同意线BG:。当设备要求使用总线时，便发出该设备的请求信号。总线挖制部件中有一排队电路，可根据优先次序确定响应哪一台设备的靖求。这种方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），似控制线数量多，总线控删更复杂。链式查询中仪用两根线确定总线使用权属于哪个设备，在计数器查询巾大致用log2 n根线，其中n是允许接纳的最大设备数，而独立请求方式需采用2n根线。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111148122.png" class="" title="image-20230828111148122"><h5 id="1-5-2总线通信控制"><a href="#1-5-2总线通信控制" class="headerlink" title="1.5.2总线通信控制"></a>1.5.2总线通信控制</h5><p>目的：解决通信双方协调配合问题</p><p>总线传输周期：</p><ul><li>中请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者。</li><li>寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与木次传输的从模块。</li><li>传数阶段：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流人目的模块。</li><li>结束阶段：主模块的有关信息均从系统总线上撒除，让出总线使用权。</li></ul><p>总线通信的四种方式：</p><ul><li>同步通信：有统一时标控制数据传送</li><li>异步通信：采用应答方式，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统 总线每个瞬间的潜力</li></ul><p>某个输入设备向CPU传输数据的同步通信（同步式数据输入传输）</p><p>对于读命令，其传输周期如下：</p><ul><li>T1:主模块发地址。</li><li>T2:主模块发读命令。</li><li>T3:从模块提供数据。</li><li>T4:主模块撤销读命令，从模央撤销数据。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111244151.png" class="" title="image-20230828111244151"><p>图中总线传输周期是连接在总线上的两个部件完成一次完整且可靠的信息传输时间，它包<br>含4个时钟周期T1、T2、T3、T4。<br>        CPU在T1上升沿发出地址信息；在T2的上升沿发出读命令；与地址信号相符合的输入设备<br>按命令进行一系列内部操作，且必须在T3的上升沿到来之前将CPU所需的数据送到数据总线<br>上：CPU在T3时钟周期内，将数据线上的信息送到其内部寄存器中；CPU在T4的上升沿撤销读<br>命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。如果总线采用三态驱动<br>电路，则从T4起，数据总线呈浮空状态。</p><p>同步式数据输出传输</p><p>对于写命令，其传输周期如下：</p><ul><li>T1:主模块发地址</li><li>T1.5：主模块提供数据。</li><li>T2：主模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到<br>地址总线所指明的单元中。</li><li>T4：主模块撤销写命令和数据等信号。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111309016.png" class="" title="image-20230828111309016"><p>这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性“同步”，必须在限定时问内完成规定的要求。并对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而市，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏贝活性。</p><p>同步通信一般用于总线长度较短、各部件存取时问比较一致的场合。</p><p>在同步通信的总线系统中，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率。</p><p>异步通信</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111331035.png" class="" title="image-20230828111331035"><p>1、不互锁方式</p><p>主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块<br>已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并<br>且经过一段时问（这段时问的设置对不同设备而言是不同的）确认主模块已收到回答信号后，自<br>动撤销回答信号。可见通信双方并无互锁关系。例如，CPU向主存写信息，CPU要先后给出地<br>址信号、写命令以及写入数据，即采用此种方式。</p><p>2、半互锁方式</p><p>主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系：而<br>从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一<br>段时间后自动撒销其回答信号，无互锁关系。由于一方存在互锁关系，一方不存在互锁关系，故<br>称半互锁方式。例如，在多机系统中，某个CPU需访问共享存储器（供所有CPU访问的存储器）<br>时，该CPU发出访存命令后，必须收到存储器未被占用的回答信号，才能真正进行访存操作。</p><p>3、全互锁</p><p>主模块发出请求信号，必须待从模块回答后再撤销其请求信号；从模块发出回答信号，必须<br>待获知主模块请求信号已撤销后，再撤销其回答信号。双方存在互锁关系，故称为全互锁方式。<br>例如，在网络通信中，通信双方采用的就是全互锁方式。</p><p>半同步通信（同步、异步结合）</p><ul><li>同步:发送方用系统 时钟前沿 发信号；接收方用系统 时钟后沿 判断、识别</li><li>异步：允许不同速度的模块和谐工作，增加一条 “等待”响应信号 WAIT</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828112117228.png" class="" title="image-20230828112117228"><p>以输入数据为例的半通信时序</p><ul><li><p>T1:主模块发出地址信息</p></li><li><p>T2：主模块发出命令</p></li><li><p>T2当WAIT为低电平时，进入等待，Tw的宽度与T的宽度一致。</p></li><li></li><li></li><li></li><li><p>T3:从模块提供数据。</p></li><li><p>T4:主模块撤销读命令，从模块撤销数据。</p></li></ul><p>上述三种通信的共同电：</p><ul><li>主模块发地址、命令占用总线</li><li>从模块准备数据        不占用总线  总线空闲</li><li>从模块向主模块发数据     占用总线</li></ul><p>分离式通信</p><p>以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结束。在整个传输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期，发现除了中请总线这一阶段外，其余时间主要花费在如下3个方面。<br>①主模块通过传输总线向从模块发送地址和命令。<br>②从模块按照命令进行读数据的必要淮备。<br>③从模块经数据总线向主模块提供数据。·<br>由②可见，对系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待，为了克服和利用这种消极等待，尤其在大型计算机系统中，总线的负载已处于饱和状态，充分挖掘系统总线每瞬间的潜力，对提高系统性能起到极大作用。为此人们又提出了“分离式”的通信方式，其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第一个子周期中，主模块A在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号（当有多个主模块时，此编号尤为重要)发到系统总线上，经总线传输后，由有关的从模块B接收下来。主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使州权，以便其他模块使用。在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将A模块所需的数据准备好，使出B模块中请总线使用权，一旦获谁，B模块便将A模块的编号、B模块的地址、A模块所器的数据等一系列信息送到总线上，供A模块接收。很明显，上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。</p><p>分离式通信特点：</p><ul><li>各模块欲占用总线使用权都必须提出申请。</li><li>在得到总线使用权后，主模块在限定的刷间内向对方传送信总，采用同步方式传送，不再等待对方的回答信号。</li><li>各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。</li><li>总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概论(一)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍计算机的组成概貌及工作原理，旨在使读者对计算机总体结构有一个概括的<br>了解，为深入学习后面各章打下基础。</p><span id="more"></span><h4 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h4><h5 id="1-1-1-计算机的软硬件概念"><a href="#1-1-1-计算机的软硬件概念" class="headerlink" title="1.1.1 计算机的软硬件概念"></a>1.1.1 计算机的软硬件概念</h5><p><strong>计算机系统有“硬件”和“软件”两大部分组成。</strong></p><p>​<strong>硬件</strong>：计算机的实体，如主机、外设等</p><p>​<strong>软件</strong>：由具有各类特殊的功能的信息（程序）组成</p><p>软件可以分为</p><p>​<strong>系统软件</strong>：用来管理整个计算机系统 。如 语言处理程序、操作系统、服务型程序、数据库管理系统、网络软件</p><p>​<strong>应用软件</strong>：按任务需要编制成的各种程序</p><h5 id="1-1-2-计算机系统的成层次结构"><a href="#1-1-2-计算机系统的成层次结构" class="headerlink" title="1.1.2 计算机系统的成层次结构"></a>1.1.2 计算机系统的成层次结构</h5><p><strong>方向：M4→M3→M2→M1→M0</strong></p><p>虚拟机器M4(高级语言机器)用编译程序翻译成汇编语言程序</p><p>虚拟机器M3(汇编语言机器)用汇编程序翻译成机器语言程序</p><p>虚拟机器M2(操作系统机器)用机器语言解释操作系统</p><p>传统机器M1(机器语言机器)用微程序解释机器指令</p><p>微程序机器M0(微指令系统)有硬件直接执行微指令</p><h5 id="1-1-3计算机组成和计算机体系结构"><a href="#1-1-3计算机组成和计算机体系结构" class="headerlink" title="1.1.3计算机组成和计算机体系结构"></a>1.1.3计算机组成和计算机体系结构</h5><p><strong>计算机体系结构</strong>：是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。计算机系统的属性通常是指用机器语言编程的程序员所能看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术、I&#x2F;O机理等，大都属于抽象概念</p><p><strong>计算机组成</strong>：是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。例如，指令系统体现了机器的属性，这属于<em>计算机结构</em>的问题。但是指令的实现，即如何取出指令，分析指令，取操作数、运算、送结果等，这些属于<em>计算机组成问题</em></p><h4 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h4><h5 id="1-2-1冯·诺伊曼计算机的特点"><a href="#1-2-1冯·诺伊曼计算机的特点" class="headerlink" title="1.2.1冯·诺伊曼计算机的特点"></a>1.2.1冯·诺伊曼计算机的特点</h5><ul><li>计算机有运算器、存储器、控制器、输入设备、输出设备五大部件组成</li><li>指令和数据以同等的地位存放与存储器内，并可按地址访问</li><li>指令和数据均用二进制数表示</li><li>指令有操作码和地址码组成，操作码可以用来表示操作的性质，地址码可以用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定的条件下，可以根据运算结果或根据设定的条件改变执行的顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ul><h5 id="1-2-2计算机的硬件框图"><a href="#1-2-2计算机的硬件框图" class="headerlink" title="1.2.2计算机的硬件框图"></a>1.2.2计算机的硬件框图</h5><p>典型的冯·诺伊曼计算机解构框图</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201047407.png" class="" title="image-20230827201047407"><p>图中各部件的功能如下：</p><ul><li>运算器用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内</li><li>存储器用来存放数据指令和程序</li><li>控制器用来控制、指挥程序和数据的输入、运行及处理运算结果</li><li>输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有鼠标、键盘等</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等</li></ul><p>由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往集成在同一个芯片上，因此，通常将他们合起来称作中央处理器（Central Processing Unit,CPU）。把输入输出设备简称为I&#x2F;O设备（Input&#x2F;Output Equipment）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201352277.png" class=""><p>主存储器是存储器子系统中的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类成为辅助存储器，简称辅存，又称外存。</p><p>算数逻辑单元（Arithmetic Logic Unit,ALU）简称算逻部件，用来完成算术逻辑运算。</p><p>控制单元（Control Unit ,CU）用来解释存储器中的指令，并发出各种操作命令来执行指令。</p><p>ALU和CU是CPU的核心</p><p>I&#x2F;O设备也受CU控制，用来完成相对应的输入和输出操作</p><h5 id="1-2-3计算机的工作步骤"><a href="#1-2-3计算机的工作步骤" class="headerlink" title="1.2.3计算机的工作步骤"></a>1.2.3计算机的工作步骤</h5><p>用计算机解决问题有两大步骤。一是上机前的准备，另一个是上机运行</p><h6 id="上机前的准备"><a href="#上机前的准备" class="headerlink" title="上机前的准备"></a>上机前的准备</h6><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h6 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202137512.png" class="" title="image-20230827202137512"><h6 id="存储器的基本组成："><a href="#存储器的基本组成：" class="headerlink" title="存储器的基本组成："></a>存储器的基本组成：</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201750247.png" class=""><p>主存储器包括存储体、各种逻辑部件及控制电路，存储体由很多存储单元组成，每个存储单元又包括若干个存储元件，每个存储元件存放一个二进制代码“0”和“1”。一个存储单元可以储存一串二进制代码，称这串二进制代码为一个存储字，这串二进制代码的位数成为存储字长。</p><ol><li>存储单元:存放一串二进制代码</li><li>存储字:存储单元中二进制代码的组合</li><li>存储字长:存储单元中二进制代码的位数 每个存储单元赋予一个地址号</li></ol><p>为了实现按地址访问的形式，主存中还得必须配置两个寄存器MAR和MDR</p><ol><li>MAR:存储器地址寄存器，反映存储单元的个数</li><li>MDR:存储器数据寄存器，反映存储字节长度</li></ol><p>设RAM&#x3D;4 位  MDR&#x3D;8位则 存储单元个数位16个，存储字长为8</p><h6 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h6><p>运算器最少包括三个寄存器和一个算数逻辑单元（ALU）其中ACC是累加器，MQ为乘商寄存器，X为操作数寄存器</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202644280.png" class="" title="image-20230827202644280"><p>M表示存储器的任意地址号，[M]表示对应M地址单元中的内容；X表示X寄存器,[X]表示X寄存器的内容；ACC表示累加器，[ACC]表示累加器中的内容；MQ表示乘商寄存器，[MQ]表示乘商寄存器中的内容</p><p>加法操作过程</p><p>假设ACC已经有前一时刻的运算运算结果，并作为下述运算中的一个操作数</p><p>即将[ACC]中看作被加数，先从主存中取一个存放在M地址号单元的加数[M]，送至运算器的X寄存器中，然后将被加数[ACC]与加数[X]相加，结果(和)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202827546.png" class="" title="image-20230827202827546"><p>减法操作过程</p><p>即将[ACC]中看作被减数，先从主存中取一个存放在M地址号单元的减数[M]，送至运算器的X寄存器中，然后将[ACC]-[X]，结果(差)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202846884.png" class="" title="image-20230827202846884"><p>乘法操作过程</p><p>即将[ACC]看作被乘数，先取出存放在主存M号地址单元中的乘数[M]并送入乘商寄存器MQ,在把被乘数送入X寄存器，并将ACC清“0”,然后[X]和[MQ]相乘，结果（积）的高位保留在ACC中，地位保留MQ中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202907215.png" class="" title="image-20230827202907215"><p>除法操作过程</p><p>即将[ACC]看作被除数，先取出存放在M地址单元内的除数[M]并送至X寄存器，然后[ACC]除以[X]，结果（商）暂留与MQ,[ACC]为余数R。若需要将商保留在ACC中，只需要做一步[MQ]→ACC即可</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202931819.png" class="" title="image-20230827202931819"><p>控制器</p><p>控制器由程序计数器（Program Counter,PC）、指令寄存器（Instruction Register,IR）以及控制单元（CU）组成</p><p>PC：用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路且具有自动加1的功能，即可自动形成下一条指令的地址。</p><p>IR:用来存放当前的指令，IR的内来自主存的MDR。IR中的操作码（OP(IR)）送至CU,记作OP(IR)→CU,用来分析指令；其地址码（Ad(IR)）作为操作数的地址送至存储器的MAR,记作Ad(IR)→MAR。</p><p>CU：用来分析当前的指令所需完成的操作，并发出各种微操作命令序号，用以控制所有被控制对象</p><p>完成一条指令需要三个步骤：取指令、分析指令、执行指令</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203029187.png" class="" title="image-20230827203029187"><p>主机完成一条指令的过程</p><p>取指数为例</p><ol><li><p>PC把指令送给MAR</p></li><li><p>MAR把指令送给存储体</p></li><li><p>在控制器的控制下，把存储体指定存储单元中的那条取数指令取出，并送入MDR中</p></li><li><p>将取出的指令送入IR中</p><hr></li><li><p>把IR的操作码送入CU</p></li><li><p>CU经过译码后，在控制器的控制下，把指令中的地址部分送给存储器，以便数据从存储体中取出</p></li><li><p>MAR将地址送给存储体</p></li><li><p>在控制器的控制之下，把存储体中我们需要取的数送至MDR中</p></li><li><p>然后将MDR的数据送入ACC</p></li></ol><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203302609.png" class="" title="image-20230827203302609"><p>例子：</p><p>首先按下图的有序指令和数据，通过键盘输入到主从第0号至第12号单元中，并置PC的初始值为0（令程序的首选地址为0）。启动机器后，计算机便自动按存储器中所存放的指令顺序有序地逐条完成取指令、分析指令、和执行指令，直至最后一条指令为止。</p><p>例如</p><ul><li>PC→MAR,并命令存储器做读操作，此时0号单元中的内容”0000010000001000”,便被送入到MDR内</li><li>MDR→IR,完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000001”为取数指令</li><li>于是CU将IR中的地址码“0000001000”送至MAR(记作Ad(IR)→MAR),并命令存储器做只读操作</li><li>将地址单元的操作数X送至MDR</li><li>再由MDR中送至ACC中，完成指令的执行过程，此时完成第一条取数指令的全过程，即操作数在X送至运算器ACC中</li><li>PC完成自动加1操作，形成下一条指令的地址“1”</li><li>PC将第二条指令送入MAR中，命令主存储器做只读操作，将“0001000000001001”送入MDR中</li><li>MDR→IR，完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000100”为乘法指令</li><li>CU向存储体发出读命令，取出对应地址为“0000001001”单元的操作数a</li><li>a经MDR送至运算器MQ</li><li>CU在向运算器发送乘法操作命令，完成ax的运算，并把结果ax存放在ACC中</li><li>PC+1→PC,形成下一条指令的地址“2”号</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203825422.png" class="" title="image-20230827203825422">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
