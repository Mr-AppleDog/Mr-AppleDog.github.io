<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>物理层(二)</title>
    <link href="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章首先讨论物理层的基本概念。然后介绍有关数据通信的重要概念，以及各种传输媒体的主要特点，但传输媒体本身并不属于物理层的范围。在讨论几种常用的信道复用技术后，对数字传输系统进行简单介绍。最后再讨论几种常用的宽带接入技术。</p><span id="more"></span><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p>首先要强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。大家知道，现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么。用于物理层的协议也常称为物理层<strong>规程</strong>（procedure)。其实物理层规程就是物理层协议。只是在“协议”这个名词出现之前人们就先使用了“规程”这一名词。</p><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：</p><ul><li>机械特性</li></ul><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。平时常见的各种规格的接插件都有严格的标准化的规定。</p><ul><li>电气特性</li></ul><p>指明在接口电缆的各条线上出现的电压的范围。</p><ul><li>功能特性</li></ul><p>指明某条线上出现的某一电平的电压的意义。</p><ul><li>过程特性</li></ul><p>指明对于不同功能的各种可能事件的出现顺序。</p><p>大家知道，数据在计算机内部多采用并行传输方式。但数据在通信线路（传输媒体）上的传输方式一般都是串行传输（这是出于经济上的考虑），即逐个比特按照时间顺序传输。因此物理层还要完成传输方式的转换。具体的物理层协议种类较多。这是因为物理连接的方式很多（例如，可以是点对点的，也可以采用多点连接或广播连接)，而传输媒体的种类也非常之多（如架空明线、双绞线、对称电缆、同轴电缆、光缆，以及各种波段的无线信道等)。因此在学习物理层时，应将重占放在堂据其本概念上。</p><h3 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h3><h5 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h5><p>一个数据通信系统可划分为三大部分，即源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908132617208.png" class="" title="image-20230908132617208"><p>源系统一般包括以下两个部分：</p><ul><li>源点(source)源点设备产生要传输的数据，例如，从计算机的键盘输入汉字，计算机产生输出的数字比特流。源点又称为源站或信源。</li><li>发送器通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。现在很多计算机使用内置的调制解调器（包含调制器和解调器)，用户在计算机外面看不见调制解调器。</li></ul><p>目的系统一般也包括以下两个部分：</p><ul><li>接收器接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li>终点(destination)终点设备从接收器获取传送来的数字比特流，然后把信息输出(例如，把汉字在计算机屏幕上显示出来)。终点又称为目的站或信宿。</li></ul><p>在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统。</p><p>下面我们先介绍一些常用术语</p><p>通信的目的是传送<strong>消息</strong>(message)。话音、文字、图像、视频等都是消息。<strong>数据</strong>(data)是运送消息的实体。根据<strong>RFC4949</strong>给出的定义，数据是使用特定方式表示的信息，通常是有意义的符号序列。这种信息的表示可用计算机或其他机器（或人）处理或产生。<strong>信号</strong>(signal)则是数据的电气或电磁的表现。</p><p>根据信号中代表消息的参数的取值方式不同，信号可分为以下两大类：</p><ul><li>模拟信号，或连续信号——代表消息的参数的取值是连续的。例如在上图中，用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。</li><li>数字信号，或离散信号——代表消息的参数的取值是离散的。例如在上图中，用户家中的计算机到调制解调器之间或在电话网中继线上传送的就是数字信号。在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一种代表1状态。</li></ul><h5 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h5><p>在许多情况下，我们要使用“<strong>信道</strong>(channel)”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条<strong>通信电路</strong>往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li>单向通信</li></ul><p>又称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>线电广播或有线电广播以及电视广播就属于这种类型。</p><ul><li>双向交替通信</li></ul><p>又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式是一方发送另一方接收，过一段时间后可以再反过来。</p><ul><li>双向同时通信</li></ul><p>又称为全双工通信，即通信的双方可以同时发送和接收信息。单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道（每个方向各一条)。显然，双向同时通信的传输效率最高。</p><p>这里注意，有时人们也常用<strong>“单工</strong>”这个名词表示“<strong>双向交替通信</strong>”。如常说的“单工电台”并不是只能进行单向通信。正因为如此，ITU-T才不采用“单工”“半双工”和“全双工”这些容易弄混的术语作为正式的名词。来自信源的信号常称为<strong>基带信号</strong>（即基本频带信号）。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含较多的低频分量，甚至有直流分量，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带<strong>信号进行调制</strong>(modulation)。</p><p>调制可分为两大类。一类是仅仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为<strong>编码</strong>(coding)。另一类调制则需要使用载波(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>(即仅在一段频率范围内能够通过信道)，而使用载波的调制称为<strong>带通调制</strong>。</p><h6 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h6><ul><li><p>不归零制：正电平代表1，负电平代表0。</p></li><li><p>归零制：正脉冲代表1，负脉冲代表0。</p></li><li><p>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。但也可反过来定义。</p></li><li><p>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</p></li></ul><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908134543743.png" class="" title="image-20230908134543743"><p>从信号波形中可以看出，曼彻斯特(Manchester)编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力)，而曼彻斯特编码具有自同步能力。</p><h6 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h6><ul><li>调幅(AM)：即载波的振幅随基带数字信号而变化。例如，0或1分别对应于无载波或有载波输出。</li><li>调频(FM)：即载波的频率随基带数字信号而变化。例如，0或1分别对应于频率f1或f2。</li><li>调相(PM)：即载波的初始相位随基带数字信号而变化。例如，0或1分别对应于相位0度或180度。</li></ul><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908135030466.png" class="" title="image-20230908135030466"><p>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。例如，正交振幅调制QAM(Quadrature Amplitude Modulation)。</p><h5 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h5><p>几十年来，通信领域的学者一直在努力寻找提高数据传输速率的途径这个问题很复杂，因为任何实际的信道都不是理想的，都不可能以任意高的速率进行传送。我们知道，数字通信的优点就是：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要我们从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就可视为无影响。例如，图a表示信号通过实际的信道传输后虽然有失真，但在接收端还可识别并恢复出原来的码元。但图b就不同了，这时信号的失真已很严重，在接收端无法识别码元是1还是0。码元传输的速率越高、信号传输的距离越远、噪声干扰越大或传输媒体质量越差，在接收端的波形的失真就越严重。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908135730608.png" class="" title="image-20230908135730608"><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个。</p><ul><li>信道能够通过的频率范围</li></ul><p>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。像上图所示的发送信号是一种典型的矩形脉冲信号，它包含很丰富的高频分量。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。这样，在接收端收到的信号波形就失去了码元之间的清晰界限。这种现象叫作码间串扰。严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。早在1924年，奈奎斯特(Nyquist)就推导出了著名的<strong>奈氏准则</strong>。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。奈氏准则的推导已超出本书的范围，这可在通信原理教科书中查阅到。这里我们只需要知道奈氏准则的结论，这就是：<strong>在带宽为W(Hz)的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W(码元&#x2F;秒)。传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别)成为不可能。</strong>例如，信道的带宽为4000Hz,那么最高码元传输速率就是每秒8000个码元。</p><ul><li>信噪比</li></ul><p>噪声存在于所有的电子设备和通信信道中。由于噪声是随机产生的，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误(1误判为0或0误判为1)。但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。因此，信噪比就很重要。所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为<strong>S&#x2F;N</strong>。但通常大家都是使用分贝(dB)作为度量单位。即：<br>$$<br>信噪比(dB)&#x3D;10 log_{10}(S&#x2F;N)(dB)<br>$$<br>在1948年，信息论的创始人<strong>香农(<strong>Shannon)推导出了著名的香农公式。香农公式指出：</strong>信道的极限信息传输速率C</strong>是<br>$$<br>C&#x3D;Wlog_2(1+S&#x2F;N)(bit&#x2F;s)<br>$$<br>式中，W为信道的带宽（以Hz为单位），S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。香农公式的推导可在通信原理教科书中找到。这里只给出其结果。</p><p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。香农公式指出了信息传输速率的上限。香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。不过，香农没有告诉我们具体的实现方法。这要由研究通信的专家去寻找。<br>从以上所讲的不难看出，对于频带宽度已确定的信道，如果信噪比也不能再提高了，并且码元传输速率也达到了上限值，那么还有什么办法提高信息的传输速率呢？这就是用编码的方法让<strong>每一个码元携带更多比特的信息量</strong>。</p><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><p><strong>传输媒体</strong>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即<strong>导引型传输媒体</strong>和非导引型传输媒体（这里的“导引型”的英文就是guided,.也可译为“导向传输媒体”)。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播：而非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。</p><h5 id="引导下传输媒体"><a href="#引导下传输媒体" class="headerlink" title="引导下传输媒体"></a>引导下传输媒体</h5><ul><li>双绞线</li></ul><p>双绞线也称为双扭线，是最古老但又是最常用的传输媒体。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合(ws)起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。使用双绞线最多的地方就是到处都有的电话系统。几乎所有的电话都用双绞线连接到电话交换机。这段从用户电话机到交换机的双绞线称为<strong>用户线</strong>或用<strong>户环路</strong>(subscriberloop)。通常将一定数量的这种双绞线捆成电缆，在其外面包上护套。现在的以太网（主流的计算机局域网)基本上也是使用各种类型的双绞线电缆进行连接的。</p><p><strong>无屏蔽双绞线UTP</strong>(Unshielded Twisted Pair)的价格较便宜。当数据的传送速率增高时，可以采用屏蔽双绞线(Shielded Twisted Pair,简称为STP)。</p><ul><li>同轴电缆</li></ul><p>同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及绝缘保护套层所组成。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p><ul><li>光纤</li></ul><p>从20世纪70年代到现在，通信和计算机都发展得非常快。据统计，计算机的运行速度大约每10年提高10倍。在通信领域里，信息的传输速率则提高得更快，从20世纪70年代的56kbit&#x2F;s(使用铜线)提高到现在的数百Gbit&#x2F;s(使用光纤)，并且这个速率还在继续提高。因此，光纤通信成为现代通信技术中的一个十分重要的领域。</p><p>光纤通信就是利用光导纤维（以下简称为光纤）传递光脉冲来进行通信的。有光脉冲相当于1，而没有光脉冲相当于0。由于可见光的频率非常高，约为108MHz的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤的优点，而且还具有其他的一些特点：</p><ul><li>具有通信容量非常大</li><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在现有电缆管道已拥塞不堪的情况下特别有利。</li></ul><h5 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>无线传输可使用的频段很广。从前面给出的图以看出，人们现在已经利用了好几个波段进行通信。紫外线和更高的波段目前还不能用于通信。图2-5的最下面一行还给出了ITU对波段取的正式名称。例如，LF波段的波长是从1km-10km(对应于30kHz-300kHz)。LF,MF和HF的中文名字分别是低频、中频(300kHz-3MHz)和高频(3MHz-30MHz)。更高的频段中的V,U,S和E分别对应于Very,Ultra,Super和Extremely,.相应的频段的中文名字分别是甚高频(30MHz-300MHz)、特高频(300MHz-3GHz)、超高频(3GHz-30GHz)和极高频(30GHz-300GHz),最高的一个频段中的T是Tremendously,目前尚无标准译名。在低频LF的下面其实还有几个更低的频段，如甚低频VLF、特低频ULF、超低频SLF和极低频ELF等，因不用于一般的通信，故未画在图中。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908142801389.png" class="" title="image-20230908142801389"><p>无线电微波通信在当前的数据通信中占有特殊重要的地位。微波的频率范围为300MHz-300GHz(波长1m-1mm),但主要使用2GHz~40GHz的频举范围。微波在空间主要是直线传播，由于地球表面是个曲面，因此其传播距离受到限制，一般只有50k左右。但若采用100m高的天线塔，则传播距离可增大到100km。微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。</p><p>短波通信（即高频通信）主要靠电离层的反射。但电离层的不稳定所产生的衰落现象，以及电离层反射所产生的多径效应，使得短波信道的通信质量较差。当利用无线信道传送数字信号时，必须使误码率（即比特错误率）不大于可容许的范围。下图中的曲线是根据通信理论计算出的，我们这里只需知道有关的三个基本概念。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908151235595.png" class="" title="image-20230908151235595"><ul><li>对于给定的调制方式和数据率，信噪比越大，误码率就越低。这个结论的得出是符合直觉的。当我们在嘈杂的餐厅用餐时，同桌的人可能听不清你说的话。提高嗓门会使说话的效果好些，但太大声说话也会影响周围顾客正常用餐。手机的情况也相似。若提高手机的发射功率，固然可以提高信噪比，但这必将缩短电池的使用时间。若增大电池的体积和重量，又会使手机携带不方便。过大的发射功率，还会干扰临近手机的正常通信，或影响人体健康。可见，如何提高信噪比需要综合考虑。</li><li>对于同样的信噪比，具有更高数据率的调制技术的误码率也更高。例如，当信噪比为10dB时，若采用1Mbit&#x2F;s数据率的二进制相移键控BPSK调制技术，则误码率小于107。但若采用4Mbit&#x2F;s数据率的正交振幅调制16QAM,则误码率为10，己经无法使用了。又如，当信噪比为20dB时，若采用4Mbit&#x2F;s数据率的正交振幅调制16QAM,则误码率小于107。但若采用1Mbit&#x2F;s数据率的二进制相移键控BPSK,则误码率变得非常小，从图中的曲线已无法查到其数值。</li><li>如果移动用户在进行通信时还在不断改变自己的地理位置，就会引起无线信道特性的改变，因而信噪比和误码率都会发生变化。因此，用户的移动设备的物理层应当有一定的自适应能力，可以根据所处的环境特性选择最合适的调制和编码技术，以便在保证容许的误码率的条件下，获得尽可能高的数据传输速率。为实现远距离通信必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站把前一站送来的信号经过放大后再发送到下一站，这种通信方式称为“微波接力”。大多数长途电话业务使用4GHz~6GHz的频率范围。</li></ul><p>常用的卫星通信方法是在地球站之间利用位于约3万6千公里高空的人造同步地球卫星作为中继器的一种微波接力通信。对地静止通信卫星就是在太空的无人值守的微波通信的中继站。可见卫星通信的主要优缺点大体上应当和地面微波通信差不多。卫星通信的最大特点是通信距离远，且通信费用与通信距离无关。同步地球卫星发射出的电磁波能辐射到地球上的通信覆盖区的跨度达1万8千多公里，面积约占全球的三分之一。只要在地球赤道上空的同步轨道上，等距离地放置3颗相隔120度的卫星，就能基本上实现全球的通信。</p><p>卫星通信的另一特点就是具有<strong>较大的传播时延</strong>。由于各地球站的天线仰角并不相同，因此不管两个地球站之间的地面距离是多少（相隔一条街或相隔上万公里），从一个地球站经卫星到另一地球站的传播时延均在250~300ms之间。一般可取为270ms。这和其他的通信有较大差别（请注意：这和两个地球站之间的距离没有什么关系）。对比之下，地面微波接力通信链路的传播时延一般取为3.3us&#x2F;km。请注意，“卫星信道的传播时延较大”并不等于“用卫星信道传送数据的时延较大”。这是因为传送数据的总时延除了传播时延，还有发送时延、处理时延和排队时延等部分。传播时延在总时延中所占的比例有多大，取决于具体情况。但利用卫星信道进行交互式的网上游戏显然是不合适的。在十分偏远的地方，或在离大陆很远的海洋中，要进行通信就几乎完全要依赖于卫星通信。卫星通信还非常适合于广播通信，因为它的覆盖面很广。但从安全方面考虑，卫星通信系统的保密性则相对较差。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概述(一)</title>
    <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>这是对作为一个互联网（网中网）的 Internet 进行概述，讨论 Internet 的组成部分。这个目标的部分内容为介绍协议分层和 TCP&#x2F;IP 协议簇</p><span id="more"></span><h3 id="计算机网络在信息时代中的作用"><a href="#计算机网络在信息时代中的作用" class="headerlink" title="计算机网络在信息时代中的作用"></a>计算机网络在信息时代中的作用</h3><p>Internet的中文译名并不统一。现有的Internet译名有两种：<br>        因特网，这个译名是全国科学技术名词审定委员会推荐的。虽然因特网这个译名较为准确，但却长期未得到推广。本书的前几版都采用因特网这个译名。<br>        互联网，这是目前流行最广的、事实上的标准译名。现在我国的各种报刊杂志、政府文件以及电视节目中都毫无例外地使用这个译名。Internet是由数量极大的各种计算机网络互连起来的，采用互联网这个译名能够体现出Internet最主要的特征。本书从第7版开始，改用“互联网”作为Internet的译名。</p><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>计算机网络（简称为<strong>网络</strong>）由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成。网络中的节点可以是计算机、集线器、交换机或路由器等（在后续的两章我们将会介绍集线器、交换机和路由器等设备的作用)。下图给出了一个具有四个节点和三条链路的网络。我们看到，有三台计算机通过三条链路连接到一个集线器上。这是一个非常简单的计算机网终（可简称为网终)又加在下图中，有多个网悠通过二些路由器相互连接起来，构成了一个覆盖范围更大的计算机网络。这样的网铭称为互连网internetwork或internet)。因此互连网是“网络的网络”(network of networks)甲一朵云表示一个网络的好处，就是可以先不考虑每一个网络中的细节，而是集中精力讨论与这个互连网有关的一些问题。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171508256.png" class="" title="image-20230829171508256"><p>请读者注意，当我们使用一朵云来表示网络时，可能会有两种不同的情况。一种情况如图(a)所示，用云表示的网络已经包含了网络中的计算机。但有时为了讨论问题的方便例如，要讨论几个计算机之间如何进行通信)，也可以把有关的计算机画在云的外面，如下图所示。习惯上，与网络相连的计算机常称为主机（host)。在互连网中不可缺少的路由器，是一种特殊的计筒机（有中央处理器、存储器、操作系统等），但不能称为主机。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171654918.png" class="" title="image-20230829171654918"><p>这样，我们初步建立了下面的基本概念：<br>网络把许多计算机连接在一起，而互连网则把许多网络通过一些路由器连接在一起。与网络相连的计算机常称为主机。</p><h4 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h4><ol><li>第一阶段是从单个网络ARPANET向互连网发展的过程</li><li>第二阶段的特点是建成了三级结构的互联网</li><li>第三阶段的特点是逐渐形成了全球范围的多层次ISP结沟的旦肤网。</li></ol><h4 id="互联网的标准化工作"><a href="#互联网的标准化工作" class="headerlink" title="互联网的标准化工作"></a>互联网的标准化工作</h4><p>制定互联网的正式标准要经过以下三个阶段：</p><ul><li>互联网草案(nternet Draft)一互联网草案的有效期只有六个月。在这个阶段还不能算是RFC文档。</li><li>建议标准(Proposed Standard)一从这个阶段开始就成为RFC文档。</li><li>互联网标准(nternet Standard)一如果经过长期的检验，证明了某个建议标准可以成为互联网标准时，就给它分配一个标准编号，记为STDxx,这里STD是“Standard”的英文缩写，而“xx”是标准的编号（有时也写成4位数编号，如STD0005)。一个互联网标准可以和多个RFC文档关联。</li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul><li>边缘部分:由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829172920816.png" class="" title="image-20230829172920816"><ul><li>核心部分:由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换)</li></ul><h4 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h4><p>我们先要明确下面的概念。我们说：“主机A和主机B进行通信”，实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式(C&#x2F;S方式)和对等方式(P2P方式)下面分别对这两种方式进行介绍。</p><p>1.客户-服务器方式</p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服多和被服务的关系。在下图中，主机A运行客户程序而主机B运行服务器程序。在这种情况下，A是客户而B是服务器。客户A向服务器B发出请求服务，而服务器B向客户A提供服务。这里最主要的特征就是：客户是服务请求方，服务器是服务提供方。<br>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829173123722.png" class="" title="image-20230829173123722">在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点。<p>客户程序：</p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p>服务器程序：</p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般需要有强大的硬件和高级的操作系统支持。客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</li></ul><p>2.对等连接方式</p><p>是指两台主机在通信时，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件(P2P软件)，它们就可以进行平等的对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为P2P方式。</p><p>在下图中，主机C,D,E和F都运行了P2P程序，因此这几台主机都可进行对等通信（如C和D,E和F,以及C和F)。实际上，对等连接方式从本质上看仍然使用客户服务器方式，只是对等连接中的每一台主机既是客户同时又是服务器。例如主机C,当C请求D的服务时，C是客户，D是服务器。但如果C又同时向F提供服务，那么C又同时起着服务器的作用。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174035901.png" class="" title="image-20230829174035901"><h4 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h4><p>网络核心部分是互联网中最复杂的部分，因为网络中的核心部分要向网络边缘部分中的大量主机提供连通性，使边缘部分中的任何一台主机都能够与其他主机通信。在网络核心部分起特殊作用的是<strong>路由器</strong>(router),它是一种专用计算机（但不叫作主机)。路由器是实现<strong>分组交换</strong>(packet switching)的关键构件，其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能。</p><p>1、电路交换的特点</p><p>从通信资源的分配角度来看，<strong>交换</strong>(switching)就是按照某种方式动态地分配传输线路的资源。在使用电路交换打电话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条<strong>专用的物理通路</strong>。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的<br>物理通路（即把刚才占用的所有通信资源归还给电信网）。这种必须经过“<strong>建立连接（占用通信资源)→通适（一直占用通信贪源→释放连接（归还通信资源）</strong>”三个步骤的交换方式称为电路交换。如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后再重新拨号。</p><p>2、分组交换的特点</p><p>分组交换则采用存储转发技术。下图表示把一个报文划分为几个分组后再进行传送。通常我们把要发送的整块数据称为一个<strong>报文</strong>(message)。在发送报文之前，先把较长的报文划分为一个个更小的等长数据段，例如，视频讲解每个数据段为1024bit。在每一个数据段前面，加上一些必要的控制信息组成的首部(header)后，就构成了一个<strong>分组</strong>(packet)。分组又称为“包”，而分组的首部也可称为“包头”。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174914172.png" class="" title="image-20230829174914172"><p>位于<strong>网络边缘部分的主机</strong>和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器则用来转发分组，即进行分组交换。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地（有时会经过几十个不同的路由器）以存储转发的方式，把分组交付最终的<br>目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175504654.png" class="" title="image-20230829175504654"><p>图的最下方归纳了三种交换方式在数据传送阶段的主要特点：</p><ul><li>电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换—整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。</li><li>分组交换—单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175607493.png" class="" title="image-20230829175607493"><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><h4 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h4><p>关于计算机网络的较好的定义是这样的[PETE12]1:计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h4 id="几种不同类别的计算机网络"><a href="#几种不同类别的计算机网络" class="headerlink" title="几种不同类别的计算机网络"></a>几种不同类别的计算机网络</h4><ul><li>按照网络的作用范围进行分类</li></ul><p>广域网WAN(Wide Area Network)广域网的作用范围通常为几十到几千公里，因而有时也称为远程网(long haul network)</p><p>城域网MAN(Metropolitan Area Network)城域网的作用范围一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5~50km。</p><p>局域网LAN(Local Area Network)局域网一般用微型计算机或工作站通过高速通信线路相连（速率通常在10Mbit&#x2F;s以上），但地理上则局限在较小的范围（如1km左右）。</p><p>个人区域网PAN(Personal Area Network)个人区域网就是在个人工作的地方把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络，因此也常称为无线个人区域网WPAN(Wireless PAN),其范围很小，大约在I0m左右。</p><ul><li>按照网络的使用者进行分类</li></ul><p>公用网(public network)这是指电信公司（国有或私有）出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为公众网。</p><p>专用网(private network)这是某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</p><ul><li>用来把用户接入到互联网的网络</li></ul><p>这种网络就是接入网AN(Access Network),它又称为本地接入网或居民接入网</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><ul><li>速率</li></ul><p>计算机发送的信号都是数字形式的。比特(bit)来源于binary digit,意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率,它也称为数据率(data rate)或比特率(bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit&#x2F;s(比特每秒)</p><ul><li>带宽</li></ul><p>“带宽”(bandwidth)有以下两种不同的意义：</p><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。例如，在传统的通信线路上传送的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,即话音的主要成分的频率范围)。这种意义的带宽的单位是赫(或千赫、兆赫、吉赫等)。在过去很长的一段时间，通信的主干线路传送的是模拟信号(即连续变化的信号)。因此，表示某信道允许通过的信号频带范围就称为该信道的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”。在本书中提到“带宽”时，主要是指这个意思。这种意义的带宽的单位就是数据率的单位bit&#x2F;s,是“比特每秒”。</li></ol><ul><li>吞吐量</li><li>时延</li></ul><p>时延(delay或latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或迟延。</p><p>发送时延：发送时延(transmission delay)是主机或路由器发送数据帧所需要的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182020809.png" class="" title="image-20230829182020809"><p>传播时延：是电磁波在信道中传播一定的距离需要花费的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182128702.png" class="" title="image-20230829182128702"><p>处理时延：处理时延主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找转发表等，这就产生了处理时延</p><p>排队时延：排队时延分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><ul><li>时延带宽积</li></ul><p>时延带宽积&#x3D;传播时延×带宽</p><ul><li>往返时间PTT</li></ul><p>在计算机网络中，往返时间RTT(Round-Trip Time)也是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。例如，A向B发送数据。如果数据长度是100MB,发送速率是1O0Mhit&#x2F;s.那么</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194040018.png" class=""><p>假定B正确收完100MB的数据后，就立即向A发送确认。再假定A只有在收到B的确认信息后，才能继续向B发送数据。显然，这就要等待一个往返时间RTT(这里假定确认信息很短，可忽略B发送确认的发送时延)。如果RTT&#x3D;2s,那么可以算出A向B发送数据的有效数据率。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194236316.png" class="" title="image-20230829194236316"><ul><li>利用率</li></ul><h4 id="计算机网络的非性能特征"><a href="#计算机网络的非性能特征" class="headerlink" title="计算机网络的非性能特征"></a>计算机网络的非性能特征</h4><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于维护和管理</li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h4><h6 id="网络协议三个要素组成："><a href="#网络协议三个要素组成：" class="headerlink" title="网络协议三个要素组成："></a>网络协议三个要素组成：</h6><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：即事件实现顺序的详细说明</li></ul><h6 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h6><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194710875.png" class="" title="image-20230829194710875"><ul><li>应用层(application layer)</li></ul><p>应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程就是指主机中正在运行的程序。对于不同的网络应用需要有不同的应用层协议。互联网中的应用层协议很多，如域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议，等等。我们把应用层交互的数据单元称为报文(message)。</p><ul><li>运输层(transport layer)</li></ul><p>运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。所谓“通用的”，是指并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议：</p><ol><li>传输控制协议TCP(Transmission Control Protocol)提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。</li><li>用户数据报协议UDP(User Datagram Protocol)—提供无连接的尽最大努力(besteffort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。</li></ol><ul><li>网络层(network layer)</li></ul><p>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用P协议，因此分组也叫作P数据报，或简称为数据报。本书把“分组”和“数据报”作为同义词使用。请注意：不要将运输层的“用户数据报协议UDP”和网络层的“IP数据报”弄混。此外，无论在哪一层传送的数据单元，都可笼统地用“分组”来表示。</p><ul><li>数据链路层(data link layer)</li></ul><p>数据链路层常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing),在两个相邻节点间的链路上传送帧(frame)。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p><ul><li>物理层(physical layer)</li></ul><p>在物理层上所传数据的单位是比特。发送方发送1（或0）时，接收方应当收到1（或0)而不是0（或1）。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。当然，解释比特代表的意思，不是物理层的任务。请注意，传递信息所利用的一些物理传输媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而是在物理层协议的下面。因此也有人把物理层下面的物理传输媒体当作第0层。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829195444407.png" class="" title="image-20230829195444407"> <h4 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h4><ul><li>实体：实体(entity)这一较为抽象的名词表示任何可发送或接收信息的硬件或软件进程。在许多情况下，实体就是一个特定的软件模块。</li><li>协议：协议是控制两个对等实体（或多个实体)进行通信的规则的集合。</li></ul><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</p><p>首先，协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。也就是说，下面的协议对上面的实体是透明的。其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体“看得见”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>在同一系统中相邻两层的实体进行交互（即交换信息）的地方，通常称为服务访问点SAP(Service Access Point)。服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口，有点像邮政信箱（可以把邮件放入信箱和从信箱中取走邮件），但这种层间接口和两个设备之间的硬件接口（并行的或串行的）并不一样。OSI把层与层之间交换的数据的单位称为服务数据单元SDU(Service Data Unit),它可以与PDU不一样。例如，可以是多个SDU合成为一个PDU,也可以是一个SDU划分为几个PDU。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200113587.png" class="" title="image-20230829200113587"><h4 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP&#x2F;IP的体系结构"></a>TCP&#x2F;IP的体系结构</h4><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200230496.png" class="" title="image-20230829200230496">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理(六)</title>
    <link href="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍参与运算的各类数据（包括无符号数和有符号数、定点数和浮点数等)，以及它们在计算机中的算术运算方法。</p><span id="more"></span><h3 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h3><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>计算机中的数均放在寄存器中，通常称寄存器的位数为机器字长。所谓无符号数，即没有符号的数，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。以机器字长为16位为例，无符号数的表示范围为0-65535，而有符号数的表示范围为-32768~+32767</p><h4 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h4><h6 id="1-机器数与真值"><a href="#1-机器数与真值" class="headerlink" title="1.机器数与真值"></a>1.机器数与真值</h6><p>对有符号数而言，符号的“正”、“负”机器是无法识别的，但由于“正”、“负”恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。</p><h6 id="2-原码表示法"><a href="#2-原码表示法" class="headerlink" title="2.原码表示法"></a>2.原码表示法</h6><p>原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为带符号的绝对值表示。</p><p>原码表示简单明了，并易于和真值转换。但用原码进行加减运算时，却带来了许多麻烦。例如，当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。运算步骤既复杂又费时，而且本来是加法运算却要用减法器实现。那么能否在计算机中只设加法器，只作加法操作呢？如果能找到一个与负数等价的正数来代替该负数，就可把减法操作用加法代替。而机器数采用补码时，就能满足此要求。</p><h6 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="3.反码表示法"></a>3.反码表示法</h6><p>正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变</p><p>4.补码表示</p><p>补码：正数的补码与原码一致，负数的补码是该数的反码加1</p><table><thead><tr><th>真值</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>+0.1011（小数）</td><td>0.1011</td><td>0.1011</td><td>0.1011</td></tr><tr><td>-0.1011（小数）</td><td>1.1011</td><td>1.0100</td><td>1.0101</td></tr><tr><td>+1100（整数）</td><td>0，1100</td><td>0，1100</td><td>0，1100</td></tr><tr><td>-1100（整数）</td><td>1，1100</td><td>1，0011</td><td>1，0100</td></tr></tbody></table><p>综上所述，三种机器数的特点可归纳如下：</p><ul><li>三种机器数的最高位均为符号位。符号位和数值部分之间可用“.”（对于小数）或“，”(对于整数)隔开。</li><li>当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同。</li><li>当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”。</li></ul><p>列出了8位寄存器中所有二进制代码组合与无符号数、原码、补码和反码所代表的真值的对应关系</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906130657434.png" class="" title="image-20230906130657434"><p>由此可得出一个结论：由于“苓”在补码中只有一种表示形式，故补码比原码和反码可以多表示一个负数。</p><h6 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906131249269.png" class="" title="image-20230906131249269"><p>进一步观察发现，同一个真值的移码和补码仅差一个符号位，若将补码的符号位由“0”改为“1”,或从“1”改为“0”，即可得该真值的移码。表列出了真值、补码和移码的对应关系。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906131448857.png" class="" title="image-20230906131448857"><h3 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h3><h4 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h4><p>小数点固定在某一位置的数为定点数，有以下两种格式。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906131903561.png" class="" title="image-20230906131903561"><p>当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数决定了定点机中数的表示范围。</p><p>在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。</p><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><p>浮点数的表示<br>$$<br>N&#x3D;S×r^j<br>$$<br>式中，S为尾数（可正可负），j为阶码（可正可负），r是基数（或基值）。在计算机中，基数可取2，<br>4、8或16等。</p><p>浮点数在机器中的形式如下所示。采用这种数据格式的机器称为浮点机。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906133321911.png" class="" title="image-20230906133321911"><p>浮点数由阶码j和尾数S两部分组成。阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围及小数点的实际位置；尾数是小数，其位数反映了浮点数的精度；尾数的符号Sf代表浮点数的正负</p><h6 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h6><p>以通式N&#x3D;S×r^j为例，设浮点数阶码的数值位取m位，尾数的数值位取n位，当浮点数为非规格化时</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906133656953.png" class="" title="image-20230906133656953"><p>一且浮点数的位数确定后，合理分配阶码和尾数的位数，直接影响浮点数的表示范围和精度。通常对于短实数（总位数为32位），阶码取8位（含阶符1位），尾数取24位（含数符1位）；对于长实数（总位数为64位），阶码取11位（含阶符1位），尾数取53位（含数符1位）；对于临时实数（总位数为80位），阶码取15位（含阶符1位），尾数取65位（含数符1位）。</p><h6 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h6><p>为了提高浮点数的精度，其尾数必须为规格化数。如果不是规格化数，就要通过修改阶码并同时左右移尾数的办法，使其变成规格化数。将非规格化数转换成规格化数的过程称为规格化。对于基数不同的浮点数，因其规格化数的形式不同，规格化过程也不同。</p><p>r &#x3D; 2 尾数最高位为 1 </p><p>r &#x3D; 4 尾数最高2位不全为 0 </p><p>r &#x3D; 8 尾数最高3位不全为 0</p><ul><li>当基数为2时，尾数最高位为1的数为规格化数。规格化时，尾数左移一位，阶码减1（这种规格化称为向左规格化，简称左规)；尾数右移一位，阶码加1（这种规格化称为向右规格化，简称右规)</li><li>当基数为4时，尾数的最高两位不全为零的数为规格化数。规格化时，尾数左移两位，阶码减1：尾数右移两位，阶码加1。</li><li>当基数为8时，尾数的最高三位不全为零的数为规格化数。规格化时，尾数左移三位，阶码减1；尾数右移三位，阶码加1。</li></ul><p>基数 r 越大，可表示的浮点数的范围越大 基数不同，浮点数的规格化形式不同 基数 r 越大，浮点数的精度降低</p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p>定点运算包括移位、加、减、乘、除几种。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><h6 id="移位的意义"><a href="#移位的意义" class="headerlink" title="移位的意义"></a>移位的意义</h6><p>移位运算在日常生活中常见。例如，15m可写成1500cm,单就数字而言，1500相当于数15相对于小数点左移了两位，并在小数点前面添了两个0；同样15也相当于1500相对于小数点右移了两位，并删去了小数点后面的两个0。可见，当某个十进制数相对于小数点左移位时，相当于该数乘以10；右移n位时，相当于该数除以10”。</p><p>移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。</p><h6 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h6><p>对于正数，由于[x]原&#x3D;[x]补&#x3D;[x]反&#x3D;真值，故移位后出现的空位均以0添之。对于负数，由于原码、补码和反码的表示形式不同，故当机器数移位时，对其空位的添补规则也不同。表列出了三种不同码制的机器数（整数或小数均可），分别对应正数或负数移位后的添补规则。必须注意的是：不论是正数还是负数，移位后其符号位均不变，这是算术移位的重要特点。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906141531767.png" class="" title="image-20230906141531767"><ul><li>机器数为正时，不论是左移还是右移，添补代码均为0。</li><li>由于负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添0即可。</li><li>由于负数的反码各位除符号位外与负数的原码正好相反，故移位后所添的代码应与原码相反，即全部添1。</li><li>分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。</li></ul><h6 id="算数移位的硬件实现"><a href="#算数移位的硬件实现" class="headerlink" title="算数移位的硬件实现"></a>算数移位的硬件实现</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906142456879.png" class="" title="image-20230906142456879"><p>算数移位和逻辑移位的区别</p><p>有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。逻辑移位的规则是：逻辑左移时，高位移丢，低位添0：逻辑右移时，低位移丢，高位添0。</p><h4 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h4><p>加减法运算是计算机中最基本的运算，因减法运算可看做被减数加上一个减数的负值，即A一B&#x3D;A+（一B),故在此将机器中的减法运算和加法运算合在.一起讨论。现代计算机中都采用补码作加减法运算。</p><h6 id="补码加减法的公式"><a href="#补码加减法的公式" class="headerlink" title="补码加减法的公式"></a>补码加减法的公式</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906142949477.png" class="" title="image-20230906142949477"><p>即补码表示的两个数在进行加法运算时，可以把符号位与数值位同等处理，只要结果不超出机器能表示的数值范围，运算后的结果按2^n+1取模（对于整数）或按2取模（对于小数），就能得到本次加法的运算结果。</p><p>若机器数采用补码，当求A-B时，只需先求[-B]补（称[-B]补为“求补”后的减数)，就可按补码加法规则进行运算。而[-B]补由[B]补连同符号位在内，每位取反，末位加1而得。</p><h6 id="溢出判定"><a href="#溢出判定" class="headerlink" title="溢出判定"></a>溢出判定</h6><ul><li>一位符号位判溢出</li></ul><p>参加操作的 两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作 数的符号不同，即为溢出</p><ul><li>两位符号位判溢出</li></ul><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906144809676.png" class="" title="image-20230906144809676"><h6 id="补码加减法的硬件配置"><a href="#补码加减法的硬件配置" class="headerlink" title="补码加减法的硬件配置"></a>补码加减法的硬件配置</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906144900824.png" class="" title="image-20230906144900824"><p>图中寄存器A、X、加法器的位数相等，其中A存效被加数（或被减数）的补码，X存放加数(或减数)的补码。当作减法时，由“求补控制逻辑”将X送至加法器，并使加法器的最末位外来进位为1，以达到对减数求补的目的。运算结果溢出时，通过溢出判断电路置“1”溢出标记V。G为加法标记，Gs为减法标记。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906145455941.png" class="" title="image-20230906145455941"><h4 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h4><p>在计算机中，乘法运算是一种很重要的运算，有的机器由硬件乘法器直接完成乘法运算，有的机器内没有乘法器，但可以按机器作乘法运算的方法，用软件编程实现。因此，学习乘法运算方法不仅有助于乘法器的设计，也有助于乘法编程。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907132124668.png" class="" title="image-20230907132124668"><p>可见，这里包含着被乘数A的多次左移，以及4个位积的相加运算。<br>若计算机完全模仿笔算乘法步骤，将会有两大困难：其一，将4个位积一次相加，机器难以实现；其二，乘积位数增长了一倍，这将造成器材的浪费和运算时间的增加。为此，对笔算乘法进行改进。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907132311831.png" class="" title="image-20230907132311831"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907133118854.png" class="" title="image-20230907133118854"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907133319912.png" class="" title="image-20230907133319912"><p>上述运算过程可归纳如下：</p><ul><li>乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。</li><li>由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，由次低位作新的末位，空出最高位放部分积的最低位。</li><li>每次做加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置。计算机很容易实现这种运算规则。用一个寄存器存放被乘数，一个寄存器存放乘积的高位，另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。</li></ul><h6 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h6><p>由于原码表示与真值极为相似，只差一个符号，而乘积的符号又可通过两数符号的逻辑异或求得，因此，上述讨论的结果可以直接用于原码一位乘，只需加上符号位处理即可。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134154514.png" class="" title="image-20230907134154514"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134437551.png" class="" title="image-20230907134437551"><h6 id="原码一位乘所需的硬件配置"><a href="#原码一位乘所需的硬件配置" class="headerlink" title="原码一位乘所需的硬件配置"></a>原码一位乘所需的硬件配置</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134722507.png" class="" title="image-20230907134722507"><p>图中A、X、Q均为+1位的寄存器，其中X存放被乘数的原码，Q存放乘数的原码。移位和加控制电路受末位乘数Q。的控制（当Q.&#x3D;1时，A和X内容相加后，A、Q右移一位；当Q&#x3D;0时，只作A、Q右移一位的操作)。计数器C用于控制逐位相乘的次数。S存放乘积的符号。G为乘法标记。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134924199.png" class="" title="image-20230907134924199"><h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907175018650.png" class="" title="image-20230907175018650"> 其特点可归纳如下：<ul><li>每次上商都是由心算来比较余数（被除数)和除数的大小，确定商为“1”还是“0”。</li><li>每做一次减法，总是保持余数不动，低位补0，再减去右移后的除数。</li><li>上商的位置不固定。</li><li>商符单独处理。</li></ul><p>如果将上述规则完全照搬到计算机内，实现起来有一定困难，主要问题如下：</p><ul><li>机器不能“心算”上商，必须通过比较被除数（或余数）和除数绝对值的大小来确定商值，即|x|-|y|,若差为正（够减）上商1，差为负（不够减）上商0。</li><li>按照每次减法总是保持余数不动低位补0，再减去右移后的除数这一规则，则要求加法器的位数必须为除数的两倍。仔细分析发现，右移除数可以用左移余数的方法代替，其运算结果是一样的，但对线路结构更有利。不过此刻所得到的余数不是真正的余数，只有将它乘上2“才是真正的余数。</li><li>笔算求商时是从高位向低位逐位求的，而要求机器把每位商直接写到寄存器的不同位置也是不可取的。计算机可将每一位商直接写到寄存器的最低位，并把原来的部分商左移一位，这样更有利于硬件实现。综上所述便可得原码除法运算规则。</li></ul><h5 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h5><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907180627287.png" class="" title="image-20230907180627287"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907180807171.png" class="" title="image-20230907180807171"><h6 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h6><p>恢复余数法的特点是：当余数为负时，需加上除数，将其恢复成原来的余数。</p><p>由上所述，商值的确定是通过比较被除数和除数的绝对值大小，即**[x*]补—[y*]<strong>补实现的，而计算机内只设加法器，故需将</strong>[x*]补—[y*]补** 操作变为**[x*]补+[一y*]**补的操作。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907181417188.png" class="" title="image-20230907181417188"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907181435758.png" class="" title="image-20230907181435758"><h6 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190034295.png" class="" title="image-20230907190034295"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190114504.png" class="" title="image-20230907190114504"><ul><li>上商n+1次</li><li>第一次上商判溢出</li><li>移n次，加n+1次</li><li>用移位的次数判断除法是否结束</li></ul><h6 id="原码加减交替法所需的硬件配置"><a href="#原码加减交替法所需的硬件配置" class="headerlink" title="原码加减交替法所需的硬件配置"></a>原码加减交替法所需的硬件配置</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190801544.png" class="" title="image-20230907190801544"><p>除法开始前，Q寄存器被清零，准备接收商，被除数的原码放在A中，除数的原码放在X中，计数器C中存放除数的位数。除法开始后，首先通过异或运算求出商符，并存于S。接着将被除数和除数变为绝对值，然后开始用第一次上商判断是否溢出。若溢出，则置溢出标记V为1，停止运算，进行中断处理，重新选择比例因子；若无溢出，则先上商，接着A、Q同时左移一位，然后再根据上一次商值的状态，决定是如还是减除数，这样重复次后，再上最后一次商（共上商n+1次)，即得运算结果。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190927432.png" class="" title="image-20230907190927432"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907191002919.png" class="" title="image-20230907191002919"><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>机器中任何一个浮点数都可写成</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230908160307301.png" class="" title="image-20230908160307301"><p>的形式。其中，S,为浮点数的尾数，一般为绝对值小于1的规格化数（补码表示时允许为-1），机器中可用原码或补码表示：，为浮点数的阶码，一般为整数，机器中大多用补码或移码表示；”为浮点数的基数，常用2、4、8或16表示。以下以基数为2进行讨论。</p><h5 id="浮点加减法运算"><a href="#浮点加减法运算" class="headerlink" title="浮点加减法运算"></a>浮点加减法运算</h5><p>设两个浮点数</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230908160404208.png" class="" title="image-20230908160404208"><p>由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。</p><ul><li>对阶，使两数的小数点位置对齐。</li><li>尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。</li><li>规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。</li><li>舍入，为提高精度，要考虑尾数右移时丢失的数值位。</li><li>溢出判断，即判断结果是否溢出。</li></ul><h6 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h6><p>对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此；首先要求出阶差，再按小阶向大阶看齐的原则，使阶小的尾数向右移位，每右移一位，阶码加1，直到两数的阶码相等为止。右移的次数正好等于阶差。尾数右移时可能会发生数码丢失，影响精度。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907192128330.png" class="" title="image-20230907192128330"><h6 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h6><p>将对阶后的两个尾数按定点加（减）运算规则进行运算。</p><h6 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907192712579.png" class="" title="image-20230907192712579"><h6 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h6><p>在对阶和右规过程中，可能出现尾数末位丢失引起误差，需考虑舍入</p><ul><li>0舍1入法</li><li>横置“1”法</li></ul><h6 id="判断溢出"><a href="#判断溢出" class="headerlink" title="判断溢出"></a>判断溢出</h6><p>与定点加减法一样，浮点加减运算最后一步也需判断滋出。在浮点规格化中已指出，当尾数之和（差）出现01.××·×或10.××…×时，并不表示溢出，只有将此数右规后，再根据阶码来判断浮点运算结果是否溢出。若机器数为补码，尾数为规格化形式，并假设阶符取2位，阶码的数值部分取7位，数符取2位，尾数的数值部分取n位，则它们能表示的补码在数轴上的表示范围如图6.14所示。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907193049182.png" class="" title="image-20230907193049182"><h5 id="浮点乘除运算"><a href="#浮点乘除运算" class="headerlink" title="浮点乘除运算"></a>浮点乘除运算</h5><p>两个浮点数相乘，乘积的阶码应为相乘两数的阶码之和，乘积的尾数应为相乘两数的尾数之积。两个浮点数相除，商的阶码为被除数的阶码减去除数的阶码，尾数为被除数的尾数除以除数的尾数所得的商，可用下式描述。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907193337603.png" class="" title="image-20230907193337603"><h3 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h3><p>针对每一种算术运算，都必须有一个相对应的基本硬件配置，其核心部件是加法器和寄存器。当需要完成逻辑运箅时，势必需要配置相应的逻辑电路，而ALU电路是既能完成算术运算又能完成逻辑运算的部件。</p><h5 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h5><p>图ALU框图。图中Ai和Bi为输入变量；ki为控制信号，ki的不同取值可决定该电路作哪一种算术运算或哪一种逻辑运算；Fi是输出函数。<img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907193543006.png" class="" title="image-20230907193543006"></p><h5 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h5><p>随着操作数位数的增加，电路中进位的速度对运算时间的影响也越来越大，为了提高运算速度，本节将通过对进位过程的分析设计快速进位链。</p><h6 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h6><p>并行加法器由若千个全加器组成，如图所示。n+1个全加器级联就组成了一个n+1位的并行加法器。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194049974.png" class="" title="image-20230907194049974"><h6 id="串行进位链"><a href="#串行进位链" class="headerlink" title="串行进位链"></a>串行进位链</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194223481.png" class="" title="image-20230907194223481"><h6 id="并行进位链"><a href="#并行进位链" class="headerlink" title="并行进位链"></a>并行进位链</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194421536.png" class="" title="image-20230907194421536"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194504727.png" class="" title="image-20230907194504727"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194525634.png" class="" title="image-20230907194525634">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器(三)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此<br>外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。</p><span id="more"></span><h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><h5 id="3-1-1存储器的分类"><a href="#3-1-1存储器的分类" class="headerlink" title="3.1.1存储器的分类"></a>3.1.1存储器的分类</h5><p>按存储介质分类：</p><ul><li>半导体存储器TTL 、MOS</li><li>磁表面存储器    磁头、磁载体</li><li>磁芯存储器        硬磁材料、环中元件</li><li>光盘存储器        激光、磁光材料</li></ul><p>按存取方式分类：</p><p>​存取时间与物理地址无关（随机访问）</p><ul><li>随机存取器       在程序的执行过程中可读可写</li><li>只读存储器       在程序的执行过程中只读</li></ul><p>​存取时间与物理地址有关（串行访问）</p><ul><li>顺序存取存储器     磁带</li><li>直接存取存储器     磁盘</li></ul><p>按在计算机中的作用分类：</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114021837.png" class="" title="image-20230828114021837"><h5 id="3-1-2存储器的层次结构"><a href="#3-1-2存储器的层次结构" class="headerlink" title="3.1.2存储器的层次结构"></a>3.1.2存储器的层次结构</h5><ul><li>存储器三个主要特性的关系</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114241506.png" class="" title="image-20230828114241506"><ul><li>缓存 -主存层次和主存 -辅存层次</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114428289.png" class="" title="image-20230828114428289"><h4 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h4><h5 id="3-2-1概述"><a href="#3-2-1概述" class="headerlink" title="3.2.1概述"></a>3.2.1概述</h5><p>主存储器（简称主存）的基本结构已在第1章介绍过。实际上，根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p><h6 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114829534.png" class="" title="image-20230828114829534"><h6 id="主存与CPU的联系"><a href="#主存与CPU的联系" class="headerlink" title="主存与CPU的联系"></a>主存与CPU的联系</h6><p>现代计算机的主存都由半导体集成电路构成，图中的驱动器、译码器和读写电路均制作在存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和CPU芯片可通过总线连接</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115057618.png" class="" title="image-20230828115057618"><p>当要从存储器读出某一信息字时，首先由CPU将该字的地址送到MAR,经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读至数据总线上，至于该信息由MDR送至什么地方，这已不是主存的任务，而是由CPU决定的。若要向主存存入一个信息字时，首先CPU将该字所在主存单元的地址经MAR到地址总线，并将信息字送入MDR,然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写人到对应地址线指出的主存单元中。</p><h6 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h6><p>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写人一个存储字。不同的机器存储字长也不同，为了满足字符处理的需要，常用8位二进制数表示一个字节，因此存储字长都取8的倍数。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370机的字长为32位，它可按字节寻址，即它的每一个存储字包含4个可独立寻址的字节，其地址分配如图所示。字地址是用该字高位字节的地址来表示，故其字地址是4的整数倍，正好用地址码的末两位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115954328.png" class="" title="image-20230828115954328"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120051543.png" class="" title="image-20230828120051543"><p>由图所示，对24位地址线的主存而言，按字节寻址的范围是16M,按字寻址的范围<br>为4M。由图所示，对24位地址线而言，按字节寻址的范围仍为16M,但按字寻址的范<br>围为8M。</p><h6 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h6><ul><li>存储容量：主存 存放二进制代码的总位数<ul><li>存储容量&#x3D;存储单元个数 ×存储字长</li></ul></li><li>存储速度<ul><li>存取时间：存储器的访问时间、读出时间、写入时间</li><li>存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间读周期 写周期</li></ul></li><li>存储器带宽：位&#x2F;秒</li></ul><h5 id="3-2-2半导体存储芯片介绍"><a href="#3-2-2半导体存储芯片介绍" class="headerlink" title="3.2.2半导体存储芯片介绍"></a>3.2.2半导体存储芯片介绍</h5><h6 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120855844.png" class="" title="image-20230828120855844"><ul><li><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读&#x2F;写电路的配合下完成对被选中单元的读&#x2F;写操作。</p></li><li><p>读&#x2F;写电路包括读出放大器和写人电路，用来完成读&#x2F;写操作。</p></li><li><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p></li><li><p>地址线是单向输入的，其位数与芯片容量有关。</p></li><li><p>数据线是双向的（有的芯片可用成对出现的数据线分别作为输入或输出），其位数与芯片可<br>读出或写人的数据位数有关。数据线的位数与芯片容量有关。</p></li><li><p>地址线和数据线的位数共同反映存储芯片的容量。例如，地址线为10根，数据线为4根，测芯片容量为2×4&#x3D;4K位；又如地址线为14根，数据线为1根，则其容量为16K位。</p></li><li><p>控制线主要有读&#x2F;写控制线与片选线两种。不同存储芯片的读&#x2F;写控制线和片选线可以不同。有的芯片的读&#x2F;写控制线共用1根（如2114），有的分用两根（如6264）；有的芯片的片选线用1根（如2114），有的用2根（如6264)。读&#x2F;写控制线决定芯片进行读&#x2F;写操作，片选线用来选择存储芯片。由于半导体存储器是由许多芯片组成的，为此需用片选信号来确定哪个芯片被选中。例如，一个64K×8位的存储器可由32片16K×1位的存储芯片组成，如图所示。但每次读出一个存储字时，只需选中8片。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828122056796.png" class="" title="image-20230828122056796"></li></ul><h6 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h6><p>半导体存储芯片的译码驱动方式有两种：线选法和重合法</p><ul><li>线选法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123207033.png" class="" title="image-20230828123207033"><p>图是一个16×1字节线选法存储芯片的结构示意图。它的特点是用一根字选择线（字线)，直接选中一个存储单元的各位（如一个字节）。这种方式结构较简单，但只适于容量不大的存储芯片。如当地址线为1111时，则第15根字线被选中，对应图4.9中的最后一行8位代码便可直接读出或写人。</p><ul><li>重合法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123235418.png" class=""><p>图是一个1K×1位重合法结构示意图。显然，只要用64根选择线(X、Y两个方向各32根)，便可选择32×32矩阵中的任一位。例如，当地址线为全0时，译码输出X。和Y。有效，矩阵中第0行、第0列共同选中的那位即被选中。由于被选单元是由X、Y两个方向的地址决定的，故称为重合法。当欲构成1K×1字节的存储器时，只需用8片如图4.10所示的芯片即可。</p><h5 id="3-2-3随机存储器"><a href="#3-2-3随机存储器" class="headerlink" title="3.2.3随机存储器"></a>3.2.3随机存储器</h5><h6 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h6><p>存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路，图4.11是一个由6个MOS管组成的基本单元电路。</p><p>图中T1-T4是一个由MOS管组成的触发器基本电路，T5、T6犹如一个开关，受行地址选择信号控制。由T1~T6。这6个M0S管共同构成一个基本单元电路。T7、T8。受列地址选择控制，分别与位线A’和A相连，它们并不包含在基本单元电路内，而是芯片内同一列的各个基本单元电路所共有的。</p><p>假设触发器已存有“1”信号，即A点为高电平。当需读出时，只要使行、列地址选择信号均有效，则使T5、T6、T7、T8均导通，A点高电平通过T6后，再由位线A通过T8作为读出放大器的输入信号，在读选择有效时，将“1”信号读出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904132216809.png" class="" title="image-20230904132216809"><p>写入时不论触发器原状态如何，只要将写入代码送至图的D端，在写选择有效时，经两个写放大器，使两端输出为相反电平。当行、列地址选择有效时，使T5、T6、T7、T8导通，并将A与A’点置成完全相反的电平。这样，就把欲写人的信息写入到该基本单元电路中。如欲写人“1”,即D&#x3D;1,经两个写放大器使位线A为高电平，位线A’为低电平，结果使A点为高，A’点为低，即写人了“1”信息。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904133958930.png" class="" title="image-20230904133958930"><p>2114RAM芯片的结构示意图如图所示。图中存储矩阵由64×64个基本单元电路组成，列I&#x2F;0电路即读&#x2F;写电路。10根地址线分为行地址A8-A3和列地址A9、A2、A1、A0,4根数据线为I&#x2F;O4-I&#x2F;O0,,它们是受输入&#x2F;输出三态门控制的双向总线，当CS和WE均为低电平时，输人三态门打开，I&#x2F;O4-I&#x2F;O0,上的数据即写人到指定地址单元中。当CS为低电平、WE为高电平时，输出三态门打开，列1&#x2F;0电路的输出经片内总线输出至数据线I&#x2F;O4~I&#x2F;O0上。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904134637357.png" class="" title="image-20230904134637357"><p>2114RAM芯片内的存储矩阵结构如图所示。其中每一个小方块均为一个由6个M0S管组成的基本单元电路，排列成64×64矩阵，64列对应64对T7,、T8管。又将64列分成4组，每组包含16列，并与一个读&#x2F;写电路相连，读&#x2F;写电路受WE和CS控制，4个读&#x2F;写电路对应4根数据线I&#x2F;O0-I&#x2F;O4。由图中可见，行地址经译码后可选中某一行；列地址经译码后可选中4组中的对应列，共4列。当对某个基本单元电路进行读&#x2F;写操作时，必须被行、列地址共同选中。例如，当A9-A0为全0时，对应行地址A8-A3为000000，列地址A、A2、A,、A。也为0000，则第0行的第0、16、32、48这4个基本单元电路被选中。此刻，若做读操作，则CS为低电平，WE为高电平，在读&#x2F;写电路的输出端1&#x2F;O1-I&#x2F;O4便输出第0行的第0、16、32、48这4个基本单元电路所存的信息。若做写操作，将写人信息送至I&#x2F;O0-I&#x2F;O4端口，并使CS为低电平、WE为低电平，同样这4个输人信息将分别写入到第0行的第0、16、32、48这4个单元之中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135156790.png" class="" title="image-20230904135156790"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135227371.png" class="" title="image-20230904135227371"><h6 id="动态RAM-DRAM"><a href="#动态RAM-DRAM" class="headerlink" title="动态RAM(DRAM)"></a>动态RAM(DRAM)</h6><p>常见的动态RAM基本单元电路有三管式和单管式两种，它们的共同特点都是靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。电容上的电荷一般只能维持1~2s,因此即使电源不掉电，信息也会自动消失。为此，必须在2s内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。由于它与静态RAM相比，具有集成度更高、功耗更低等特点，目前被各类计算机广泛应用。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135533598.png" class="" title="image-20230904135533598"><p>读出时，先对预充电管T4置一预充电信号（在存储矩阵中，每一列共用一个T4管)，使读数据线达高电平VDD。然后由读选择线打开T2,若T1的极间电容Cg存有足够多的电荷（被认为原存“1”)，使T1导通，则因T2、T1导通接地，使读数据线降为零电平，读出“0”信息。若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，由读出线的高低电平可区分其是读“1”，还是读“0”，只是它与原存信息反相。写入时，将写人信号加到写数据线上，然后由写选择线打开T3,这样，C.便能随输入信息充电（写“1”）或放电（写“0”）。</p><p>为了提高集成度，将三管电路进一步简化，去掉T1,把信息存在电容Cs上，将T2、T3合并成一个管子T,便得到单管M0S动态RAM基本单元电路，如图4.18所示。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904140145043.png" class="" title="image-20230904140145043"><p>读出时，字线上的高电平使T导通，若C,有电荷，经T管在数据线上产生电流，可视为读出“1”。若Cs无电荷，则数据线上无电流，可视为读出“0”。读操作结束时，Cs的电荷已释放完毕，故是破坏性读出，必须再生。写人时，字线为高电平使T导通，若数据线上为高电平，经T管对0，充电，使其存“1”；若数据线为低电平，则C,经T放电，使其无电荷而存“0”。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164519993.png" class="" title="image-20230904164519993"><p>这是一个1K×1位的存储芯片，图中每一小方块代表由3个M0S管组成的动态RAM基本单元电路。它们排列成32×32的矩阵，每列都有一个刷新放大器(用来形成再生信息)和一个预充电管（图中未画），芯片有10根地址线，采用重合法选择基本单元电路。</p><p>读出时，先置以预充电信号，接着按行地址A9-A5经行译码器给出读选择信号，同时由列地址A4~A0。经列译码器给出列选择信号。只有在行、列选择信号共同作用下的基本单元电路才能将其信息经读数据线送到读&#x2F;写控制电路，并从数据线D输出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164942057.png" class="" title="image-20230904164942057"><p>写入时，在受行地址控制的行译码器给出的写选择信号的作用下；选中芯片的某一行，并在列地址的作用下，由列译码器的输出控制读&#x2F;写控制电路，只将数据线D的信息送到被选中列的写数据线上，信息即被写人到行列共同选中的基本单元电路中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165055182.png" class="" title="image-20230904165055182"><p>16K×1位的存储芯片共有16K个单管M0S基本单元电路，它们排列成128×128的矩阵，如图所示。图中的行线就是图4.18中的字线，列线就是图4.18中的数据线。128行分布在读放大器的左、右两侧（左侧为0<del>63行，右侧为64</del>127行）。每根行选择线与128个M0S管的栅极相连。128列共有128个读放大器，它的两侧又分别与64个M0S管相连，每根列线上都有一个列地址选择管。128个列地址选择管的输出又互相并接在一起与I&#x2F;0缓冲器相连，I&#x2F;0缓冲器的一端接输出驱动器，可输出数据；另一端接输入器，供数据输入</p><p>读出时，行、列地址受RAS和CAS控制，分两次分别存人行、列地址缓存器。行地址经行译码后选中一行，使该行上所有的M0S管均导通，并分别将其电容C,上的电荷反映到128个读放大器的某一侧（第0-63行反映到读放大器的左侧，第64-127行反映到读放大器的右侧）。读放大器的工作原理像一个撬撬板电路，类似于一个触发器，其左右两侧电平相反。此外列地址经列译码后选中某一列，该列上的列地址选择管导通，即可将读放大器右侧信号经读&#x2F;写线、I&#x2F;0缓冲器输出至Dout端。例如，选中第63行、第0列的单管MOS电路，若其C。有电荷为“1”状态，则反映到第0列读放大器的左侧为“1”，右侧为“0”，经列地址选择管输出至Dout为0，与原存信息反相。同理，第0-62行经读放大器至输出线Dout的信息与原存信息均反相。而读出第64~127行时，因它们的电容C。上的电荷均反映到读放大器的右侧，故经列地址选择管输出至Dout的信息均同相。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165802445.png" class="" title="image-20230904165802445"><p>写人时，行、列地址也要分别送人芯片内的行、列地址缓存器，经译码可选中某行、某列。输入信息D通过数据输人器，经I&#x2F;0缓冲器送至读&#x2F;写线上，但只有被选中的列地址选择管导通，可将读&#x2F;写线上的信息送至该列的读放大器右侧，破坏了读放大器的平衡，使读放大器的右侧与输人信息同相，左侧与输入信息反相，读放大器的信息便可写入到选中行的C,中。例如，选中第64行、第127列，输入信息为“1”，则第127列地址选择管导通，将“1”信息送至第127列的读放大器的右侧。虽然第64行上的128个M0S管均导通，但惟有第64行、第127列的M0S管能将读放大器的右侧信息“1”对C,充电，使其写入“1”。值得注意的是写人读放大器左侧行的信息与输入信息都是反相的，而由读出过程分析又知，对读放大器左侧行进行读操作时，读出的信息也是反相的，故最终结果是正确的。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165825227.png" class="" title="image-20230904165825227"><h6 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h6><p>由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的渎&#x2F;写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2s,这个时间称为刷新周期，又称再生周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证动态RAM内的信息不丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。</p><ul><li>集中刷新</li></ul><p>集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读&#x2F;写操作。例如，对128×128矩阵的存储芯片进行刷新时，若存取周期为0.55，刷新周期为2s(占4000个存取周期)，则对128行集中刷新共儒64us(占128个存取周期)，其余的1936s(共3872个存取周期)用来读&#x2F;写或维持信息，如图所示。由于在这64us时间内不能进行读&#x2F;写操作，故称为“死时间”，又称访存“死区”，所占比率28&#x2F;4000×100%&#x3D;3.2%,称为死时间率。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170137608.png" class="" title="image-20230904170137608"><ul><li>分散刷新</li></ul><p>分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期tc分成两段，前半段tm用来读&#x2F;写或维持信息，后半tr段用来刷新，即c&#x3D;tm+tr。若读&#x2F;写周期为0.5us,则存取周期为1s。仍以128×128矩阵的存储芯片为例，刷新按行进行，每隔128s就可将存储芯片全部刷新一遍，如图所示。这比允许的间隔2ms要短得多，而且也不存在停止读&#x2F;写操作的死时间，但存取周期长了，整个系统速度降低了。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170449800.png" class="" title="image-20230904170449800"><ul><li>异步刷新</li></ul><p>异步刷新是前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为2s的特点。例如，对于存取周期为0.5us,排列成128×128的存储芯片，可采取在2ms内对128行各刷新一遍，即每隔15.6s(2000s÷128≈15.6s)刷新一行，而每行刷新的时间仍为0.5s,如图所示。这样，刷新一行只停业一个存取周期，但对每行来说，刷新间隔时间仍为2ms,而“死时间”缩短为0.5心8。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170623026.png" class="" title="image-20230904170623026"><h6 id="动态RAM与静态RAM比较"><a href="#动态RAM与静态RAM比较" class="headerlink" title="动态RAM与静态RAM比较"></a>动态RAM与静态RAM比较</h6><p>目前，动态RAM的应用比静态RAM要广泛得多。其原因如下：</p><ul><li>在同样大小的芯片中，动态RAM的集成度远高于静态RAM,如动态RAM的基本单元电路为一个MOS管，静态RAM的基本单元电路可为4~6个MOS管。</li><li>动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少。</li><li>动态RAM的功耗比静态RAM小。</li><li>动态RAM的价格比静态RAM的价格便宜。当采用同一档次的实现技术时，动态RAM的容量大约是静态RAM容量的4-8倍，静态.RAM的存取周期比动态RAM的存取周期快8-16倍，但价格也贵8~16倍。.</li></ul><p>动态RAM也有缺点：</p><ul><li>由于使用动态元件（电容），因此它的速度比静态RAM低。</li><li>动态RAM需要再生，故需配置再生电路，也需要消耗一部分功率。通常，容量不大的高速缓冲存储器大多用静态RAM实现。</li></ul><h5 id="3-2-4只读存储器-ROM"><a href="#3-2-4只读存储器-ROM" class="headerlink" title="3.2.4只读存储器(ROM)"></a>3.2.4只读存储器(ROM)</h5><p>按R0M的原始定义，一且注入原始信息即不能改变，但随着用户的需要，总希望能任意修改ROM内的原始信息。这便出现了PROM、EPROM和EEPROM等。对半导体ROM而言，基本器件为两种：MOS型和TL型。</p><ul><li>掩模ROM(MROM)<ul><li>行列选择线交叉处有MOS管为“1”</li><li>行列选择线交叉处无MOS管为“0”</li></ul></li><li>PROM(一次性编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171603204.png" class="" title="image-20230904171603204"><ul><li>EPROM(多次编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171626849.png" class="" title="image-20230904171626849"><ul><li><p>EEPROM(多次性编程)</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul></li><li><p>Flash Memory(闪速型存储器)</p></li></ul><p>进入到20世纪.80年代，又出现了一种闪速存储器(lash Memory),又称快擦型存储器，它是在EPROM和EEPROM工艺基础上产生的一种新型的、具有性能价格比更好、可靠性更高的可擦写非易失性存储器。它既有EPROM的价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性。它具有整片擦除的特点，其擦除、重写的速度快。一块1M位的闪速存储芯片的擦除、重写时间小于5s,比一般标准的EEPROM快得多，已具备了RAM的功能，可与CPU直接连接。它还具有高速编程的特点，例如，采用快速脉冲编程算法对28256闪速存储芯片每字节的编程时间仅需100s。此外，该器件具有存储器访问周期短，功耗低及与计算机接口简单等优点。</p><h5 id="3-2-5存储器与CPU的连接"><a href="#3-2-5存储器与CPU的连接" class="headerlink" title="3.2.5存储器与CPU的连接"></a>3.2.5存储器与CPU的连接</h5><h6 id="存储芯片的扩展"><a href="#存储芯片的扩展" class="headerlink" title="存储芯片的扩展"></a>存储芯片的扩展</h6><ul><li>位扩展</li></ul><p>位扩展是指增加存储字长，例如，2片1K×4位的芯片可组成1K×8位的存储器，如图所示。图中2片2114的地址线A9-A0,、CS、WE都分别连在一起，其中一片的数据线作为高4位D7-D4,另一片的数据线作为低4位D3~D0。这样，便构成了一个1K×8位的存储器。（10根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172431505.png" class="" title="image-20230904172431505"><ul><li>字扩展</li></ul><p>字扩展是指增加存储器字的数量。例如，用2片1K×8位的存储芯片可组成一个2K×8位的存储器，即存储字增加了一倍，如图所示。在此，将A10用做片选信号。由于存储芯片的片选输入端要求低电平有效，故当A10为低电平时，CS0有效，选中左边的1K×8位芯片；当A10为高电平时，反相后CS1有效，选中右边的1K×8位芯片。（11根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172643451.png" class="" title="image-20230904172643451"><ul><li>位、字扩展</li></ul><p>字、位扩展是指既增加存储字的数量，又增加存储字长。图示意用8片1K×4位的芯片组成4K×8位的存储器。（12根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172920491.png" class="" title="image-20230904172920491"><p>由图中可见，每2片构成一组1K×8位的存储器，4组便构成4K×8位的存储器。地址线A11、A10经片选译码器得到4个片选信号CS0、CS1、CS2、CS3,分别选择其中1K×8位的存储芯片。WE为读&#x2F;写控制信号。</p><h6 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h6><p>存储芯片与CPU芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。</p><ul><li>地址线的连接</li></ul><p>存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU地址线的低位与存储芯片的地址线相连。CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。例如，设CPU地址线为16位A15-A0。,1K×4位的存储芯片仅有10根地址线A9-A0。,此时，可将CPU的低位地址A9-A0与存储芯片地址线A9-A0相连。又如，当用16K×1位存储芯片时，则其地址线有14根A13-A0。,此时，可将CPU的低位地址A13-A0。与存储芯片地址线A13~A0相连。</p><ul><li>数据线的连接</li></ul><p>同样，CPU的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p><ul><li>读&#x2F;写命令线的连接</li></ul><p>CPU读&#x2F;写命令线一般可直接与存储芯片的读&#x2F;写控制端相连，通常高电平为读，低电平为写。有些CPU的读&#x2F;写命令线是分开的，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p><ul><li>片选线的连接</li></ul><p>片选线的连接是CPU与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。片选有效信号与CPU的访存控制信号MREQ(低电平有效)有关，因为只有当CPU要求访存时，才需选择存储芯片。若CPU访问I&#x2F;O，则MRE0为高电平，表示不要求存储器工作。此外，片选有效信号还和地址有关，因为CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。通常需用到一些逻辑电路，如译码器及其他各种门电路，来产生片选有效信号。</p><ul><li>合理选择存储芯片</li></ul><p>合理选择存储芯片主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽重使连线简单方便。</p><h5 id="3-2-6存储器的校验"><a href="#3-2-6存储器的校验" class="headerlink" title="3.2.6存储器的校验"></a>3.2.6存储器的校验</h5><p>在计算机运行过程中，由于种种原因致使数据在存储过程中可能出现差错。为了能及时发现错误并及时纠正错误，通常可将原数据配成汉明编码。</p><h6 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h6><p>任意两组合法代码之间二进制位数的最少差异编码的纠错、检错能力与编码的最小距离有关</p><p>L-1&#x3D;D+C(D&gt;&#x3D;C)</p><ul><li>L:编码的最小距离  L&#x3D;3</li><li>D:检测错误的位数 具有一<strong>位</strong>纠错</li><li>C:纠正错误的位数</li></ul><p>汉明码是具有一位纠错能力的编码</p><h6 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h6><p>汉明码的三要素</p><ul><li>汉明码的组成需增添？位检测位</li></ul><p>$$<br>2^k&gt;&#x3D;n+k+1<br>$$</p><ul><li>检测位的位置?</li></ul><p>$$<br>2^i(i&#x3D;0,1,2,3,……)<br>$$</p><ul><li>检测为的取值？</li></ul><p>检测位的取值与该位所在的检测“小组”中承担的奇偶校验任务有关</p><h5 id="3-2-7提高访存速度的措施"><a href="#3-2-7提高访存速度的措施" class="headerlink" title="3.2.7提高访存速度的措施"></a>3.2.7提高访存速度的措施</h5><p>随着计算机应用领域的不断扩大，处理的信息量越来越多，对存储器的工作速度和容量要求也越来越高。此外，因CPU的功能不断增强，&#x2F;0设备的数量不断增多，致使主存的存取速度已成为计算机系统的瓶颈。可见，提高访存速度也成为迫不及待的任务。为了解决此问题，除了寻找高速元件和采用层次结构以外，调整主存的结构也可提高访存速度。</p><ul><li>单体多字系统</li></ul><p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可以在一个存取周期内，从同一地址取出4条指令，然后再逐条将指令送至CPU执行，即每隔1&#x2F;4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183437547.png" class="" title="image-20230904183437547"><p>图中示意了一个单体四字结构的存储器，每字W位。按地址在一个存取周期内可读出4×W位的指令或数据，使主存带宽提高到4倍。显然，采用这种办法的前提是：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p><ul><li>多体并行系统</li></ul><p>多体并行系统就是采用多体模块组成的存储器。每个模块有相同的容量和存取速度，各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读&#x2F;写电路，它们能并行工作，又能交叉工作。并行工作即同时访问N个模块，同时启动，同时读出，完全并行地工作（不过，同时读出的N个字在总线上需分时传送)。图4.42是适合于并行工作的高位交叉编址的多体存储器结构示意图，图中程序因按体内地址顺序存放（一个体存满后，再存人下一个体），故又有顺序存储之称。显然，高位地址可表示体号，低位地址为体内地址。按这种编址方式，只要合理调动，使不同的请求源同时访问不同的体，便可实现并行工作。例如，当一个体正与CPU交换信息时，另一个体可同时与外部设备进行直接存储器访问，实现两个体并行工作。这种编址方式由于一个体内的地址是连续的，有利于存储器的扩充。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183724260.png" class="" title="image-20230904183724260"><p>下图是按低位交叉编址的多体模块结构示意图。由于程序连续存放在相邻体中，故又有交叉存储之称。显然低位地址用来表示体号，高位地址为体内地址。这种编址方法又称为模M编址(M等于模块数)，表4.3列出了模4交叉编址的地址号。一般模块数M取2的方幂，使硬件电路比较简单。有的机器为了减少存储器冲突，采用质数个模块，例如，我国银河机的M为31,其硬件实现比较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183908836.png" class="" title="image-20230904183908836"><ul><li>高性能存储芯片<ul><li>SDRAM(同步DRAM):在系统时钟的控制下进行读入和写出，CPU无需等待</li><li>RDRAM:有Rambus开发，只要解决存储宽带问题</li><li>带Cache的DRAM:在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</li></ul></li></ul><h4 id="3-3高速缓冲存储器"><a href="#3-3高速缓冲存储器" class="headerlink" title="3.3高速缓冲存储器"></a>3.3高速缓冲存储器</h4><h5 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h5><p>在多体并行存储系统中，由于I&#x2F;O设备向主存请求的级别高于CPU访存，这就出现了CPU等待&#x2F;0设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU的工作效率。为了避免CPU与I&#x2F;O设备争抢访存，可在CPU与主存之间加一级缓存，这样，主存可将CPU要取的信息提前送至缓存，一旦主存在与&#x2F;0设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。从另一角度来看，主存速度的提高始终跟不上CPU的发展。据统计，CPU的速度平均每年改进60%，而组成主存的动态RAM速度平均每年只改进7%，结果是CPU和动态RAM之间的速度间隙平均每年增大50%。例如，100MHz的Pentium处理器平均每10ns就执行一条指令，而动态RAM的典型访问时间为60~120ns。这也希望由高速缓存Cache来解决主存与CPU速度的不匹配问题。</p><p>Cache的出现使CPU可以不直接访问主存，而与高速Cache交换信息。那么，这是否可能呢？通过大量典型程序的分析，发现CPU从主存取指令或取数据，在一定时间内，只是对主存局部地址区域的访问。这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用（如子程序、循环程序和一些常数），即指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性，这就称为程序访问的局部性原理。根据这一原理，很容易设想，只要将CPU近期要用到的程序和数据提前从主存送到Cache,那么就可以做到CPU在一定时间内只访问Cache.。一般Cache采用高速的SRAM制作，其价格比主存贵，但因其容量远小于主存，因此能很好地解决速度和成本的矛盾。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904184832650.png" class="" title="image-20230904184832650"><h6 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h6><p>任何时刻都有一些主存块处在缓存块中。CPU欲读取主存某字时，有两种可能：一种是所需要的字已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字)；另一种是所需的字不在Cache内，此时需将该字所在的主存整个字块一次调入Cache中(Cache与主存之间是字块传送)。如果主存块已调入缓存块，侧称该主存块与缓存块建立了对应关系。</p><p>上述第一种情况为CPU访问Cache命中，第二种情况为CPU访问Cache不命中。由于缓存的块数C远小于主存的块数M,因此，一个缓存块不能惟一地、永久地只对应一个主存块，故每个缓存块需设一个标记，用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位（或m位中的一部分）与缓存块的标记进行比较，以判断所读的信息是否已在缓存中。</p><p>Cache的容量与’块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。命中率是指CPU要访问的信息已在Cache内的比率。</p><h6 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904190947078.png" class="" title="image-20230904190947078"><ul><li>Cache存储体</li></ul><p>Cache存储体以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高。</p><ul><li>地址映射变换机构</li></ul><p>地址映射变换机构是将CPU送来的主存地址转换为Cache地址。由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。而地址变换又与主存地址以什么样的函数关系映射到Cache中（称为地址映射）有关</p><ul><li>替换机构</li></ul><p>当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache.。有关替换算法详见特别需指出的是，Cache对用户是透明的，即用户编程时所用到的地址是主存地址，用户根术不知道这些主存块是否已调入Cache内。因为，将主存块调入Cache的任务全由机器硬件自动完成。</p><ul><li>Cache的读写操作</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904195651008.png" class="" title="image-20230904195651008"><p>写操作比较复杂，因为对Cache块内写人的信息，必须与被映射的主存块内的信息完全一致。当程序运行过程中需对某个单元进行写操作时，会出现如何使Cache与主存内容保持一致的问题。目前主要采用以下几种方法。</p><ul><li>写直达法</li></ul><p>写直达法(Write-through),又称为存直达法（Store-through),即写操作时数据既写入Cache又写入主存。它能随时保证主存和Cache的数据始终一致，但增加了访存次数。</p><ul><li>写回法</li></ul><p>写回法(Write-back),又称为拷回法(Copy-back),即写操作时只把数据写入Cache而不写入主存，但当Cache数据被替换出去时才写回主存。可见写回法Cache中的数据会与主存中的不一致。为了识别Cache中的数据是否与主存一致，Cache中的每一块要增设一个标志位，该位有两个状态：“清”（表示未修改过，与主存一致）和“浊”（表示修改过，与主存不一致)。在Cache替换时，“清”的Cache块不必写回主存，因为此时主存中相应块的内容与Cache块是一致的。在写Cache时，要将该标志位设置为“浊”，替换时此Cache块要写回主存，同时要使标志位为“清”。</p><h6 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h6><p>Cache刚出现时，典型系统只有一个缓存，近年来普遍采用多个Cache。其含义.有两方面：一是增加Cache的级数；二是将统一的Cache变成分立的Cache</p><ul><li>单一缓存和二级缓存：片内Cache、片外Cache</li><li>统一缓存和分立缓存：统一缓存是指指令和数据都存放在同一缓存内的Cache;分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令Cache,一个称为数据Cache。.两种缓存的选用主要考虑如下两个因素。其一，它与主存结构有关，如果计算机的主存是统一的（指令、数据存储在同一主存内），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。其二，它与机器对指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般都采用分立缓存。</li></ul><h5 id="3-3-2-Cache——主存地址映射"><a href="#3-3-2-Cache——主存地址映射" class="headerlink" title="3.3.2 Cache——主存地址映射"></a>3.3.2 Cache——主存地址映射</h5><p>由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射（固定的映射关系)、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。</p><ul><li>直接映射</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201458711.png" class="" title="image-20230904201458711"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201608551.png" class="" title="image-20230904201608551"><p>这种方式的优点是实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。由图可见，主存地址高m位被分成两部分：低c位是指Cace的字块地址，高t位(t&#x3D;m一c)是指主存字块标记，它被记录在建立了对应关系的缓存块的“标记”位中。当缓存接到CPU送来的主存地址后，只儒根据中间c位字段（假设为00…01）找到Cache字块1，然后根据字块1的“标记”是否与主存地址的高t位相符来判断，若符合且有效位为“1”（有效位用来识别Cache存储块中的数据是否有效，因为有时Cache中的数据是无效的，例如，在初始时刻Cache应该是“空”的，其中的内容是无意义的)，表示该Cache块已和主存的某块建立了对应关系（即已命中)，则可根据b位地址从Cace中取得信息；若不符合，或有效位为“0”（即不命中)，则从主存读人新的字块来替代旧的字块，同时将信息送往CPU,并修改Cache“标记”。如果原来有效位为“0”，还得将有效位置成“1”。</p><p>直接映射方式的缺点是不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><ul><li>全相联映射</li></ul><p>全相联映射允许主存中每一字块映射到Cache中的任何一块位置上，如图所示。这种映射方式可以从已被占满的Cache中替换出任一旧字块。显然，这种方式灵活，命中率也更高，缩小了块冲突率。与直接映射相比，它的主存字块标记从t位增加到：t+c位，这就使Cache“标记”的位数增多，而且访问Cache时主存字块标记需要和Cache的全部“标记”位进行比较，才能判断出所访问主存地址的内容是否已在Cache内。这种比较通常采用“按内容寻址”的相联存储器（见附录4A)来完成。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904202232710.png" class="" title="image-20230904202232710"><p>总之，这种方式所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。</p><ul><li>组相联映射</li></ul><p>组相联映射是对直接映射和全相联映射的一种折中。它把Cache分为Q组，每组有R块，并有以下关系：</p><p>i&#x3D;j mod Q</p><p>其中，i为缓存的组好，j为主存的块号。某一主存块按模Q将其映射到级存的第i组内</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904203103631.png" class="" title="image-20230904203103631"><ul><li>直接 ：某一 主存块只能固定映射到某一缓存块 </li><li>全相联 ：某一主存块能映射到任一缓存块</li><li>组相联  ：某一主存块只能映射到某一缓存组中的任一块</li></ul><h5 id="3-3-3替换策略"><a href="#3-3-3替换策略" class="headerlink" title="3.3.3替换策略"></a>3.3.3替换策略</h5><ul><li>先进先出（First-In-First-Out,FIFO）</li></ul><p>FIF0算法选择最早调入Cache的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，开销小，但没有根据访存的局部性原理，故不能提高Cache的命中率。因为最早调人的信息可能以后还要用到，或者经常要用到，如循环程序。</p><ul><li>近期最少使用算法(Least Recently Used,LRU）</li></ul><p>LRU算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它需要随时记录Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU算法的平均命中率比FIFO的高。</p><ul><li>随机法</li></ul><p>随机法是随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块，但它也没有根据访存的局部性原理，故不能提高Cache的命中率。</p><h4 id="3-4辅助存储器"><a href="#3-4辅助存储器" class="headerlink" title="3.4辅助存储器"></a>3.4辅助存储器</h4><h5 id="3-4-1概述"><a href="#3-4-1概述" class="headerlink" title="3.4.1概述"></a>3.4.1概述</h5><p>辅助存储器作为主存的后援设备又称为外部存储器，简称外存，它与主存一起组成了存储器系统的主存一辅存层次。与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。而主存具有速度快、成本高、容量小等特点，而且大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。</p><p>目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。</p><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul><li>不能直接与CPU交换信息</li></ul><h6 id="磁表面存储技术"><a href="#磁表面存储技术" class="headerlink" title="磁表面存储技术"></a>磁表面存储技术</h6><ul><li>记录密度</li><li>存储容量</li><li>平均寻址时间 </li><li>数据传输率 </li><li>误码率 辅存的速</li></ul><h5 id="3-4-2磁记录原理和记录方式"><a href="#3-4-2磁记录原理和记录方式" class="headerlink" title="3.4.2磁记录原理和记录方式"></a>3.4.2磁记录原理和记录方式</h5><ul><li>磁记录原理</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204226140.png" class="" title="image-20230904204226140"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204245123.png" class="" title="image-20230904204245123"><ul><li>磁表面存储器的记录方式</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204359480.png" class="" title="image-20230904204359480"><h5 id="3-4-3硬度磁盘存储器"><a href="#3-4-3硬度磁盘存储器" class="headerlink" title="3.4.3硬度磁盘存储器"></a>3.4.3硬度磁盘存储器</h5><h6 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h6><ul><li>固定磁头和移动磁头 </li><li>可换盘和固定盘</li></ul><h6 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204604155.png" class="" title="image-20230904204604155"><p>硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片3大部分组成</p><ul><li>磁盘驱动器</li></ul><p>磁盘驱动器是主机外的一个独立装置，又称磁盘机。大型磁盘驱动器要占用一个或几个机柜，温盘只是一个比砖还小的小匣子。驱动器主要包括主轴、定位驱动及数据控制等3部分。图示意了磁盘驱动器的主轴系统和定位驱动系统。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204817860.png" class="" title="image-20230904204817860"><ul><li><p>磁盘控制器</p><ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令 </li><li>实现主机和驱动器之间的数据格式转换 </li><li>控制磁盘驱动器读写</li></ul><p>磁盘控制器是主机与磁盘驱动器之间的接口</p></li><li><p>盘片：由硬质铝合金材料制成</p></li></ul><h5 id="3-4-4软磁盘存储器"><a href="#3-4-4软磁盘存储器" class="headerlink" title="3.4.4软磁盘存储器"></a>3.4.4软磁盘存储器</h5><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>高</td><td>低</td></tr><tr><td>磁头</td><td>固定、活动、浮动</td><td>活动</td></tr><tr><td>盘片</td><td>固定盘、盘组 大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>环境</td><td>苛刻</td><td></td></tr></tbody></table><h5 id="3-4-7光盘存储器"><a href="#3-4-7光盘存储器" class="headerlink" title="3.4.7光盘存储器"></a>3.4.7光盘存储器</h5><p>采用光存储技术 采用非磁性介质 采用磁性介质 </p><p>第一代光存储技术 不可擦写</p><p>第二代光存储技术  可擦写</p><h6 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h6><p>只读型和只写一次型 热作用（物理或化学变化）</p><p>可擦写光盘  热磁效应 </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线(二)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章着重介绍系统总线的基本概念及其分类、结构和总线控制，逻辑。要求读者能对系统总<br>线在计算机硬件结构中的地位和作用有所了解。</p><span id="more"></span><h4 id="2-1系统总线的基本概念"><a href="#2-1系统总线的基本概念" class="headerlink" title="2.1系统总线的基本概念"></a>2.1系统总线的基本概念</h4><h5 id="2-1-1什么是总线？"><a href="#2-1-1什么是总线？" class="headerlink" title="2.1.1什么是总线？"></a>2.1.1什么是总线？</h5><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p><h5 id="2-1-2总线上的信息传送"><a href="#2-1-2总线上的信息传送" class="headerlink" title="2.1.2总线上的信息传送"></a>2.1.2总线上的信息传送</h5><p>串行</p><p>并行</p><h4 id="2-2-总线的分类"><a href="#2-2-总线的分类" class="headerlink" title="2.2 总线的分类"></a>2.2 总线的分类</h4><h5 id="2-2-1-片内总线"><a href="#2-2-1-片内总线" class="headerlink" title="2.2.1 片内总线"></a>2.2.1 片内总线</h5><p>片内总线：指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间，寄存器与算逻单元ALU之间都由片内总线连接</p><h5 id="2-2-2-系统总线"><a href="#2-2-2-系统总线" class="headerlink" title="2.2.2 系统总线"></a>2.2.2 系统总线</h5><p>系统总线分三类：数据总线、地址总线、控制总线</p><p>数据总线：用来传输各个功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关</p><p>地址总线：主要用来指出数据总线上的源数据或目的数据在主存单元的地址或I&#x2F;O设备地址，单项传输，与存储地址、I&#x2F;O地址有关</p><p>控制总线：用来发出各种控制信号的传输线，控制信号有输入（存储器读、存储器写、总线允许、中断确认）；控制信号有输出（中断请求、总线请求）</p><p>常见的控制型号如下：</p><ul><li>时钟：用来同步各个操作</li><li>复位：初始化所有部件</li><li>总线请求：表示某部件需获得总线使用权</li><li>总线允许：表示需要获得总线使用权的部件以获得控制权</li><li>中断请求：表示某部件提出中断请求</li><li>中断响应：表示中断请求已被接收</li><li>存储器写：将数据总线上的数据写至存储器的指定单元内</li><li>存储器读：将指定存储单元中的数据读到数据总线上</li><li>I&#x2F;O读：从指定的I&#x2F;O端口将数据读到数据总线上</li><li>I&#x2F;O写：将数据总线上的数据输出到指定的I&#x2F;O端口内</li><li>传输响应:表示数据应被接受，或已将数据送至数据总线上</li></ul><h5 id="2-2-3-通信总线"><a href="#2-2-3-通信总线" class="headerlink" title="2.2.3 通信总线"></a>2.2.3 通信总线</h5><p>通信总线：用于计算机系统之间或计算机系统与其他系统（控制仪表、移动通信等）之间的通信</p><p>传输方式：串行通信总线、并行同行总线</p><p>串行总线：是指数据在单条1位宽的传输线上，一位一位地按顺序分时传送，如1字节的数据，在串行传送中，1字节的数据要通过8此有地位到高位按顺序逐位传输</p><p>并行总线：是指数据在多条并行在1位宽的传输线上，同时由源传送到目的地，如1字节的数据，在并行传送中，要通过8条并行传输线同时由源传送到目的地。</p><h4 id="2-3总线特性及性能指标"><a href="#2-3总线特性及性能指标" class="headerlink" title="2.3总线特性及性能指标"></a>2.3总线特性及性能指标</h4><h5 id="2-3-1-总线的特征"><a href="#2-3-1-总线的特征" class="headerlink" title="2.3.1 总线的特征"></a>2.3.1 总线的特征</h5><ul><li>机型特性：尺寸、形状、管脚数 及排列顺序</li><li>电器特性：传输方向和有效的电平范围</li><li>功能特性：每根传输线的功能</li></ul><p>​功能分类：地址、数据、控制</p><p>​地址总线：用来指出地址码</p><p>​数据总线：用来传递数据</p><p>​控制总线：发出信号控制，既有从CPU发出的如存储器的读&#x2F;写、I&#x2F;O的读&#x2F;写，也有I&#x2F;O向CPU发来的，如中断请求、DMA请求</p><ul><li>时间特性：信号的时序关系</li></ul><h5 id="2-3-2-总线性能指标"><a href="#2-3-2-总线性能指标" class="headerlink" title="2.3.2 总线性能指标"></a>2.3.2 总线性能指标</h5><ul><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟同步&#x2F;异步：同步、不同步</li><li>总线复用：地址线与数据线复用</li><li>信号线数：地址线、数据线、控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、技术</li><li>其他指标：负载能力</li></ul><h5 id="2-3-3总线标准"><a href="#2-3-3总线标准" class="headerlink" title="2.3.3总线标准"></a>2.3.3总线标准</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110537846.png" class="" title="image-20230828110537846"><h4 id="2-4总线结构"><a href="#2-4总线结构" class="headerlink" title="2.4总线结构"></a>2.4总线结构</h4><h5 id="2-4-1-单总线结构"><a href="#2-4-1-单总线结构" class="headerlink" title="2.4.1 单总线结构"></a>2.4.1 单总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110613375.png" class="" title="image-20230828110613375"><h5 id="2-4-2多总线结构"><a href="#2-4-2多总线结构" class="headerlink" title="2.4.2多总线结构"></a>2.4.2多总线结构</h5><p>双总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110652825.png" class="" title="image-20230828110652825"><h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110711335.png" class="" title="image-20230828110711335"><p>三总线的另一结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110728329.png" class="" title="image-20230828110728329"><h5 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110750849.png" class="" title="image-20230828110750849"><h5 id="2-4-3总线结构举例"><a href="#2-4-3总线结构举例" class="headerlink" title="2.4.3总线结构举例"></a>2.4.3总线结构举例</h5><p>传统微型机总线</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110815002.png" class="" title="image-20230828110815002"><p>VL-BUS局部总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110840540.png" class="" title="image-20230828110840540"><p>PCI总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110904069.png" class="" title="image-20230828110904069"><p>多层 PCI 总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110922273.png" class="" title="image-20230828110922273"><h4 id="2-5总线控制"><a href="#2-5总线控制" class="headerlink" title="2.5总线控制"></a>2.5总线控制</h4><h5 id="2-5-1-总线判优控制"><a href="#2-5-1-总线判优控制" class="headerlink" title="2.5.1 总线判优控制"></a>2.5.1 总线判优控制</h5><p>基本概念：</p><ul><li><p>主模块对总线有控制权</p></li><li><p>从模块        响应从主设备发来的总线命令</p></li><li><p>总线判优控制：集中式、分布式</p><p>集中式包括：</p><ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li></ul><p>链式查询方式</p><p>下图为链式查询，图中控制总线有3根线用于总线控制（BS总线忙、BR总线请求、BG总线统一），其中总线同意是串行的一个I&#x2F;O接口送至下一个I&#x2F;O接口。如果BG达到的接口有请求，BG信号就不再往下传，意味着改接口获得了总线的使用全，并建立总线忙BS信号，表示它占用了总线，可见在链式查询中，离总线控制部件最近的设备具有最高的优先级。这种方式的特点是：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，！对电路故障很敏感，且优光级别低的设备可能很难获得请求。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111006976.png" class="" title="image-20230828111006976"><p>计数器定时查询方式</p><p>下图是计数器定时查询方式。与链式查询方式相比，多了一组设备地址线，少了一<br>根总线同意线BG。总线控制部件接到由BR送来的总线请求信号后，在总线未被使用(BS&#x3D;0)<br>的情况下，总线控制部件屮的计数器开始计数，并通过设备地址线.向各设备发出一组地址信号。<br>当某个请求占用总线的设备地址与计数值一致时，便获得总线使用权，此吋终止计数查询。这种<br>方式的特点是：计数可以从“0”开始，此时一且设备的优先次序被固定，设备的优先级就按<br>0,1,…,n的顺序降序排列，而且固定不变；计数也可以从上一次计数的终止点开始，即是一种循<br>环方法，此时设备使用总线的优先级相等；计数器的初始值还可由程序设置，战优先次序可以改变。<br>这种方式对电路故障不如链式查询方式敏感，但增加了控制线（设备地址）数，控制也较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111057390.png" class="" title="image-20230828111057390"><p>​独立亲求方式</p><p>下图是独立请求方式。由图中可见，每一台设备均有一对总线请求线BR,和总线同意线BG:。当设备要求使用总线时，便发出该设备的请求信号。总线挖制部件中有一排队电路，可根据优先次序确定响应哪一台设备的靖求。这种方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），似控制线数量多，总线控删更复杂。链式查询中仪用两根线确定总线使用权属于哪个设备，在计数器查询巾大致用log2 n根线，其中n是允许接纳的最大设备数，而独立请求方式需采用2n根线。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111148122.png" class="" title="image-20230828111148122"><h5 id="1-5-2总线通信控制"><a href="#1-5-2总线通信控制" class="headerlink" title="1.5.2总线通信控制"></a>1.5.2总线通信控制</h5><p>目的：解决通信双方协调配合问题</p><p>总线传输周期：</p><ul><li>中请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者。</li><li>寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与木次传输的从模块。</li><li>传数阶段：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流人目的模块。</li><li>结束阶段：主模块的有关信息均从系统总线上撒除，让出总线使用权。</li></ul><p>总线通信的四种方式：</p><ul><li>同步通信：有统一时标控制数据传送</li><li>异步通信：采用应答方式，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统 总线每个瞬间的潜力</li></ul><p>某个输入设备向CPU传输数据的同步通信（同步式数据输入传输）</p><p>对于读命令，其传输周期如下：</p><ul><li>T1:主模块发地址。</li><li>T2:主模块发读命令。</li><li>T3:从模块提供数据。</li><li>T4:主模块撤销读命令，从模央撤销数据。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111244151.png" class="" title="image-20230828111244151"><p>图中总线传输周期是连接在总线上的两个部件完成一次完整且可靠的信息传输时间，它包<br>含4个时钟周期T1、T2、T3、T4。<br>        CPU在T1上升沿发出地址信息；在T2的上升沿发出读命令；与地址信号相符合的输入设备<br>按命令进行一系列内部操作，且必须在T3的上升沿到来之前将CPU所需的数据送到数据总线<br>上：CPU在T3时钟周期内，将数据线上的信息送到其内部寄存器中；CPU在T4的上升沿撤销读<br>命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。如果总线采用三态驱动<br>电路，则从T4起，数据总线呈浮空状态。</p><p>同步式数据输出传输</p><p>对于写命令，其传输周期如下：</p><ul><li>T1:主模块发地址</li><li>T1.5：主模块提供数据。</li><li>T2：主模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到<br>地址总线所指明的单元中。</li><li>T4：主模块撤销写命令和数据等信号。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111309016.png" class="" title="image-20230828111309016"><p>这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性“同步”，必须在限定时问内完成规定的要求。并对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而市，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏贝活性。</p><p>同步通信一般用于总线长度较短、各部件存取时问比较一致的场合。</p><p>在同步通信的总线系统中，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率。</p><p>异步通信</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111331035.png" class="" title="image-20230828111331035"><p>1、不互锁方式</p><p>主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块<br>已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并<br>且经过一段时问（这段时问的设置对不同设备而言是不同的）确认主模块已收到回答信号后，自<br>动撤销回答信号。可见通信双方并无互锁关系。例如，CPU向主存写信息，CPU要先后给出地<br>址信号、写命令以及写入数据，即采用此种方式。</p><p>2、半互锁方式</p><p>主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系：而<br>从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一<br>段时间后自动撒销其回答信号，无互锁关系。由于一方存在互锁关系，一方不存在互锁关系，故<br>称半互锁方式。例如，在多机系统中，某个CPU需访问共享存储器（供所有CPU访问的存储器）<br>时，该CPU发出访存命令后，必须收到存储器未被占用的回答信号，才能真正进行访存操作。</p><p>3、全互锁</p><p>主模块发出请求信号，必须待从模块回答后再撤销其请求信号；从模块发出回答信号，必须<br>待获知主模块请求信号已撤销后，再撤销其回答信号。双方存在互锁关系，故称为全互锁方式。<br>例如，在网络通信中，通信双方采用的就是全互锁方式。</p><p>半同步通信（同步、异步结合）</p><ul><li>同步:发送方用系统 时钟前沿 发信号；接收方用系统 时钟后沿 判断、识别</li><li>异步：允许不同速度的模块和谐工作，增加一条 “等待”响应信号 WAIT</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828112117228.png" class="" title="image-20230828112117228"><p>以输入数据为例的半通信时序</p><ul><li><p>T1:主模块发出地址信息</p></li><li><p>T2：主模块发出命令</p></li><li><p>T2当WAIT为低电平时，进入等待，Tw的宽度与T的宽度一致。</p></li><li></li><li></li><li></li><li><p>T3:从模块提供数据。</p></li><li><p>T4:主模块撤销读命令，从模块撤销数据。</p></li></ul><p>上述三种通信的共同电：</p><ul><li>主模块发地址、命令占用总线</li><li>从模块准备数据        不占用总线  总线空闲</li><li>从模块向主模块发数据     占用总线</li></ul><p>分离式通信</p><p>以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结束。在整个传输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期，发现除了中请总线这一阶段外，其余时间主要花费在如下3个方面。<br>①主模块通过传输总线向从模块发送地址和命令。<br>②从模块按照命令进行读数据的必要淮备。<br>③从模块经数据总线向主模块提供数据。·<br>由②可见，对系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待，为了克服和利用这种消极等待，尤其在大型计算机系统中，总线的负载已处于饱和状态，充分挖掘系统总线每瞬间的潜力，对提高系统性能起到极大作用。为此人们又提出了“分离式”的通信方式，其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第一个子周期中，主模块A在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号（当有多个主模块时，此编号尤为重要)发到系统总线上，经总线传输后，由有关的从模块B接收下来。主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使州权，以便其他模块使用。在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将A模块所需的数据准备好，使出B模块中请总线使用权，一旦获谁，B模块便将A模块的编号、B模块的地址、A模块所器的数据等一系列信息送到总线上，供A模块接收。很明显，上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。</p><p>分离式通信特点：</p><ul><li>各模块欲占用总线使用权都必须提出申请。</li><li>在得到总线使用权后，主模块在限定的刷间内向对方传送信总，采用同步方式传送，不再等待对方的回答信号。</li><li>各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。</li><li>总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概论(一)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍计算机的组成概貌及工作原理，旨在使读者对计算机总体结构有一个概括的<br>了解，为深入学习后面各章打下基础。</p><span id="more"></span><h4 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h4><h5 id="1-1-1-计算机的软硬件概念"><a href="#1-1-1-计算机的软硬件概念" class="headerlink" title="1.1.1 计算机的软硬件概念"></a>1.1.1 计算机的软硬件概念</h5><p><strong>计算机系统有“硬件”和“软件”两大部分组成。</strong></p><p>​<strong>硬件</strong>：计算机的实体，如主机、外设等</p><p>​<strong>软件</strong>：由具有各类特殊的功能的信息（程序）组成</p><p>软件可以分为</p><p>​<strong>系统软件</strong>：用来管理整个计算机系统 。如 语言处理程序、操作系统、服务型程序、数据库管理系统、网络软件</p><p>​<strong>应用软件</strong>：按任务需要编制成的各种程序</p><h5 id="1-1-2-计算机系统的成层次结构"><a href="#1-1-2-计算机系统的成层次结构" class="headerlink" title="1.1.2 计算机系统的成层次结构"></a>1.1.2 计算机系统的成层次结构</h5><p><strong>方向：M4→M3→M2→M1→M0</strong></p><p>虚拟机器M4(高级语言机器)用编译程序翻译成汇编语言程序</p><p>虚拟机器M3(汇编语言机器)用汇编程序翻译成机器语言程序</p><p>虚拟机器M2(操作系统机器)用机器语言解释操作系统</p><p>传统机器M1(机器语言机器)用微程序解释机器指令</p><p>微程序机器M0(微指令系统)有硬件直接执行微指令</p><h5 id="1-1-3计算机组成和计算机体系结构"><a href="#1-1-3计算机组成和计算机体系结构" class="headerlink" title="1.1.3计算机组成和计算机体系结构"></a>1.1.3计算机组成和计算机体系结构</h5><p><strong>计算机体系结构</strong>：是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。计算机系统的属性通常是指用机器语言编程的程序员所能看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术、I&#x2F;O机理等，大都属于抽象概念</p><p><strong>计算机组成</strong>：是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。例如，指令系统体现了机器的属性，这属于<em>计算机结构</em>的问题。但是指令的实现，即如何取出指令，分析指令，取操作数、运算、送结果等，这些属于<em>计算机组成问题</em></p><h4 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h4><h5 id="1-2-1冯·诺伊曼计算机的特点"><a href="#1-2-1冯·诺伊曼计算机的特点" class="headerlink" title="1.2.1冯·诺伊曼计算机的特点"></a>1.2.1冯·诺伊曼计算机的特点</h5><ul><li>计算机有运算器、存储器、控制器、输入设备、输出设备五大部件组成</li><li>指令和数据以同等的地位存放与存储器内，并可按地址访问</li><li>指令和数据均用二进制数表示</li><li>指令有操作码和地址码组成，操作码可以用来表示操作的性质，地址码可以用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定的条件下，可以根据运算结果或根据设定的条件改变执行的顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ul><h5 id="1-2-2计算机的硬件框图"><a href="#1-2-2计算机的硬件框图" class="headerlink" title="1.2.2计算机的硬件框图"></a>1.2.2计算机的硬件框图</h5><p>典型的冯·诺伊曼计算机解构框图</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201047407.png" class="" title="image-20230827201047407"><p>图中各部件的功能如下：</p><ul><li>运算器用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内</li><li>存储器用来存放数据指令和程序</li><li>控制器用来控制、指挥程序和数据的输入、运行及处理运算结果</li><li>输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有鼠标、键盘等</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等</li></ul><p>由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往集成在同一个芯片上，因此，通常将他们合起来称作中央处理器（Central Processing Unit,CPU）。把输入输出设备简称为I&#x2F;O设备（Input&#x2F;Output Equipment）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201352277.png" class=""><p>主存储器是存储器子系统中的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类成为辅助存储器，简称辅存，又称外存。</p><p>算数逻辑单元（Arithmetic Logic Unit,ALU）简称算逻部件，用来完成算术逻辑运算。</p><p>控制单元（Control Unit ,CU）用来解释存储器中的指令，并发出各种操作命令来执行指令。</p><p>ALU和CU是CPU的核心</p><p>I&#x2F;O设备也受CU控制，用来完成相对应的输入和输出操作</p><h5 id="1-2-3计算机的工作步骤"><a href="#1-2-3计算机的工作步骤" class="headerlink" title="1.2.3计算机的工作步骤"></a>1.2.3计算机的工作步骤</h5><p>用计算机解决问题有两大步骤。一是上机前的准备，另一个是上机运行</p><h6 id="上机前的准备"><a href="#上机前的准备" class="headerlink" title="上机前的准备"></a>上机前的准备</h6><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h6 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202137512.png" class="" title="image-20230827202137512"><h6 id="存储器的基本组成："><a href="#存储器的基本组成：" class="headerlink" title="存储器的基本组成："></a>存储器的基本组成：</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201750247.png" class=""><p>主存储器包括存储体、各种逻辑部件及控制电路，存储体由很多存储单元组成，每个存储单元又包括若干个存储元件，每个存储元件存放一个二进制代码“0”和“1”。一个存储单元可以储存一串二进制代码，称这串二进制代码为一个存储字，这串二进制代码的位数成为存储字长。</p><ol><li>存储单元:存放一串二进制代码</li><li>存储字:存储单元中二进制代码的组合</li><li>存储字长:存储单元中二进制代码的位数 每个存储单元赋予一个地址号</li></ol><p>为了实现按地址访问的形式，主存中还得必须配置两个寄存器MAR和MDR</p><ol><li>MAR:存储器地址寄存器，反映存储单元的个数</li><li>MDR:存储器数据寄存器，反映存储字节长度</li></ol><p>设RAM&#x3D;4 位  MDR&#x3D;8位则 存储单元个数位16个，存储字长为8</p><h6 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h6><p>运算器最少包括三个寄存器和一个算数逻辑单元（ALU）其中ACC是累加器，MQ为乘商寄存器，X为操作数寄存器</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202644280.png" class="" title="image-20230827202644280"><p>M表示存储器的任意地址号，[M]表示对应M地址单元中的内容；X表示X寄存器,[X]表示X寄存器的内容；ACC表示累加器，[ACC]表示累加器中的内容；MQ表示乘商寄存器，[MQ]表示乘商寄存器中的内容</p><p>加法操作过程</p><p>假设ACC已经有前一时刻的运算运算结果，并作为下述运算中的一个操作数</p><p>即将[ACC]中看作被加数，先从主存中取一个存放在M地址号单元的加数[M]，送至运算器的X寄存器中，然后将被加数[ACC]与加数[X]相加，结果(和)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202827546.png" class="" title="image-20230827202827546"><p>减法操作过程</p><p>即将[ACC]中看作被减数，先从主存中取一个存放在M地址号单元的减数[M]，送至运算器的X寄存器中，然后将[ACC]-[X]，结果(差)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202846884.png" class="" title="image-20230827202846884"><p>乘法操作过程</p><p>即将[ACC]看作被乘数，先取出存放在主存M号地址单元中的乘数[M]并送入乘商寄存器MQ,在把被乘数送入X寄存器，并将ACC清“0”,然后[X]和[MQ]相乘，结果（积）的高位保留在ACC中，地位保留MQ中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202907215.png" class="" title="image-20230827202907215"><p>除法操作过程</p><p>即将[ACC]看作被除数，先取出存放在M地址单元内的除数[M]并送至X寄存器，然后[ACC]除以[X]，结果（商）暂留与MQ,[ACC]为余数R。若需要将商保留在ACC中，只需要做一步[MQ]→ACC即可</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202931819.png" class="" title="image-20230827202931819"><p>控制器</p><p>控制器由程序计数器（Program Counter,PC）、指令寄存器（Instruction Register,IR）以及控制单元（CU）组成</p><p>PC：用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路且具有自动加1的功能，即可自动形成下一条指令的地址。</p><p>IR:用来存放当前的指令，IR的内来自主存的MDR。IR中的操作码（OP(IR)）送至CU,记作OP(IR)→CU,用来分析指令；其地址码（Ad(IR)）作为操作数的地址送至存储器的MAR,记作Ad(IR)→MAR。</p><p>CU：用来分析当前的指令所需完成的操作，并发出各种微操作命令序号，用以控制所有被控制对象</p><p>完成一条指令需要三个步骤：取指令、分析指令、执行指令</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203029187.png" class="" title="image-20230827203029187"><p>主机完成一条指令的过程</p><p>取指数为例</p><ol><li><p>PC把指令送给MAR</p></li><li><p>MAR把指令送给存储体</p></li><li><p>在控制器的控制下，把存储体指定存储单元中的那条取数指令取出，并送入MDR中</p></li><li><p>将取出的指令送入IR中</p><hr></li><li><p>把IR的操作码送入CU</p></li><li><p>CU经过译码后，在控制器的控制下，把指令中的地址部分送给存储器，以便数据从存储体中取出</p></li><li><p>MAR将地址送给存储体</p></li><li><p>在控制器的控制之下，把存储体中我们需要取的数送至MDR中</p></li><li><p>然后将MDR的数据送入ACC</p></li></ol><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203302609.png" class="" title="image-20230827203302609"><p>例子：</p><p>首先按下图的有序指令和数据，通过键盘输入到主从第0号至第12号单元中，并置PC的初始值为0（令程序的首选地址为0）。启动机器后，计算机便自动按存储器中所存放的指令顺序有序地逐条完成取指令、分析指令、和执行指令，直至最后一条指令为止。</p><p>例如</p><ul><li>PC→MAR,并命令存储器做读操作，此时0号单元中的内容”0000010000001000”,便被送入到MDR内</li><li>MDR→IR,完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000001”为取数指令</li><li>于是CU将IR中的地址码“0000001000”送至MAR(记作Ad(IR)→MAR),并命令存储器做只读操作</li><li>将地址单元的操作数X送至MDR</li><li>再由MDR中送至ACC中，完成指令的执行过程，此时完成第一条取数指令的全过程，即操作数在X送至运算器ACC中</li><li>PC完成自动加1操作，形成下一条指令的地址“1”</li><li>PC将第二条指令送入MAR中，命令主存储器做只读操作，将“0001000000001001”送入MDR中</li><li>MDR→IR，完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000100”为乘法指令</li><li>CU向存储体发出读命令，取出对应地址为“0000001001”单元的操作数a</li><li>a经MDR送至运算器MQ</li><li>CU在向运算器发送乘法操作命令，完成ax的运算，并把结果ax存放在ACC中</li><li>PC+1→PC,形成下一条指令的地址“2”号</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203825422.png" class="" title="image-20230827203825422">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
