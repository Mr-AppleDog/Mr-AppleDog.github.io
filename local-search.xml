<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>输入输出系统（四）</title>
    <link href="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/"/>
    <url>/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>除了CPU和存储器两大模块外，计算机硬件系统的第三个关键部分是输入输出模块，又称输入输出系统。随着计算机系统的不断发展，应用范围的不断扩大，I&#x2F;O设备的数量和种类也越来越多，它们与主机的联络方式及信息的交换方式也各不相同。</p><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h4><p>输入输出系统的发展大致可分为4个阶段。</p><p>1、早期</p><p>早期的I&#x2F;O设备种类较少，I&#x2F;O设备与主存交换信息都必须通过CPU</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165053240.png" class="" title="image-20230919165053240"><p>这种交换方式延续了相当长的时间。当时的&#x2F;O设备具有以下几个特点：</p><ul><li>每个I&#x2F;0设备都必须配有一套独立的逻辑电路与CPU相连，用来实现I&#x2F;0设备与主机之<br>间的信息交换，因此线路十分散乱、庞杂。</li><li>输入输出过程是穿插在CPU执行程序过程之中进行的，当I&#x2F;O设备与主机交换信息时，<br>CPU不得不停止各种运算，因此，&#x2F;O设备与CPU是按串行方式工作的，极浪费时间。</li><li>每个I&#x2F;O设备的逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，它们彼<br>此依赖，相互牵连，因此，欲增添、撤减或更换&#x2F;0设备是非常困难的。</li></ul><p>2、接口模块和DMA阶段</p><p>这个阶段&#x2F;O设备通过接口模块与主机连接，计算机系统采用了总线结构</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165303547.png" class="" title="image-20230919165303547"><p>通常，在接口中都设有数据通路和控制通路。数据经过接口既起到缓冲作用，又可完成串一并变换。控制通路用以传送CPU向I&#x2F;O设备发出的各种控制命令，或使CPU接受来自I&#x2F;O设备的反馈信号。许多接口还能满足中断请求处理的要求，使I&#x2F;O设备与CPU可按并行方式工作，大大地提高了CPU的工作效率。采用接口技术还可以使多台I&#x2F;O设备分时占用总线，使多台I&#x2F;0设备互相之间也可实现并行工作方式，有利于整机工作效率的提高。虽然这个阶段实现了CPU和I&#x2F;O设备并行工作，但是在主机与I&#x2F;O设备交换信息时，CPU要中断现行程序，即CPU与I&#x2F;0设备还不能做到绝对的并行工作。为了进一步提高CPU的工作效率，又出现了直接存储器存取(Direct Memory Access,DMA)技术，其特点是I&#x2F;O设备与主存之间有一条直接数据通路，I&#x2F;O设备可以与主存直接交换信息，使CPU在I&#x2F;O设备与主存交换信息时能继续完成自身的工作，故资源利用率得到了进一步提高。</p><p>3、具有通道结构的阶段</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165518859.png" class="" title="image-20230919165518859"><p>在小型和微型计算机中，采用DMA方式可实现高速I&#x2F;O设备与主机之间成组数据的交换，但在大中型计算机中，I&#x2F;O设备配置繁多，数据传送频繁，若仍采用DMA方式会出现一系列问题。</p><ul><li>如果每台1&#x2F;0设备都配置专用的DMA接口，不仅增加了硬件成本，而且为了解决众多DMA接口同时访问主存的冲突问题，会使控制变得十分复杂。</li><li>CPU需要对众多的DMA接口进行管理，同样会占用CPU的工作时间，而且因频繁地进入周期挪用阶段，也会直接影响CPU的整体工作效率</li></ul><p>因此在大中型计算机系统中，采用&#x2F;0通道的方式来进行数据交换。</p><p>通道是用来负责管理I&#x2F;O设备以及实现主存与I&#x2F;O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器。通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，但不是一个完全独立的处理器。它依据CPU的&#x2F;0指令进行启动、停业或改变工作状态，是从属于CPU的一个专用处理器。依赖通道管理的I&#x2F;O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。</p><p>4、具有I&#x2F;O处理机的阶段</p><p>输入输出系统发展到第四阶段，出现了I&#x2F;O处理机。L&#x2F;O处理机又称为外围处理机(Pr-ipheral Processor),它基本独立于主机工作，既可完成&#x2F;O通道要完成的&#x2F;0控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。具有&#x2F;0处理机的输入输出系统与CPU工作的并行性更高，这说明&#x2F;O系统对主机来说具有更大的独立性。</p><h4 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h4><h5 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I&#x2F;O软件"></a>I&#x2F;O软件</h5><p>I&#x2F;O指令是机器指令的一类I&#x2F;O指令的一般格式：</p><table><thead><tr><th>操作码</th><th>命令码</th><th>设备码</th></tr></thead></table><p>通道指令</p><p>通道指令是对具有通道的I&#x2F;O系统专门设置的指令，这类指令一般用以指明参与传送（写人或读取)的数据组在<strong>主存中的首地址</strong>；指明需要传送的字节数或所传送数据组的<strong>末地址</strong>；指明所选设备的设备码及完成某种操作的<strong>命令码</strong>。这类指令的位数一般较长，如BM370机的通道指令为64位。</p><h5 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I&#x2F;O硬件"></a>I&#x2F;O硬件</h5><p>设备I&#x2F;O接口</p><p>设备设备控制器通道</p><h4 id="I-O设备与主机的联系方式"><a href="#I-O设备与主机的联系方式" class="headerlink" title="I&#x2F;O设备与主机的联系方式"></a>I&#x2F;O设备与主机的联系方式</h4><h6 id="I-O设备编制方式"><a href="#I-O设备编制方式" class="headerlink" title="I&#x2F;O设备编制方式"></a>I&#x2F;O设备编制方式</h6><p>通常将I&#x2F;O设备码看做地址码，对I&#x2F;O地址码的编址可采用两种方式：</p><ul><li>统一编址</li></ul><p>统一编址就是将&#x2F;0地址看做是存储器地址的例如，在64K地址的存储空间中，划出8K地址作为I&#x2F;O设备的地址，凡是在这8K地址范围内的访问，就是对I&#x2F;O设备的访问，所用的指令与访存指令相似。</p><ul><li>不统一编址</li></ul><p>不统一编址就是指I&#x2F;O地址和存储器地址是分开的，所有对&#x2F;IO设备的访问必须有专用的I&#x2F;0指令。显然统一编址占用了存储空间，减少了主存容量，但无须专用的I&#x2F;O指令。不统一编址由于不占用主存空间，故不影响主存容量，但需设I&#x2F;O专用指令。因此，设计机器时，需根据实际情况权衡考虑选取何种编址方式。</p><h6 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h6><p>由于每台设备都赋予一个设备号，因此，当要启动某一设备时，可由I&#x2F;O指令的设备码字段直接指出该设备的设备号。通过接口电路中的设备选择电路，便可选中要交换信息的设备。</p><h6 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h6><ul><li>并行</li><li>串行</li></ul><h6 id="联络方式"><a href="#联络方式" class="headerlink" title="联络方式"></a>联络方式</h6><ul><li>立即响应</li></ul><p>对于一些工作速度十分缓馒的I&#x2F;O设备，如指示灯的亮与灭、开关的通与断、A&#x2F;D转换器缓变信号的输入等，当它们与CPU发生联系时，通常都已使其处于某种等待状态，因此，只要CPU的I&#x2F;0指令一到，它们便立即响应，故这种设备无须特殊联络信号，称为立即响应方式。</p><ul><li>异步工作采用应答信号联络</li></ul><p>当I&#x2F;O设备与主机工作速度不匹配时，通常采用异步工作方式。这种方式在交换信息前，I&#x2F;O设备与CPU各自完成自身的任务，一旦出现联络信号，彼此才准备交换信息。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920133546602.png" class="" title="image-20230920133546602"><ul><li>同步工作采用同步时标联络</li></ul><p>同步工作要求I&#x2F;O设备与CPU的工作速度完全同步。例如，在数据采集过程中，若外部数据以2400bPs的速率传送至接口，则CPU也必须以1&#x2F;2400s的速率接收每一位数。这种联络互相之间还得配有专用电路，用以产生同步时标来控制同步工作。</p><h6 id="I-O设备与主机的连接方式"><a href="#I-O设备与主机的连接方式" class="headerlink" title="I&#x2F;O设备与主机的连接方式"></a>I&#x2F;O设备与主机的连接方式</h6><ul><li>辐射式</li></ul><p>每台设备都配有一套控制线路和一组信号线,不便于增删设备</p><ul><li>总线式</li></ul><p>便于增删设备</p><h4 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I&#x2F;O设备与主机信息传送的控制方式"></a>I&#x2F;O设备与主机信息传送的控制方式</h4><p>I&#x2F;0设备与主机交换信息时，共有5种控制方式：程序查询方式、程序中断方式、直接存储器存取方式(DMA)、I&#x2F;0通道方式、I&#x2F;0处理机方式。</p><h6 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h6><p>程序查询方式是由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。采用这种方式实现主机和I&#x2F;O设备交换信息，要求I&#x2F;O接口内设置一个能反映I&#x2F;O设备是否准备就绪的状态标记，CPU通过对此标记的检测，可得知I&#x2F;O设备的准备情况。</p><p>当现行程序需启动某I&#x2F;O设备工作时，即将此程序流程插入到运行的程序中。由图中可知，CPU启动I&#x2F;O设备后便开始对I&#x2F;O设备的状态进行查询。若查得I&#x2F;O设备未准备就绪，就继续查询；若查得I&#x2F;O设备准备就绪，就将数据从I&#x2F;O接口送至CPU,再由CPU送至主存。这样一个字一个字地传送，直至这个数据块的数据全部传送结束，CPU又重新回到原现行程序。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134310369.png" class="" title="image-20230920134310369"><p>由这个查询过程可见，只要一启动I&#x2F;O设备，CPU便不断查询I&#x2F;O设备的准备情况，从而终止了原程序的执行。CPU在反复查询过程中，犹如就地“踏步”。另一方面，I&#x2F;O设备准备就绪后，CPU要一个字一个字地从I&#x2F;O设备取出，经CPU送至主存，此刻CPU也不能执行原程序，可见这种方式使CPU和I&#x2F;O设备处于串行工作状态，CPU的工作效率不高。</p><h6 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h6><p>徜若CPU在启动I&#x2F;O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I&#x2F;O设备推备就绪并向CPU发出中断请求后才予以响应，这将大大提高CPU的工作效率。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134745159.png" class="" title="image-20230920134745159"><p>由图中可见，CPU启动I&#x2F;O设备后仍继续执行原程序，在第K条指令执行结束后，CPU响应了I&#x2F;O设备的请求，中断了现行程序，转至中断服务程序，待处理完后又返回到原程序断点处，继续从第K+1条指令往下执行。由于这种方式使原程序中断了运行，故称为程序中断方式。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134903603.png" class="" title="image-20230920134903603"><h6 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h6><p>虽然程序中断方式消除了程序查询方式的“踏步”现象，提高了CPU资源的利用率，但是CPU在响应中断请求后，必须停止现行程序而转入中断服务程序，并且为了完成I&#x2F;O设备与主存交换信息，还不得不占用CPU内部的一些寄存器，这同样是对CPU资源的消耗。如果I&#x2F;O设备能直接与主存交换信息而不占用CPU,那么，CPU的资源利用率显然又可进一步提高，这就出现了直接存储器存取(DMA)的方式。</p><p>在DMA方式中，主存与&#x2F;O设备之间有一条数据通路，主存与I&#x2F;0设备交换信息时，无须调用中断服务程序。若出现DMA和CPU同时访问主存，CPU总是将总线占有权让给DMA,通常把DMA的这种占有称为窃取或挪用。窃取的时间一般为一个存取周期，故又把DMA占用的存取周期窃取周期或挪用周期。而且，在DMA窃取存取周期时，CPU尚能继续作内部操作（如乘法运算）。可见，与程序查询和程序中断方式相比，DMA方式进一步提高了CPU的资源利用率。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920135237074.png" class="" title="image-20230920135237074"><h6 id="三种方式的-CPU-工作效率比较"><a href="#三种方式的-CPU-工作效率比较" class="headerlink" title="三种方式的 CPU 工作效率比较"></a>三种方式的 CPU 工作效率比较</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920135309902.png" class="" title="image-20230920135309902"><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>中央处理器和主存构成了主机，除主机外的大部分硬件设备都可称为&#x2F;0设备或外部设备，或外围设备，简称外设,I&#x2F;O设备的组成通常可用图画线框内的结构来描述。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920185042630.png" class="" title="image-20230920185042630"><p>I&#x2F;O设备大致可分为三类:</p><ul><li>人机交互设备键盘、鼠标、打印机、显示器</li><li>计算机信息存储设备磁盘、光盘、磁带</li><li>机—-机通信设备调制解调器等</li></ul><h6 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h6><ul><li>键盘</li></ul><ol><li>按下一个键。</li><li>查出按下的是哪个键。</li><li>将此键翻译成ASCII码,由计算机接收。</li></ol><ul><li>鼠标</li><li>触摸屏</li></ul><h6 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h6><ul><li>显示器</li></ul><ol><li>字符显示——字符发生器</li><li>图形显示——主观图像</li><li>图像显示——客观图像</li></ol><ul><li>打印机</li></ul><ol><li>击打式点——阵式（逐字、逐行）</li><li>非击打式——激光（逐页）喷墨（逐字）</li></ol><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ul><li>A&#x2F;D、D&#x2F;A模拟&#x2F;数字（数字模拟）转换器</li><li>终端 由键盘和显示器组成完成显示控制与存储、键盘管理及通信控制</li><li>汉字处理汉字输入、汉字存储、汉字输出</li></ul><h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>接口可以看做是两个系统或两个部件之间的交接部分，它既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界I&#x2F;O接口通常是指主机与I&#x2F;O设备之间设置的一个硬件电路及其相应的软件控制。不同的I&#x2F;O设备都有其相应的设备控制器，而它们往往都是通过I&#x2F;O接口与主机取得联系的。主机与i?o设备之间设置接口的理由如下：</p><ul><li>一台机器通常配有多台I&#x2F;O设备，它们各自有其设备号（地址），通过接口可实现I&#x2F;O设备的选择。</li><li>I&#x2F;O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲，达到速度匹配。</li><li>有些I&#x2F;O设备可能串行传送数据，而CPU一般为并行传送，通过接口可实现数据串~并格式的转换。</li><li>I&#x2F;O设备的输人输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换。</li><li>CPU启动I&#x2F;O设备工作，要向I&#x2F;O设备发各种控制信号，通过接口可传送控制命令。</li><li>I&#x2F;O设备需将其工作状态（如“忙”、“就绪”、“错误”、“中断请求”等）及时向CPU报告</li></ul><p>通过接口可监视设备的工作状态，并可保存状态信息，供CPU查询。值得注意的是，接口(Interface)和端口(Port)是两个不同的概念。端口是指接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑才能组成接口。CPU通过输人指令，从端口读人信息，通过输出指令，可将信息写人到端口中。</p><h4 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h4><h5 id="按总线的连接方式的I-O接口方式"><a href="#按总线的连接方式的I-O接口方式" class="headerlink" title="按总线的连接方式的I&#x2F;O接口方式"></a>按总线的连接方式的I&#x2F;O接口方式</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921133011814.png" class="" title="image-20230921133011814"><ul><li>数据线</li></ul><p>数据线是I&#x2F;O设备与主机之间数据代码的传送线，其根数一般等于存储字长的位数或字符的位数，它通常是双向的，也可以是单向的。若采用单向数据总线，则必须用两组才能实现数据的输人和输出功能，而双向数据总线只需一组即可。</p><ul><li>设备选择线</li></ul><p>设备选择线是用来传送设备码的，它的根数取决于I&#x2F;O指令中设备码的位数。如果把设备码看做是地址号，那么设备选择线又可称为地址线。设备选择线可以有一组，也可以有两组，其中一组用于主机向I&#x2F;O设备发送设备码，另一组用于I&#x2F;O设备向主机回送设备码。当然设备选择线也可采用一组双向总线代替两组单向总线。</p><ul><li>命令线</li></ul><p>命令线主要用以传输CPU向设备发出的各种命令信号，如启动、清除、屏蔽、读、写等。它是一组单向总线，其根数与命令信号多少有关。</p><ul><li>状态线</li></ul><p>状态线是将I&#x2F;O设备的状态向主机报告的信号线，例如，设备是否准备就绪，是否向CPU.发出中断请求等。它也是一组单向总线。</p><h5 id="接口的的功能和组成"><a href="#接口的的功能和组成" class="headerlink" title="接口的的功能和组成"></a>接口的的功能和组成</h5><ul><li>选址功能</li></ul><p>由于I&#x2F;O总线与所有设备的接口电路相连，但CPU究竟选择哪台设备，还得通过设备选择线上的设备码来确定。该设备码将送至所有设备的接口，因此，要求每个接口都必须具有选址功能，即当设备选择线上的设备码与本设备码相符时，应发出设备选中信号SEL,这种功能可通过接口内的设备选择电路来实现。</p><ul><li>传送命令的功能</li></ul><p>当CPU向I&#x2F;0设备发出命令时，要求I&#x2F;O设备能做出响应，如果I&#x2F;O接口不具备传送命令信息的功能，那么设备将无法响应，故通常在I&#x2F;O接口中设有存放命令的命令寄存器以及命令译码器</p><ul><li>传送数据的功能</li></ul><p>既然接口处于主机与I&#x2F;O设备之间，因此数据必须通过接口才能实现主机与I&#x2F;O设备之间的传送。这就要求接口中具有数据通路，完成数据传送。这种数据通路还应具有缓冲能力，即能将数据暂存在接口内。接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR),它用来暂存I&#x2F;O设备与主机准备交换的信息，与I&#x2F;O总线中的数据线是相连的。</p><ul><li>反映设备状态的功能</li></ul><p>为了使CPU能及时了解各I&#x2F;O设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。例如，用完成触发器D和工作触发器B来标志设备所处的状态。</p><ol><li>当D&#x3D;0,B&#x3D;0时，表示I&#x2F;O设备处于暂停状态。</li><li>当D&#x3D;1,B&#x3D;0时，表示I&#x2F;O设备已经准备就绪。</li><li>当D&#x3D;0,B&#x3D;1时，表示I&#x2F;O设备正处于准备状态。</li></ol><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921134020211.png" class="" title="image-20230921134020211"><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><ol><li>按数据传送方式分类</li></ol><ul><li>并行接口Intel 8255</li><li>串行接口Intel 8251</li></ul><p>​2.按功能选择的灵活性分类</p><ul><li>可编程接口Intel8255、Intel 8251</li><li>不可编程接口Intel8212</li></ul><p>​3.按通用性分类</p><ul><li>通用接口Intel8255、Intel 8251</li><li>专用接口Intel8279、Intel 8275</li></ul><p>​4.按数据传送的控制方式分类</p><ul><li>中断接口Intel 8259</li><li>DMA接口Intel 8257</li></ul><h3 id="程序查询方式-1"><a href="#程序查询方式-1" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921135908938.png" class="" title="image-20230921135908938"><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921135932696.png" class="" title="image-20230921135932696"><p>当I&#x2F;O设备较多时，CPU需按各个I&#x2F;O设备在系统中的优先级别进行遂级查询，其流程图所示。图中设备的优先顺序按1至N降序排列。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921175143457.png" class="" title="image-20230921175143457"><ol><li>由于这种方式传送数据时要占用CPU中的寄存器，故首先需将寄存器原内容保护起来(若该寄存器中存有用信息)。</li><li>由于传送往往是一批数据，因此需先设置I&#x2F;O设备与主机交换数据的计数值。</li><li>设置欲传送数据在主存缓冲区的首地址。</li><li>CPU启动I&#x2F;O设备。</li><li>将I&#x2F;O接口中的设备状态标志取至CPU并测试I&#x2F;O设备是否准备就绪。如果未准备就绪，则等待，直到准备就绪为止。当准备就绪时，接着可实现传送。对输入而言，准备就绪意味着接口电路中的数据缓冲寄存器已装满欲传送的数据，称为输入缓冲满，CPU即可取走数据；对输出而言，准备就绪意味着接口电路中的数据已被设备取走，故称为输出缓冲空，这样CPU可再次将数据送到接口，设备可再次从接口接收数据。</li><li>CPU执行I&#x2F;O指令，或从I&#x2F;O接口的数据缓冲寄存器中读出一个数据，或把一个数据写入I&#x2F;O接口中的数据缓冲寄存器内，同时将接口中的状态标志复位。</li><li>修改主存地址。</li><li>修改计数值，若原设置计数值为原码，则依次减1；若原设置计数值为负数的补码，则依次加1（有关原码、补码的）。</li><li>判断计数值。若计数值不为0，表示一批数据尚未传送完，重新启动外设继续传送；若计数值为0，则表示一批数据已传送完毕。</li><li>结束I&#x2F;O传送，继续执行现行程序。</li></ol><h4 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h4><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921175621004.png" class="" title="image-20230921175621004"><p>图中设备选择电路用以识别本设备地址，当地址线上的设备号与本设备号相符时，SEL有效，可以接收命令；数据缓冲寄存器用于存放欲传送的数据；D是完成触发器，B是工作触发器。以输入设备为例，该接口的工作过程如下：</p><ol><li>当CPU通过1&#x2F;O指令启动输人设备时，指令的设备码字段通过地址线送至设备选择电路。</li><li>若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</li><li>I&#x2F;O指令的启动命令经过“与非”门将工作触发器B置“1”，将完成触发器D置“0”。</li><li>由B触发器启动设备工作。</li><li>输人设备将数据送至数据缓冲寄存器。</li><li>由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。</li><li>D触发器以“准备就绪”状态通知CPU,表示“数据缓冲满”。</li><li>CPU执行输人指令，将数据缓冲寄存器中的数据送至CPU的通用寄存器，再存人主存相关单元。</li></ol><h3 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p>计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断”。中断是现代计算机能有效合理地发挥效能和提高效率的一个十分重要的功能。通常又把实现这种功能所需的软硬件技术统称为中断技术。</p><h4 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I&#x2F;O中断的产生"></a>I&#x2F;O中断的产生</h4><p>在I&#x2F;O设备与主机交换信息时，由于设备本身机电特性的影响，其工作速度较低，与CPU无法匹配，因此，CPU启动设备后，往往需要等待一段时间才能实现主机与I&#x2F;O设备之间的信息交换。如果在设备准备的同时，CPU不作无谓的等待，而继续执行现行程序，只有当I&#x2F;O设备准备就绪向CPU提出请求后，再暂时中断CPU现行程序转人I&#x2F;O服务程序，这便产生了I&#x2F;O中断。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921185718159.png" class="" title="image-20230921185718159"><h4 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h4><h5 id="中断请求触发器和中断屏蔽触发器"><a href="#中断请求触发器和中断屏蔽触发器" class="headerlink" title="中断请求触发器和中断屏蔽触发器"></a>中断请求触发器和中断屏蔽触发器</h5><p>每台外部设备都必须配置一个中断请求触发器INTR,当其为“1”时，表示该设备向CPU提出中断请求。但是设备欲提出中断请求时，其设备本身必须准备就绪，即接口内的完成触发器D的状态必须为“1”。</p><p>由于计算机应用的范围越来越广泛，向CPU提出中断请求的原因也越来越多，除了各种I&#x2F;O设备外，还有其他许多突发性事件都是引起中断的因素，为此，把凡能向CPU提出中断请求的各种因素统称为中断源。当多个中断源向CPU提出中断请求时，CPU必须坚持一个原则，即在任何瞬间只能接受一个中断源的请求。所以，当多个中断源同时提出请求时，CPU必须对各中断源的请求进行排队，且只能接受级别最高的中断源的请求，不允许级别低的中断源中断正在运行的中断服务程序。这样，在I&#x2F;O接口中需设置一个屏蔽触发器MASK,当其为“1”时，表示被屏的中断服务程序。这样，在I&#x2F;O接口中需设置一个屏蔽触发器MASK,当其为“1”时，表示被屏蔽，即封锁其中断源的请求。可见中断请求触发器和中断屏蔽触发器在I&#x2F;O接口中是成对出现的。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211335034.png" class="" title="image-20230921211335034"><h5 id="排队器"><a href="#排队器" class="headerlink" title="排队器"></a>排队器</h5><p>如上所述，当多个中断源同时向CPU提出请求时，CPU只能按中断源的不同性质对其排队，给予不同等级的优先权，并按优先等级的高低予以响应。就I&#x2F;O中断而言，速度越高的I&#x2F;O设备，优先级越高</p><p>图下面的一排门电路是链式排队器的核心。每个接口中有一个反相器和一个“与非”门（如图中点画线框内所示），它们之间犹如链条一样串接在一起，故称为链式排队器。该电路中级别最高的中断源是1号，其次是2号、3号、4号。不论是哪个中断源（一个或多个）提出中断请求，排队器输出端INTP只有一个高电平。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211632244.png" class="" title="image-20230921211632244"><h5 id="中断向量地址形成部件（设备编码器）"><a href="#中断向量地址形成部件（设备编码器）" class="headerlink" title="中断向量地址形成部件（设备编码器）"></a>中断向量地址形成部件（设备编码器）</h5><p>CPU一且响应了&#x2F;0中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同的设备有不同的中断服务程序，每个服务程序都有一个人口地址，CPU必须找到这个入口地址。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211847534.png" class="" title="image-20230921211847534"><h4 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I&#x2F;O中断处理过程"></a>I&#x2F;O中断处理过程</h4><h5 id="CPU响应中断的条件和时间"><a href="#CPU响应中断的条件和时间" class="headerlink" title="CPU响应中断的条件和时间"></a>CPU响应中断的条件和时间</h5><p>CPU响应I&#x2F;O设备提出中断请求的条件是必须满足CPU中的允许中断触发器EINT为“1”。该触发器可用开中断指令置位（称为开中断）：也可用关中断指令或硬件自动使其复位（称为关中断)。</p><p>I&#x2F;O设备准备就绪的时间（即D&#x3D;1)是随机的，而CPU是在统一的时刻(每条指令执行阶段结束前)向接口发中断查询信号，以获取&#x2F;0的中断请求。因此，CPU响应中断的时间一定是在每条指令执行阶段的结束时刻。</p><h5 id="I-O处理中断的过程"><a href="#I-O处理中断的过程" class="headerlink" title="I&#x2F;O处理中断的过程"></a>I&#x2F;O处理中断的过程</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921214815629.png" class="" title="image-20230921214815629"><p>下面以输人设备为例，结合图，说明I&#x2F;O中断处理的全过程。当CPU通过I&#x2F;O指令的地址码选中某设备后，则</p><ol><li>由CPU发启动I&#x2F;O设备命令，将接口中的B置“1”，D置“0”。</li><li>接口启动输入设备开始工作。</li><li>输人设备将数据送人数据缓冲寄存器。</li><li>输人设备向接口发出“设备工作结束”信号，将D置“1”，B置“0”，标志设备准备就绪。</li><li>当设备准备就绪(D&#x3D;1),且本设备未被屏蔽(MASK&#x3D;0)时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。</li><li>设备中断请求触发器INTR被置“1”，标志设备向CPU提出中断请求。与此同时，INTR送至排队器，进行中断判优。</li><li>若CPU允许中断(EINT&#x3D;1),设备又被排队选中，即进入中断响应阶段，由中断响应信号NTA将排队器输出送至编码器形成向量地址。</li><li>向量地址送至PC，作为下一条指令的地址。</li><li>由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进人中断服务阶段，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。</li><li>中断服务程序的最后一条指令是中断返回指令，当其执行结束时，即中断返回至原程序的断点处。</li></ol><h4 id="中断服务程序流程"><a href="#中断服务程序流程" class="headerlink" title="中断服务程序流程"></a>中断服务程序流程</h4><h5 id="中断服务的流程"><a href="#中断服务的流程" class="headerlink" title="中断服务的流程"></a>中断服务的流程</h5><p>不同设备的服务程序是不相同的，可它们的程序流程又是类似的，一般中断服务程序的流程分四大部分：保护现场、中断服务、恢复现场和中断返回。</p><ul><li>保护现场</li></ul><p>保护现场有两个含义，其一是保存程序的断点；其二是保存通用寄存器和状态寄存器的内容。前者由中断隐指令完成，后者由中断服务程序完成。具体而言，可在中断服务程序的起始部分安排若干条存数指令，将寄存器的内容存至存储器中保存，或用进栈指令(PUSH)将各寄存器的内容推入堆栈保存，即将程序中断时的“现场”保存起来。</p><ul><li>中断服务</li></ul><p>这是中断服务程序的主体部分，对于不同的中断请求源，其中断服务操作内容是不同的，例如，打印机要求CPU将需打印的一行字符代码，通过接口送入打印机的缓冲存储器中以供打印机打印。又如，显示设备要求CPU将需显示的一屏字符代码通过接口送人显示器的显示存储器中。</p><ul><li>恢复现场</li></ul><p>这是中断服务程序的结尾部分，要求在退出服务程序前，将原程序中断时的“现场”恢复到原来的寄存器中。通常可用取数指令或出栈指令(POP),将保存在存储器（或堆栈）中的信息送回到原来的寄存器中。</p><ul><li>中断返回</li></ul><p>中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p><h5 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h5><ul><li>单重中断 不允许中断现行的中断服务程序</li><li>多重中断 允许级别更高的中断源中断现行的中断服务程序</li></ul><h5 id="单重中断和多重中断的服务程序流程"><a href="#单重中断和多重中断的服务程序流程" class="headerlink" title="单重中断和多重中断的服务程序流程"></a>单重中断和多重中断的服务程序流程</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921215635101.png" class="" title="image-20230921215635101"><p>计算机在处理中断的过程中，有可能出现新的中断请求，此时如果CPU暂停现行的中断服务程序，转去处理新的中断请求，这种现象称为中断嵌套，或多重中断。倘若CPU在执行中断服务程序时，对新的中断请求不予理睬，这种中断称为单重中断。这两种处理方式的中断服务程序路有区别，上图分别为单重中断和多重中断服务程序流程。比较上图可以发现，其区别在于“开中断”的设置时间不同。</p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><h4 id="DMA方式特点"><a href="#DMA方式特点" class="headerlink" title="DMA方式特点"></a>DMA方式特点</h4><h5 id="DMA-和程序中断两种方式的数据通路"><a href="#DMA-和程序中断两种方式的数据通路" class="headerlink" title="DMA 和程序中断两种方式的数据通路"></a>DMA 和程序中断两种方式的数据通路</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926201541917.png" class="" title="image-20230926201541917"><p>由于主存和DMA接口之间有一条数据通路，因此主存和设备交换信息时，不通过CPU,也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高。这一特点特别适合于高速I&#x2F;O或辅存与主存之间的信息交换。因为高速I&#x2F;O设备若每次申请与主机交换信息时，都要等待CPU做出中断响应后再进行，很可能因此使数据丢失。值得注意的是，若出现高速I&#x2F;O(通过DMA接口)和CPU同时访问主存，CPU必须将总线(如地址线、数据线)占有权让给DMA接口使用，即DMA采用周期窃取的方式占用一个存取周期。</p><h5 id="DMA-与主存交换数据的三种方式"><a href="#DMA-与主存交换数据的三种方式" class="headerlink" title="DMA 与主存交换数据的三种方式"></a>DMA 与主存交换数据的三种方式</h5><ul><li>停止 CPU 访问主存</li></ul><p>当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202217133.png" class="" title="image-20230926202217133"><ul><li>周期挪用（或周期窃取）</li></ul><p>在这种方法中，每当I&#x2F;O设备发出DMA请求时，IO设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。I&#x2F;O设备请求DMA传送会遇到三种情祝。一种是CPU此时不需要访问主存（如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需要访问主存)，故I&#x2F;O设备与CPU不发生冲突。第二种情况是I&#x2F;O设备请求DMA传送时，CPU正在访问主存，此时必须待存取周期结束，CPU才能将总线占有权让出。第三种情况是I&#x2F;O设备要求访问主存时，CPU也要求访问主存，这就出现了访问冲突。此刻，I&#x2F;O访存优先于CPU访问主存，因为I&#x2F;O不立即访问主存就可能丢失数据，这时I&#x2F;O要窃取一、二个存取周期，意味着CPU在执行访问主存指令过程中插入了DMA请求，并挪用了一、二个存取周期，使CPU延缓了一、二个存取周期再访问主存。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202243779.png" class="" title="image-20230926202243779"><ul><li>DMA 与 CPU 交替访问</li></ul><p>这种方法适合于CPU的工作周期比主存存取周期长的情况。例如，CPU的工作周期为1.2u3,主存的存取周期小于0.6us,那么可将一个CPU周期分为C和C2两个分周期，其中C,专供DMA访存，C2专供CPU访存，</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202301140.png" class="" title="image-20230926202301140"><h4 id="DMA-接口的功能和组成"><a href="#DMA-接口的功能和组成" class="headerlink" title="DMA 接口的功能和组成"></a>DMA 接口的功能和组成</h4><h5 id="DMA-接口功能"><a href="#DMA-接口功能" class="headerlink" title="DMA 接口功能"></a>DMA 接口功能</h5><p>利用DMA方式传送数据时，数据的传输过程完全由DMA接口电路控制，故DMA接口又有DMA控制器之称。DMA接口应具有如下几个功能。</p><ul><li>向CPU申请DMA传送。</li><li>在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响CPU正常活动或引起总线竞争。</li><li>在DMA期间管理系统总线，控制数据传送。</li><li>确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度。</li><li>在数据块传送结束时，给出DMA操作完成的信号。</li></ul><h5 id="DMA-接口组成"><a href="#DMA-接口组成" class="headerlink" title="DMA 接口组成"></a>DMA 接口组成</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202653060.png" class="" title="image-20230926202653060"><ul><li>主存地址寄存器(AR)</li></ul><p>AR用于存放主存中需要交换数据的地址。在DMA传送数据前，必须通过程序将数据在主存中的首地址送到主存地址寄存器。在DMA传送过程中，每交换一次数据，将地址寄存器内容加1，直到一批数据传送完毕为止。</p><ul><li>字计数器(WC)</li></ul><p>WC用于记录传送数据的总字数，通常以交换字数的补码值预置。在DMA传送过程中，每传送一个字，字计数器如1，直到计数器为0，即最高位产生进位时，表示该批数据传送完毕（若交换字数以原码值预置，则每传送一个字，字计数器减1，直到计数器为0时，表示该批数据传送结束)。于是DMA接口向CPU发中断请求信号。</p><ul><li>数据缓冲寄存器(BR)</li></ul><p>BR用于暂存每次传送的数据。通常DMA接口与主存之间采用字传送，而DMA与设备之间可能是字节或位传送。因此DMA接口中还可能包括有装配或拆卸字信息的硬件逻辑，如数据移位缓冲寄存器、字节计数器等。</p><ul><li>DMA控制逻辑</li></ul><p>DMA控制逻辑负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。每当设备准备好一个数据字（或一个字传送结束），就向DMA接口提出申请(DREQ),DMA控制逻辑便向CPU请求DMA服务，发出总线使用权的请求信号(HRQ)。待收到CPU发出的响应信号HLDA后，DMA控制逻辑便开始负责管理DMA传送的全过程，包括对主存地址寄存器和字计数器的修改、识别总线地址、指定传送类型（输入或输出）以及通知设备已经被授予一个DMA周期(DACK)等。</p><ul><li>中断机构</li></ul><p>当字计数器溢出（全“0”）时，表示一批数据交换完毕，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作.DMA操作的后处理。必须注意，这里的中断与5.5节介绍的I&#x2F;O中断的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一批数据传送结束。它们是I&#x2F;O系统中不同的中断事件。</p><ul><li>设备地址寄存器(DAR)</li></ul><p>DAR存放I&#x2F;O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号、盘面号和柱面号。具体内容取决于设备的数据格式和地址的编址方式。</p><h4 id="DMA-的工作过程"><a href="#DMA-的工作过程" class="headerlink" title="DMA 的工作过程"></a>DMA 的工作过程</h4><h5 id="DMA-传送过程"><a href="#DMA-传送过程" class="headerlink" title="DMA 传送过程"></a>DMA 传送过程</h5><p>DMA的数据传送过程分为预处理、数据传送和后处理3个阶段。</p><h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>在DMA接口开始工作之前，CPU必须给它预置如下信息。</p><ol><li>给DMA控制逻辑指明数据传送方向是输人（写主存）还是输出（读主存）。</li><li>向DMA设备地址寄存器送人设备号，并启动设备。</li><li>向DMA主存地址寄存器送入交换数据的主存起始地址。</li><li>对字计数器赋予交换数据的个数。</li></ol><p>上述工作由CPU执行几条输入输出指令完成，即程序的初始化阶段。这些工作完成后，CPU继续执行原来的程序，当I&#x2F;O设备推备好发送的数据（输人）或上次接收的数据已经处理完毕（输出）时，它便通过DMA接口向CPU提出占用总线的申请，若有多个DMA同时申请，则按轻重缓急由硬件排队判优逻辑决定优先等。待I&#x2F;O设备得到主存总线的控制权后，数据的传送便由该DMA接口进行管理。</p><h6 id="DMA-传送过程示意"><a href="#DMA-传送过程示意" class="headerlink" title="DMA 传送过程示意"></a>DMA 传送过程示意</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203301196.png" class="" title="image-20230926203301196"><p>以数据输入为例：</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203631295.png" class="" title="image-20230926203631295"><ol><li>当设备准备好一个字时，发出选通信号，将该字读到DMA的数据级冲寄存器(BR)中，表示数据缓冲寄存器“满”（如果I&#x2F;O设备是面向字符的，则一次读入一个字节，组装成一个字）。</li><li>与此同时设备向DMA接口发请求(DREQ)。</li><li>DMA接口向CPU申请总线控制权(HRQ)。</li><li>CPU发回HLDA信号，表示允许将总线控制权交给DMA接口。</li><li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器写。</li><li>通知设备已被授予一个DMA周期(DACK),并为交换下一个字做准备。</li><li>将DMA数据缓冲寄存器的内容送数据总线。</li><li>主存将数据总线上的信息写至地址总线指定的存储单元中。</li><li>修改主存地址和字计数值。</li><li>判断数据块是否传送结束，若未结束，则继续传送；若已结束，（宇计数器溢出），则向CPU申请程序中断，标志数据块传送结束。</li></ol><p>以数据输出为例：</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203744324.png" class="" title="image-20230926203744324"><ol><li>当DMA数据缓冲寄存器已将输出数据送至&#x2F;0设备后，表示数据缓冲寄存器已“空”。</li><li>设备向DMA接口发请求(DREQ)。</li><li>DMA接口向CPU申请总线控制权(HRQ)。</li><li>CPU发回HLDA信号，表示允许将总线控制权交给DMA接口使用。</li><li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器读。</li><li>通知设备已被授予一个DMA周期(DACK),并为交换下一个字做准备。</li><li>主存将相应地址单元的内容通过数据总线读入到DMA的数据缓冲寄存器中。</li><li>将DMA数据缓神寄存器的内容送到输出设备，若为字符设备，则需将其拆成字符输出。</li><li>修改主存地址和字计数值。</li><li>判断数据块是否已传送完毕，若未完毕，继续传送；若已传送完毕，则向CPU申请程序中断。</li></ol><h6 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h6><p>当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，做一些DMA的结束工作的后处理部分。这包括校验送入主存的数据是否正确；决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化，若不需要传送，则停止外设；测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序。</p><h5 id="DMA-接口与系统的连接方式"><a href="#DMA-接口与系统的连接方式" class="headerlink" title="DMA 接口与系统的连接方式"></a>DMA 接口与系统的连接方式</h5><h6 id="具有公共请求线的-DMA-请求"><a href="#具有公共请求线的-DMA-请求" class="headerlink" title="具有公共请求线的 DMA 请求"></a>具有公共请求线的 DMA 请求</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204157036.png" class="" title="image-20230926204157036"><p>为具有公共请求线的DMA请求方式，若干个DMA接口通过一条公用的DMA请求线向CPU申请总线控制权。CPU发出响应信号，用链式查询方式通过DMA接口，首先选中的设备获得总线控制权，即可占用总线与主存传送信息。</p><h6 id="独立的-DMA-请求"><a href="#独立的-DMA-请求" class="headerlink" title="独立的 DMA 请求"></a>独立的 DMA 请求</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204213449.png" class="" title="image-20230926204213449"><p>)是独立的DMA请求方式，每一个DMA接口各有一对独立的DMA请求线和DMA响应线，它由CPU的优先级判别机构裁决首先响应哪个请求，并在响应线上发出响应信号，被获得响应信号的DMA接口便可控制总线与主存传送数据。</p><p>与程序中断方式相比，DMA方式有如下特点。</p><ul><li>从数据传送看，程序中断方式靠程序传送，DMA方式靠硬件传送。</li><li>从CPU响应时间看，程序中断方式是在一条指令执行结束时响应，而DMA方式可在指令周期内的任一存取周期结束时响应。</li><li>程序中断方式有处理异常事件的能力，DMA方式没有这种能力，主要用于大批数据的传送，如硬盘存取、图像处理、高速数据采集系统等，可提高数据吞吐量。</li><li>程序中断方式需要中断现行程序，故需保护现场；DMA方式不中断现行程序，无须保护现场。</li><li>DMA的优先级比程序中断的优先级高。</li></ul><h4 id="DMA-接口的类型"><a href="#DMA-接口的类型" class="headerlink" title="DMA 接口的类型"></a>DMA 接口的类型</h4><h5 id="选择型"><a href="#选择型" class="headerlink" title="选择型"></a>选择型</h5><p>这种类型的DMA接口的基本组成，它的主要特点是在物理上可连接多个设备，在逻辑上只允许连接一个设备，即在某一段时间内，DMA接口只能为一个设备服务，关键是在预处理时将所选设备的设备号送人设备地址寄存器。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204614841.png" class="" title="image-20230926204614841"><h5 id="多路型"><a href="#多路型" class="headerlink" title="多路型"></a>多路型</h5><p>多路型DMA接口不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作，各个设备采用字节交叉的方式通过DMA接口进行数据传送。在多路型DMA接口中，为每个与它连接的设备都设置了一套寄存器，分别存放各自的传送参数。分</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204638266.png" class="" title="image-20230926204638266"><p>多路型 DMA 接口的工作原理</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204937986.png" class="" title="image-20230926204937986"><p>上图是多路型DMA接口工作原理示意图。图中磁盘、磁带、打印机同时工作。磁盘、磁带、打印机分别每隔30us、45us、150us向DM接口发DMA请求，磁盘的优先级高于磁带，磁带的优先级高于打印机。</p><p>假设DMA接口完成一次DMA数据传送需5s,由图可见，打印机首先发请求，故DMA接口首先为打印机服务(T1);接着磁盘、磁带同时又有DMA请求，DMA接口按优先级别先响应磁盘请求(T2),再响应磁带请求(T3),每次DMA传送都是一个字节。这样，在90多微秒的时间里，DMA接口为打印机服务一次(T1),为磁盘服务4次(T2、T4、T6、T7),为磁带服务3次(T3、T5、T8)。可见DMA接口还有很多空闲时间，可再容纳更多的设备。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql基础篇</title>
    <link href="/2023/09/18/mysql%E7%AF%87/"/>
    <url>/2023/09/18/mysql%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>创建一个数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT DATABASE RUNOOB;<br></code></pre></td></tr></table></figure><p>删除一个数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE RUNOOB;<br></code></pre></td></tr></table></figure><p>选择一个数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE RUNOOB;<br></code></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h6 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h6><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th align="right">用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 Bytes</td><td>(-128，127)</td><td>(0，255)</td><td align="right">小整数值</td></tr><tr><td>SMALLINT</td><td>2 Bytes</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td align="right">大整数值</td></tr><tr><td>MEDIUMIN</td><td>3 Bytes</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td align="right">大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 Bytes</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td align="right">大整数值</td></tr><tr><td>BIGINT</td><td>8 Bytes</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td align="right">极大整数值</td></tr><tr><td>FLOAT</td><td>4 Bytes</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="right">单精度<br/>浮点数值</td></tr><tr><td>DOUBLE</td><td>8 Bytes</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="right">双精度<br/>浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td align="right">小数值</td></tr></tbody></table><h6 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h6><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="center">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="center">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="center">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="center">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="center">混合日期和时间值，时间戳</td></tr></tbody></table><h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6><table><thead><tr><th>CHAR</th><th>0-255 bytes</th><th>定长字符串</th></tr></thead><tbody><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><h4 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h4><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p>以下为创建MySQL数据表的SQL通用语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE table_name (column_name column_type);<br></code></pre></td></tr></table></figure><p>为RUNOOB数据库创建一张表</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层(三)</title>
    <link href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/"/>
    <url>/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本章最重要的内容是：</p><ul><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议(PPP协议以及CSMA&#x2F;CD协议)的特点。</li><li>数据链路层的三个基本问题：封装成帧、透明传输和差错检测。</li><li>以太网MAC层的硬件地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。</li></ul><span id="more"></span><p>数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><h3 id="数据链路层的几个共同问题"><a href="#数据链路层的几个共同问题" class="headerlink" title="数据链路层的几个共同问题"></a>数据链路层的几个共同问题</h3><h4 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h4><p>我们在这里要明确一下，<strong>“链路”</strong>和<strong>“数据链路”</strong>并不是一回事。所谓<strong>链路</strong>(link)就是从一个节点到<strong>相邻节点</strong>的一段物理线路（有线或无线)，而中间没有任何其他的交换节点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</p><p><strong>数据链路(data link)<strong>则是另一个概念。这是因为当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输（这将在后面几节讨论)。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用网络适配器（既有硬件，也包括软件）来实现这些协议。一般的适配器都包括了数据链路层和物理层这两层的功能。也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。物理链路就是上面所说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。早期的数据通信协议曾叫作通信</strong>规程</strong>(procedure)。因此在数据链路层，规程和协议是同义语。</p><p><strong>桢</strong>——点对点信道的数据链路层的协议数据单元</p><p>数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是IP数据报（或简称为数据报、分组或包)。</p><p>为了把主要精力放在点对点信道的数据链路层协议上，可以采用下图所示的三层模型。在这种三层模型中，不管在哪一段链路上的通信（主机和路由器之间或两个路由器之间)，我们都看成是节点和节点的通信（如图中的节点A和节点B),而每个节点只有下三层—网络层、数据链路层和物理层。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910194724135.png" class="" title="image-20230910194724135"><p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p><ol><li>节点A的数据链路层把网络层交下来的P数据报添加首部和尾部封装成帧。</li><li>节点A把封装好的帧发送给节点B的数据链路层。</li><li>若节点B的数据链路层收到的帧无差错，则从收到的帧中提取出P数据报交给上面的网络层：否则丢弃这个帧。数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如下图所示</li></ol><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910194930340.png" class="" title="image-20230910194930340"><h4 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h4><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：封装成帧、透明传输和差错检测。</p><h5 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h5><p>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。下图表示用帧首部和帧尾部封装成帧的一般概念。我们知道，分组交换的一个重要概念就是：所有在互联网上传送的数据都以分组（即IP数据报）为传送单位。网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限一最大传送单元MTU(Maximum Transfer Unit)。下图给出了帧的首部和尾部的位置，以及帧的数据部分与MTU的关系</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910195411903.png" class="" title="image-20230910195411903"><h5 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h5><p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。但当数据部分是非ASCⅡ码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样(如图3-6所示)，数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧)，而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH)。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910200044140.png" class="" title="image-20230910200044140"><p>像上图所示的帧的传输显然就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”将被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。但实际上在数据中出现的字符“E0T”并非控制字符而仅仅是二进制数据00000100。</p><p>前面提到的“透明”是一个很重要的术语。它表示：某一个实际存在的事物看起来却好像不存在一样（例如，你看不见在你前面有块100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p><p>前面提到的“透明”是一个很重要的术语。它表示：某一个实际存在的事物看起来却好像不存在一样（例如，你看不见在你前面有块100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p><p>为了解决透明传输问题，就必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。<strong>具体的方法</strong>是：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B,二进制是00011011)。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充(byte stuffing)或字符填充(character stuffing)。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。下图表示用字节填充法解决透明传输的问题。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910222053765.png" class="" title="image-20230910222053765"><h5 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h5><p>现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。这就叫作<strong>比特差错</strong>。比特差错是传输差错中的一种。本小节所说的“差错”，如无特殊说明，就是指“比特差错”。在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER</strong>(Bit Error Rate)。例如，误码率为10^-10时，表示平均每传送10个比特就会出现一个比特的差错。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并非是理想的，它不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了<strong>循环冗余检验</strong>CRC(Cyclic Redundancy Check)的检错技术。</p><h6 id="CRC循环冗余校验码的原理"><a href="#CRC循环冗余校验码的原理" class="headerlink" title="CRC循环冗余校验码的原理"></a>CRC循环冗余校验码的原理</h6><p>发送端，先把数据划分为组，假定每组k位比特，在每组M后面再添加供差错检测用的n位冗余码（帧检验序列FCS），然后构成一个帧发送出去，那么就是一共发送k+n位</p><p>接收端，接收到k+n位之后，将接收到都除以相同的P，然后检出余数R，如果余数R为0，则证明传输正确。</p><h6 id="冗余码FCS的计算"><a href="#冗余码FCS的计算" class="headerlink" title="冗余码FCS的计算"></a>冗余码FCS的计算</h6><ol><li>用二进制的模2运算进行2^n乘M的运算，这相当于在M后面添加n个0</li><li>得到的k+n位的数除以事先选定好的长度为n+1位的除数P，得出商是Q，余数是R，余数R比除数P少1位，即R是n位。</li><li>将余数R作为冗余码拼接在数据M后面，一起发送出去。</li></ol><p>计算过程如下图所示</p><ol><li>假定要传输的数据为M&#x3D;101001（k&#x3D;6）；</li><li>假定除数为P&#x3D;1101（因为选定的是除数P是4位，所以n&#x3D;3，也就是P的位数-1）</li><li>在M后面加n个0（n&#x3D;3，所以加3个0），得到M’&#x3D;101001000；</li><li>用M’除以P</li></ol><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910223309774.png" class="" title="image-20230910223309774"><h6 id="除数P是哪来的"><a href="#除数P是哪来的" class="headerlink" title="除数P是哪来的"></a>除数P是哪来的</h6><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910223644470.png" class="" title="image-20230910223644470"><p>最后再强调一下，在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受，即：“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾<strong>收到</strong>了，但最终还是因为有差错被丢弃，即没有被<strong>接受</strong>。以上所述的可以<strong>近似</strong>地表述为（通常都是这样认为）：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。请注意，我们现在并没有要求数据链路层向网络层提供“可靠传输”的服务。所谓“可靠传输”就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为两大类：一类就是前面所说的最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。例如，发送方连续传送三个帧：[#1][#2][#3]。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：</p><ul><li>帧丢失：收到#1]-[#3]（丢失[#2]）。</li><li>帧重复：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2]）。</li><li>帧失序：收到[#1]-[#3]-[#2]（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样)。</li></ul><p>以上三种情况都属于“<strong>出现传输差错</strong>”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。在学完运输层，我们就会知道在什么情况下接收端可能会出现帧重复或帧失序。总之，我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。</p><h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><h4 id="各字段的意义"><a href="#各字段的意义" class="headerlink" title="各字段的意义"></a>各字段的意义</h4><p>PPP的帧格式如图所示。PPP帧的首部和尾部分别为四个字段和两个字段。</p><p>首部的第一个字段和尾部的第二个字段都是标志字段F(Flag),规定为0x7E(符号“0x”表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是PPP帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃。</p><p>首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011)。最初曾考虑以后再对这两个字段的值进行其他定义，但至今也没有给出。可见这两个字段实际上并没有携带PPP帧的信息。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913113344001.png" class="" title="image-20230913113344001"><p>PPP首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021,则信息字段是PPP链路控制协议LCP的数据，而0x8021表示这是网络层的控制数据。</p><p>信息字段的长度是可变的，不超过1500字节。尾部中的第一个字段(2字节)是使用CRC的帧检验序列FCS。</p><h4 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h4><p>当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。</p><p>当PPP使用异步传输时，它把转义符定义为0x7D(即01111101)，并使用字节填充，RFC1662规定了如下所述的填充方法：</p><ol><li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D,0x5E)。</li><li>若信息字段中出现一个0x7D的字节（即出现了和转义字符一样的比特组合），则把0x7D转变成为2字节序列(0x7D,0x5D)。</li><li>若信息字段中出现ASCI码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列(0x7D,0x23)。由于在发送端进行了字节填充，因此在链路上传送的信息字节数就超过了原来的信息字节数。但接收端在收到数据后再进行与发送端字节填充相反的变换，就可以正确地恢复出原来的信息。</li></ol><h4 id="比特零填充"><a href="#比特零填充" class="headerlink" title="比特零填充"></a>比特零填充</h4><p>PPP协议用在SONET&#x2F;SDH链路时，使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送）。在这种情况下，PPP协议采用零比特填充方法来实现透明传输。零比特填充的具体做法是：在发送端，先扫描整个信息字段（通常用硬件实现，但也可用软件实现，只是会慢些)。只要发现有5个连续1，则立即填入一个0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流（如图3-11所示)。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913120324664.png" class="" title="image-20230913120324664"><h4 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h4><p>我们通过PPP帧的格式讨论了PPP帧是怎样组成的。但PPP链路一开始是怎样被初始化的？当用户拨号接入ISP后，就建立了一条从用户个人电脑到ISP的物理连接。这时，用户个人电脑向ISP发送一系列的链路视频讲解控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的P地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机了。</p><p>当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。上述过程可用如图所示的状态图来描述。</p><p>PPP链路的起始和终止状态永远是图中的“<strong>链路静止</strong>”(Link Dead)状态，这时在用户个人电脑和ISP的路由器之间并不存在物理层的连接。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913120728341.png" class="" title="image-20230913120728341"><p>当用户个人电脑通过调制解调器呼叫路由器时（通常是在屏幕上用鼠标点击一个连接按钮)，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP就进入“<strong>链路建立</strong>”(Link Establish)状态，其目的是建立链路层的LCP连接。</p><p>这时LCP开始协商一些配置选项，即发送LCP的配置请求帧(Configure-.Request)。这是个PPP帧，其协议字段置为LCP对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：</p><ol><li>配置确认帧(Configure-.Ack):所有选项都接受。</li><li>配置否认帧(Configure-.Nak):所有选项都理解但不能接受。</li><li>配置拒绝帧(Configure-.Reject):选项有的无法识别或不能接受，需要协商。</li></ol><p>LCP配置选项包括链路上的最大帧长、所使用的鉴别协议(Authentication Protocol)的规约（如果有的话），以及不使用PPP帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在PPP帧的首部中省略这两个字节)。</p><p>协商结束后双方就建立了LCP链路，接着就进入“<strong>鉴别</strong>”(Authenticate)状态。在这一状态，只允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用口令鉴别协议PAP(Password Authentication Protocol),则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的<strong>口令握手鉴别协议</strong>CHAP(Challenge-Handshake Authentication Protocol)。若鉴别身份失败，则转到“<strong>链路终止</strong>”(Link Terminate)状态。若鉴别成功，则进入“网络层协议”Network-LayerProtocol)状态。</p><p>在“网络层协议”状态，PPP链路两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信。</p><p>如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块（如分配IP地址)时就要使用NCP中支持IP的协议一IP控制协议IPCP(IP Control Protocol)。IPCP分组也封装成PPP帧（其中的协议字段为Ox8021)在PPP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和IP首部，以减少在链路上发送的比特数。</p><p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”(Link Open)状态。链路的两个PPP端点可以彼此向对方发送分组。两个PPP端点还可发送回送请求LCP分组(Echo-Request)和回送回答LCP分组(Echo-Reply),以检查链路的状态。数据传输结束后，可以由链路的一端发出终止请求LCP分组(Terminate-Request)请求终止链路连接，在收到对方发来的终止确认LCP分组(Terminate-Ack)后，转到“链路终止”状态。如果链路出现故障，也会从“链路打开”状态转到“链路终止”状态。当调制解调器的载波停止后，则回到“链路静止”状态。</p><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p>广播信道可以进行一对多的通信。下面要讨论的局域网使用的就是广播信道。局域网是在20世纪70年代末发展起来的。局域网技术在计算机网络中占有非常重要的地位。</p><h4 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h4><p>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。在局域网刚刚出现时，局域网比广域网具有较高的数据率、较低的时延和较小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率。</p><p>局域网具有如下的一些优点：</p><ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性(reliability)、可用性(availability)和生存性(survivability)。</li></ul><p>局域网可按网络拓扑进行分类。图a是星形网。由于集线器的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了非常广泛的应用。图(b)是环形网，图(c)为总线网，各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名，但以太网后来又演变成了星形网。经过四十多年的发展，以太网的速率已大大提高。现在最常用的以太网的速率是1Gbit&#x2F;s(家庭或中小企业)、10Gbit&#x2F;s(数据中心)和100Gbt&#x2F;s(长距离传输)，且其速率仍在继续提高。现在以太网已成为了局域网的同义词</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913122113630.png" class="" title="image-20230913122113630"><p>必须指出，局域网工作的层次跨越了数据链路层和物理层。由于局域网技术中有关数据链路层的内容比较丰富，因此我们就把局域网的内容放在数据链路层这一章中讨论。但这并不表示局域网仅仅和数据链路层有关。</p><p>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：</p><ol><li>静态划分信道，如在第2章的2.4节中已经介绍过的频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用。</li><li>动态媒体接入控制，它又称为**多点接入(**multiple access),其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：</li></ol><ul><li>随机接入</li></ul><p>随机接入的特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突)，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</p><ul><li>受控接入</li></ul><p>受控接入的特点是用户不能随机地发送信息而必须服从一定的控制：这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询(polling),或称为轮询。</p><p>属于随机接入的以太网将被重点讨论。受控接入则由于目前在局域网中使用得较少，</p><p>由于以太网的数据率己演进到每秒吉比特甚至高达400吉比特，因此通常就用“传统以太网”来表示最早流行的10Mbt&#x2F;s速率的以太网。为了讨论原理，下面我们就从传统以太网开始。</p><h5 id="以太网的两个主要标准"><a href="#以太网的两个主要标准" class="headerlink" title="以太网的两个主要标准"></a>以太网的两个主要标准</h5><p>逻辑链路控制LLC(Logical Link Control)子层和媒体接入控制MAC(Medium Access Control)子层。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913123042264.png" class="" title="image-20230913123042264"><p>目前使用最多的局域网只剩下DIX Ethernet V2(简称为以太网)，而不是EEE802委员会制定的几种局域网。EEE802委员会制定的逻辑链路控制子层LLC(即IEEE802.2标准)的作用已经消失了，很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议。本章在介绍以太网时就不再考虑LLC子层。这样对以太网工作原理的讨论会更加简洁。</p><h5 id="适配器的作用"><a href="#适配器的作用" class="headerlink" title="适配器的作用"></a>适配器的作用</h5><p>计算机与外界局域网的连接是通过适配器(adapter)。适配器本来是在主机箱内插入的块网络接口板（或者是在笔记本电脑中插入一块PCMCIA卡一个人计算机存储器卡接口适配器)。这种接口板又称为网络接口卡NIC (Network Interface Card)或简称为“网卡”。由于现在计算机主板上都已经嵌入了这种适配器，不再使用单独的网卡了，因此本书使用适配器这个更准确的术语。在这种通信适配器上面装有处理器和存储器（包括RAM和ROM)。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的&#x2F;O总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p><p>适配器在接收和发送各种帧时，不使用计算机的CPU。这时计算机中的CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。图3-15表示适配器的作用。我们特别要注意，计算机的硬件地址（在本章的3.3.5节讨论）就在适配器的ROM中，而计算机的软件地址一P地址（在第4章讨论），则在计算机的存储器中。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913123512657.png" class="" title="image-20230913123512657"><h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><p>总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。这种就是广播通信方式。但我们并不总是要在局域网上进行一对多的广播通信。为了在总线上实现一对一的通信，可以使每一台计算机的适配器都拥有一个与其他适配器都不同的地址。在发送数据帧时，在帧的首部写明接收站的地址。现在的电子技术可以很容易做到：仅当数据帧中的目的地址与适配器ROM中存放的硬件地址一致时，该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧就丢弃。这样，具有广播特性的总线上就实现了一对一的通信。</p><p>人们也常把局域网上的计算机称为<strong>“主机</strong>”“<strong>工作站</strong>”“<strong>站点</strong>”或“<strong>站</strong>”。在本书中，这几个名词都可以当成是同义词。</p><p>为了通信的简便，以太网采取了以下两种措施：</p><p>第一，采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，以太网提供的服务是尽最大努力的交付，即不可靠的交付。当目的站收到有差错的数据帧时(例如，用CRC查出有差错)，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来决定。例如，如果高层使用TCP协议，那么TCP就会发现丢失了一些数据。于是经过一定的时间后，TCP就把这些数据重新传递给以太网进行重传。但以太网并不知道这是重传帧，而是当作新的数据帧来发送。</p><p>我们知道，总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。以太网采用最简单的随机接入，但有很好的协议用来减少冲突发生的概率。这好比有一屋子的人在开讨论会，没有会议主持人控制发言。想发言的随时可发言，不需要举手示意。但我们还必须有个协议来协调大家的发言。这就是：如果你听见有人在发言，那么你就必须等别人讲完了才能发言（否则就干扰了别人的发言）。但有时碰巧两个或更多的人同时发言了，那么一旦发现冲突，大家都必须立即停止发言，等听到没有人发言了你再发言。以太网采用的协调方法和上面的办法非常像，<strong>它使用的协议是CSMA&#x2F;CD,意思是载波监听多点接入&#x2F;碰撞检测(Carrier Sense Multiple Access with Collision Detection)。</strong></p><p>第二，以太网发送的数据都使用曼彻斯特Manchester)编码的信号。我们在第2章的2.2.2节中已经简单地介绍过曼彻斯特编码了。我们知道，二进制基带数字信号通常就是高、低电压交替出现的信号。使用这种信号的最大问题就是当出现一长串连续的1或连续的0时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。如图3-16所示，曼彻斯特编码的编码方法是把每一个码元再分成两个相等的间隔。码元1是前一个间隔为低电压而后一个间隔为高电压。码元0则正好相反，从高电压变到低电压（也可采用相反的约定，即1是“前高后低”而0是“前低后高”)。这样就保证了在每一个比特的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来。但是从曼彻斯特编码的波形图也不难看出其缺点，这就是它所占的频带宽度比原始的基带信号增加了一倍(因为每秒传送的码元数加倍了)。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913124141451.png" class="" title="image-20230913124141451"><p>“<strong>多点接入</strong>”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。</p><p><strong>“载波监听</strong>”也就是“边发送边监听”。这里必须指出，在通信领域，在大多数情况下，Carrier的标准译名是“载波”。但对于以太网，总线上根本没有什么“载波”。其实英语Carrier有多种意思，如“承运器”“传导管”或“运载工具”等。因此在以太网中，把Carrier译为“载体”或“媒体”可能更加准确些。考虑到“载波”这个译名已经在我国广泛流行了好几十年，本书也就继续使用这个不准确的译名。我们知道，载波监听就是不管在想要发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道。在发送前检测信道，是为了避免冲突。如果检测出已经有其他站在发送，则本站就暂时不要发送数据。在发送中检测信道，是为了及时发现如果有其他站也在发送，就立即中断本站的发送。这就称为碰撞检测。</p><p>“<strong>碰撞检测</strong>”是适配器边发送数据边检测信道上的信号电压的变化情况。当两个或几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。这时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。因此，任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得继续进行无效的发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</p><p>图所示的例子可以说明这种情况。设图中的局域网两端的站A和B相距1k,用同轴电缆相连。电磁波在1k电缆的传播时延约为5us(这个数字应当记住)。因此，A向B发出的数据，在约5s后才能传送到B。换言之，B若在A发送的数据到达B之前发送自己的帧（因为这时B的载波监听检测不到A所发送的信息），则必然要在某个时间和A发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的单程端到端传播时延记为x。发送数据的站希望尽早知道是否发生了碰撞。那么，A发送数据后，最迟要经过多长时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞？从图不难看出，这个时间最多是两倍的总线端到端的传播时延(2)，或总线的端到端往返传播时延。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延（这两个站之间的距离最大）为端到端传播时延。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913125033086.png" class="" title="image-20230913125033086"><p>显然，在使用CSMA&#x2F;CD协议时，一个站不可能同时进行发送和接收（但必须边发送边监听信道)。因此使用CSMA&#x2F;CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工通信）。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230914172406680.png" class="" title="image-20230914172406680"><p>由此可见，每一个站在自己发送<strong>数据之后的一小段时间内</strong>，<strong>存在着遭遇碰撞的可能性</strong>。这一小段时间是不确定的，它取决于另一个发送数据的站到本站的距离。因此，以太网不能保证在检测到信道空闲后的某一时间内，一定能够把自己的数据帧成功地发送出去（因为存在产生碰撞的可能)。以太网的这一特点称为发送的不确定性。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</p><p>从图可看出，最先发送数据帧的A站，在发送数据帧后至多经过时间2t他就可知道所发送的数据帧是否遭受了碰撞。这就是δ→0的情况。因此以太网的端到端往返时间2t称为<strong>争用期</strong>(contention period),它是一个很重要的参数。争用期又称为碰撞窗口(collisionwindow)。这是因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</p><h6 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a><strong>截断二进制指数退避</strong>算法</h6><p>以太网使用<strong>截断二进制指数退避</strong>(truncated binary exponential backoff)算法来确定碰撞后重传的时机。截断二进制指数退避算法并不复杂。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是退避一个随机的时间。这点很容易理解，因为几个发生碰撞的站将会同时检测到信道变成了空闲。如果大家都同时重传，必然接连发生碰撞。如果采用退避算法，生成了最小退避时间的站将最先获发送权。以后其余的站的退避时间到了，但发送数据之前监听到信道忙，就不会马上发送数据了。</p><p>为了尽可能减小重传时再次发生冲突的概率，退避算法有如下具体的规定：</p><ul><li>基本退避时间为争用期2t,具体的争用期时间是51.2us。对于10Mbit&#x2F;s以太网，在争用期内可发送512比特，即64字节。也可以说争用期是512比特时间。1比特时间就是发送1比特所需的时间。所以这种时间单位与数据率密切相关。为了方便，也可以直接使用比特作为争用期的单位。争用期是512比特，即争用期是发送512比特所需的时间。</li><li>从离散的整数集合[0,1，…，(2^k^-1)]中随机取出一个数，记为r。重传应推后的时间就是r倍的争用期。上面的参数k按下面的公式计算：k&#x3D;Min[重传次数，10]可见当重传次数不超过10时，参数k等于重传次数：但当重传次数超过10时，k就不再增大而一直等于10。</li><li>当重传达16次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突)，则丢弃该帧，并向高层报告。例如，在第1次重传时，k&#x3D;1,随机数r从整数0,1}中选一个数。因此重传的站可选择的重传推迟时间是0或2π，在这两个时间中随机选择一个。若再发生碰撞，则在第2次重传时，k&#x3D;2,随机数r就从整数0,1,2,3}中选一个数。因此重传推迟的时间是在0.2x,4x和6x这4个时间中随机地选取一个。若再发生碰撞，则在第2次重传时，k&#x3D;2,随机数r就从整数0,1,2,3}中选一个数。因此重传推迟的时间是在0,2x,4x和6x这4个时间中随机地选取一个。同样，若再发生碰撞，则重传时k&#x3D;3,随机数r就从整数0,1,2,3,4,5,6,7}中选一个数。依此类推。若连续多次发生冲突，就表明可能有较多的站参与争用信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</li></ul><p>下面介绍<strong>强化碰撞</strong>的概念。这就是当发送数据的站一旦发现发生了碰撞时，除立即停止发送数据外，还要再继续发送32比特或48比特的人为干扰信号(jamming signal),以便让所有用户都知道现在已经发生了碰撞（对于10Mbit&#x2F;s以太网，发送32或48)比特只需要3.2（或4.8）μs。</p><p>根据以上所讨论的，可以把CSMA&#x2F;CD协议的要点归纳如下：</p><ul><li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部（见后面的3.4.3节)，组成以太网帧，放入适配器的缓存中。但在发送之前，必须先检测信道。</li><li>检测信道：若检测到信道忙，则继续不停地检测，一直等待信道转为空闲。此时若在96比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li><li>在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可<br>能性：<ul><li>发送成功：<br>如果在争用期内一直未检测到碰撞，就认为发送成功（如果接收方收到了有差错的帧，就丢弃它，后续的工作由高层来处理)。发送完毕后，其他什么也不做。然后回到(1)。</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待r倍512比特时间后，返回到步骤(2)，继续检测信道。但若重传达16次仍不能成功，则停止重传而向上报错。以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</li></ul></li></ul><h4 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h4><p>传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫作**集线器(**hub),</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230917230121908.png" class="" title="image-20230917230121908"><p>集线器的一些特点如下：</p><ul><li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。也就是说，<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA&#x2F;CD协议</strong>（更具体些说，是各站中的适配器执行CSMA&#x2F;CD协议）。网络中的各站必须竞争对传输媒体的控制，<strong>并且在同一时刻至多只允许一个站发送数据。</strong></li><li>一个集线器有许多端口①，例如，8至16个，每个端口通过RJ-45插头（与电话机使用的插头RJ-11相似，但略大一些)用两对双绞线与一台计算机上的适配器相连（这种插座可连接4对双绞线，实际上只用2对，即发送和接收各使用一对双绞线)。因此，<strong>一个集线器很像一个多端口的转发器。</strong></li><li><strong>集线器工作在物理层</strong>，它的每个端口仅仅简单地转发比特收到1就转发1，收到0就转发0，不进行碰撞检测。若两个端口同时有信号输入（即发生碰撞），那么所有的端口都将收不到正确的帧。图3-20是具有三个端口的集线器的示意图。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使端口转发出去的较强信号不致对该端口接收到的较弱信号产生干扰（这种干扰即近端串音）。每个比特在转发之前还要进行再生整形并重新定时。</li></ul><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230917230313131.png" class="" title="image-20230917230313131"><p>集线器本身必须非常可靠。现在的堆叠式(stackable)集线器由4~8个集线器堆叠起来使用。集线器一般都有少量的容错能力和网络管理功能。例如，假定在以太网中有一个适配器出了故障，不停地发送以太网帧。这时，集线器可以检测到这个问题，在内部断开与出故障的适配器的连线，使整个以太网仍然能够正常工作。模块化的机箱式智能集线器有很高的可靠性。它全部的网络功能都以模块方式实现。各模块均可进行热插拔，出故障时不断电即可更换或增加新模块。集线器上的指示灯还可显示网络上的故障情况，给网络的管理带来了很大的方便。</p><h4 id="以太网的利用率"><a href="#以太网的利用率" class="headerlink" title="以太网的利用率"></a>以太网的利用率</h4><p>下面我们讨论一下以太网的信道利用率。<br>假定一个10Mbt&#x2F;s以太网同时有10个站在工作，那么每一个站所能发送数据的平均速率似乎应当是总数据率的1&#x2F;10（即1Mbit&#x2F;s)。其实不然，因为多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到100%。</p><p>图的例子是以太网的信道被占用的情况。一个站在发送帧时出现了碰撞。经过一个争用期2t后（t是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站就发送成功了。假定发送帧需要的时间是T<del>0</del>。它等于帧长(bit)除以发送速率(10Mbit&#x2F;s)。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918131512337.png" class="" title="image-20230918131512337"><p>我们应当注意到，成功发送一个帧需要占用信道的时间是T<del>0</del>+t,比这个帧的发送时间要多一个单程端到端时延t。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是t。因此，必须在经过时间T。+后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p><p>从可看出，要提高以太网的信道利用率，就必须减小t与T<del>0</del>之比。在以太网中定义了参数α，它是以太网单程端到端时延t与帧的发送时间T<del>0</del>之比：</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918131741603.png" class="" title="image-20230918131741603"><p>当α→0时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数α越大，表明争用期所占的比例越大，这就使得每发生一次碰撞就浪费了不少的信道资源，使得信道利用率明显降低。因此，以太网的参数α的值应当尽可能小些。从式可看出，这就要求式分子的数值要小些，而分母T<del>0</del>的数值要大些。这就是说，当数据率一定时，以太网的连线的长度受到限制（否则的数值会太大)，同时以太网的帧长不能太短（否则T<del>0</del>的值会太小，使α值太大）。</p><p>现在考虑一种理想化的情况。假定以太网上的各站发送数据都不会产生碰撞（这显然已经不是CSMA&#x2F;CD,而是需要使用一种特殊的调度方法)，并且能够非常有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是T<del>0</del>+t,而帧本身的发送时间是<del>0</del>。于是我们可计算出极限信道利用率S<del>max</del>为：</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918132017910.png" class="" title="image-20230918132017910"><p>式的意义是：虽然实际的以太网不可能有这样高的极限信道利用率，但式指出了只有当参数α远小于1才能得到尽可能高的极限信道利用率。反之，若参数α远大于1(即每发生一次碰撞，就要浪费相对较多的传输数据的时间)，则极限信道利用率就远小于1,而这时实际的信道利用率就更小了。据统计，当以太网的利用率达到30%时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p><h4 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h4><h5 id="MAC层的硬件地址"><a href="#MAC层的硬件地址" class="headerlink" title="MAC层的硬件地址"></a>MAC层的硬件地址</h5><p>在局域网中，硬件地址又称为物理地址或MAC地址（因为这种地址用在MAC帧中)。</p><p>大家知道，在所有计算机系统的设计中，标识系统(identification system)都是一个核心问题。在标识系统中，地址就是识别某个系统的一个非常重要的标识符。在讨论地址问题时，很多人常常引用著名文献SHOC78给出的如下定义：“<strong>名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处</strong>。”</p><p>这个非形式的定义固然很简单，但有时却不够准确。严格地讲，名字应当与系统的所在地无关。这就像我们每一个人的名字一样，不随我们所处的地点而改变。为此EEE802标准为局域网规定了一种48位的全球地址（一般都简称为“地址”），这就是局域网上的每一台计算机中固化在适配器的ROM中的地址。因此，请特别注意下面两点：</p><ul><li>假定连接在局域网上的一台计算机的适配器坏了而我们更换了一个新的适配器，那么这台计算机的局域网的“地址”也就改变了，虽然这台计算机的地理位置一点也没有变化，所接入的局域网也没有任何改变。</li><li>假定我们把位于南京的某局域网上的一台笔记本电脑携带到北京，并连接在北京的某局域网上。虽然这台电脑的地理位置改变了，但只要电脑中的适配器不变，那么该电脑在北京的局域网中的“地址”仍然和它在南京的局域网中的“地址”一样。</li></ul><p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。我们知道适配器有过滤功能。当适配器从网络上每收到一个MAC帧就先用硬件检查MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源了。这里“发往本站的帧”包括以下三种帧：</p><ul><li>单播(unicast)帧（一对一），即收到的帧的MAC地址与本站的MAC地址相同。</li><li>广播(broadcast)帧（一对全体），即发送给本局域网上所有站点的帧（全1地址）。</li><li>多播(multicast)帧（一对多），即发送给本局域网上一部分站点的帧。</li></ul><p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p><h5 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h5><p>这里介绍使用得最多的以太网V2的MAC帧格式，图中假定网络层使用的是IP协议。实际上使用其他的协议也是可以的。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918133325777.png" class="" title="image-20230918133325777"><p>以太网V2的MAC帧较为简单，由五个字段组成。前两个字段分别为6字节长的<strong>目的地址和源地址字段</strong>。第三个字段是2字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。例如，当类型字段的值是0x0800时，就表示上层使用的是IP数据报。第四个字段是<strong>数据字段</strong>，其长度在46到1500字节之间(46字节是这样得出的：最小长度64字节减去18字节的首部和尾部就得出数据字段的最小长度)。最后一个字段是4字节的**帧检验序列FCS(使用CRC检验)**。当传输媒体的误码率为1×10^-8^时，MAC子层可使未检测到的差错小于1×10^-14^。FCS检验的范围就是整个的MAC帧，从目的地址开始到FCS为止的这五个字段，但不包括物理层插入的8字节的前同步码和帧开始定界符。</p><p>从图可看出，在传输媒体上实际传送的要比MAC帧还多8个字节。这是因为当一个站在刚开始接收MAC帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此MAC帧的最前面的若干位就无法接收，结果使整个的MAC成为无用的帧。为了接收端迅速实现位同步，从MAC子层向下传到物理层时还要在帧的前面插入8个字节（由硬件生成)，它由两个字段构成。第一个字段是7个字节的<strong>前同步码</strong>(1和0交替码)，它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现位同步”（位同步就是比特同步的意思）。第二个字段是<strong>帧开始定界符</strong>，定义为10101011。它的前六位的作用和前同步码一样，最后的两个连续的1就是告诉接收端适配器：“MAC帧的信息马上就要来了，请适配器注意接收。”MAC帧的FCS字段的检验范围不包括前同步码和帧开始定界符。顺便指出，在使用SONET&#x2F;SDH进行同步传输时则不需要用前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p><p>IEEE802.3标准规定凡出现下列情况之一的即为无效的MAC帧：</p><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列FCS查出有差错</li><li>收到的帧的MAC客户数据字段的长度不在46-1500字节之间。考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间。对于检查出的无效MAC帧就简单地丢弃。以太网不负责重传丢弃的帧。</li></ul><h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><h4 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h4><p>扩展以太网更常用的方法是在数据链路层进行的。最初人们使用的是网桥(bridge)。网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所有的端口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个端口，或者是把它丢弃(即过滤)。</p><p>1990年问世的交换式集线器(switching hub),很快就淘汰了网桥。交换式集线器常称为<strong>以太网交换机</strong>(switch)或第二层交换机(L2 switch),强调这种交换机工作在数据链路层。“交换机”并无准确的定义和明确的概念。著名网络专家Perlman认为：“交换机”应当是一个市场名词，而交换机的出现的确使数据的转发更加快速了[PERLO0]。本书也使用这个广泛被接受的名词一以太网交换机。下面简单地介绍以太网交换机的特点。</p><h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><p>以太网交换机实质上就是一个<strong>多端口的网桥</strong>，通常都有十几个或更多的端口，和工作在物理层的转发器、集线器有很大的差别。以太网交换机的每个端口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。以太网交换机还具有并行性，即能同时连通多对端口，使多对主机能同时通信（而网桥只能一次分析和转发一个帧）。相互通信的主机都独<strong>占传输媒体，无碰撞地传输数据</strong>。换句话说，每一个端口和连接到端口的主机构成了一个碰撞域，具有N个端口的以太网交换机的碰撞域共有N个。以太网交换机的端口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。因此，如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的端口繁忙时，发送帧的这两台主机的端口会把收到的帧暂存一下，以后再发送出去。</p><p>以太网交换机是一种即插即用设备，其内部的<strong>帧交换表（又称为地址表）</strong>是通过自<strong>学习算法</strong>自动地逐渐建立起来的。实际上，这种交换表就是一个<strong>内容可寻址存储器</strong>CAM(Content Addressable Memory)。以太网交换机由于使用了专用的交换结构芯片，用硬件转发收到的帧，其转发速率要比使用软件转发的网桥快很多。</p><h5 id="以太网交换机的自学功能"><a href="#以太网交换机的自学功能" class="headerlink" title="以太网交换机的自学功能"></a>以太网交换机的自学功能</h5><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918134848441.png" class="" title="image-20230918134848441"><p>假定在图中的以太网交换机有4个端口，各连接一台计算机，其MAC地址分别是A,B,C和D。交换表最重要的就是两个项目：目的MAC地址和转发端口。在一开始，以太网交换机里面的交换表是空的（如图(a)所示）。</p><p>假定A先向B发送一帧，从端口1进入到交换机。交换机收到帧后，先查找交换表。现在表中没有B的地址。于是，交换机把此帧的源地址A和端口1写入交换表中，并向除端口1以外的所有端口广播这个帧（从端口1收到的帧显然不应再从端口1转发出去）广播发送可以保证让B收到这个帧，而C和D在收到帧后，因目的地址不匹配将丢弃此帧。这一过程也称为过滤。</p><p>由于在交换表中写入了项目(A,1),因此以后不管从哪个端口收到帧，只要其目的地址是A,就把收到的帧从端口1转发出去送交A。这样做的依据是：既然A发送的帧是从端口1进入交换机的，那么从端口1转发出的帧肯定到达A。接下来假定B通过端口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A,表明凡是发给A的帧（即目的地址为A的帧）都应从端口1转发。显然，现在应直接把收到的帧从端口1转发给A,而没有必要再广播收到的帧。交换表这时用源地址B写入一个项目B,3),表明今后如有发送给B的帧，应从端口3转发。</p><p>经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的端口号(2或4)写入交换表中。这样，交换表中的项目就逐渐增多了，以后再转发帧时就可以直接从交换表中找到转发的端口，而不必使用发送广播帧</p><p>考虑到有时可能要在交换机的端口更换主机，或者主机要更换其网络适配器，这就需要及时更改交换表中的项目。为此，当交换表中写入一个项目时就记下当时的时间，只要超过预先设定的时间（例如300秒），该项目就自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。这就是说，图3-25中的交换表实际上是有三列，即MAC地址、端口和写入时间。</p><p>但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。</p><p>为了解决这种兜圈子问题，IEEE的802.lD标准制定了一个生成树协议STP(SpanningTree Protocol)。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>首先，一个以太网是一个广播域。在以太网上经常会出现大量的广播帧。在交换机的交换表的建立过程中要使用许多广播帧。我们经常使用的ARP和DHCP协议（这将在后面两章中讲到)，也都要在以太网中传送很多的广播帧。在一个主机数量很大的以太网上传播广播帧，必然会消耗很多的网络资源。如果网络的配置出了些差错，就有可能发生广播帧在网络中无限制地兜圈子（如图3-26所示那样)，形成了“广播风暴”，使整个的网络瘫痪。</p><p>如果使每一个小部门各拥有自己的较小的局域网，那么这不但可使局域网的广播域范围缩小，同时也提高了局域网的安全性。在以太网交换机出现后，我们可以很方便灵活地建立虚拟局域网VLAN(Virtual LAN)。这样就把一个较大的局域网，分割成为一些较小的局域网，而每一个局域网是一个较小的广播域。</p><p>在IEEE802.1Q标准中，对虚拟局域网VLAN是这样定义的：虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918140522713.png" class="" title="image-20230918140522713"><p>这样的802.1Q帧在什么地方使用呢？我们可以用图给出的简单例子来说明。交换机#1连接了7台计算机，组成了一个局域网（一个广播域）。现在把局域网分为两个虚拟局域网VLAN-10和VLAN-20。这里的10和20是虚拟局域网的编号，由交换机管理人员设定。这个编号就是图3-27中的VID字段的值。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918140858704.png" class="" title="image-20230918140858704"><p>现在我们有了两个较小的广播域。每台计算机都是通过接入<strong>链路</strong>(access link)连接到以太网交换机的。管理人员划分虚拟局域网的方法有多种。例如，按交换机的端口划分，或按MAC地址划分。每台主机并不知道自己的VID值（但交换机必须知道这些信息）。这些主机通过接入链路发送到交换机的帧都是标准的以太网帧。在一个用多个交换机连接起来的较大的局域网中，可以灵活地划分虚拟局域网，不受地理位置的限制。一个虚拟局域网的范围可以跨越不同的交换机。当然，所使用的交换机必须要能够识别和处理虚拟局域网。在图中，在另外一层楼的交换机#2连接了5台计算机，并与交换机#1相连接。交换机#2中的两台计算机加入到VLAN-10,而另外3台加入到VLAN-20。</p><p>这两个虚拟局域网虽然都跨越了两个交换机，但都各自是一个广播域。连接两个交换机端口之间的链路称为汇<strong>聚链路(trunk link)或干线链路</strong>。</p><p>现在假定A向B发送帧。由于交换机#1能够根据帧首部的目的MAC地址，识别B属于本交换机管理的VLAN-10,因此就像在普通以太网中那样直接进行帧的转发，不需要使用VLAN标签。这是最简单的情况。现在假定A向E发送帧。交换机#1查到E并没有连接到本交换机，因此必须从汇聚链路把帧转发到交换机2，但在转发之前，要插入VLAN标签。不插入VLAN标签，交换机#2就不知道应把帧转发给哪一个VLAN。因此在汇聚链路传送的帧是802.1Q帧。交换机#2在向E转发帧之前，要拿走已插入的VLAN标签，因此E收到的帧就是A发送的标准以太网帧，而不是802.1Q帧。图说明了这种情况。如果A向C发送帧，情况又怎样呢？这种情况就复杂些了，因为这是在不同网络之间的通信。虽然A和C都连接到同一个交换机，但它们已经处在不同的网络中(VLAN-10和VLAN-20)。这问题是互连网络中的通信问题，已经超过了本章数据链路层的范围。这要由属于上面的网络层中的路由器来解决。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层(二)</title>
    <link href="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章首先讨论物理层的基本概念。然后介绍有关数据通信的重要概念，以及各种传输媒体的主要特点，但传输媒体本身并不属于物理层的范围。在讨论几种常用的信道复用技术后，对数字传输系统进行简单介绍。最后再讨论几种常用的宽带接入技术。</p><span id="more"></span><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p>首先要强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。大家知道，现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么。用于物理层的协议也常称为物理层<strong>规程</strong>（procedure)。其实物理层规程就是物理层协议。只是在“协议”这个名词出现之前人们就先使用了“规程”这一名词。</p><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：</p><ul><li>机械特性</li></ul><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。平时常见的各种规格的接插件都有严格的标准化的规定。</p><ul><li>电气特性</li></ul><p>指明在接口电缆的各条线上出现的电压的范围。</p><ul><li>功能特性</li></ul><p>指明某条线上出现的某一电平的电压的意义。</p><ul><li>过程特性</li></ul><p>指明对于不同功能的各种可能事件的出现顺序。</p><p>大家知道，数据在计算机内部多采用并行传输方式。但数据在通信线路（传输媒体）上的传输方式一般都是串行传输（这是出于经济上的考虑），即逐个比特按照时间顺序传输。因此物理层还要完成传输方式的转换。具体的物理层协议种类较多。这是因为物理连接的方式很多（例如，可以是点对点的，也可以采用多点连接或广播连接)，而传输媒体的种类也非常之多（如架空明线、双绞线、对称电缆、同轴电缆、光缆，以及各种波段的无线信道等)。因此在学习物理层时，应将重占放在堂据其本概念上。</p><h3 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h3><h5 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h5><p>一个数据通信系统可划分为三大部分，即源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908132617208.png" class="" title="image-20230908132617208"><p>源系统一般包括以下两个部分：</p><ul><li>源点(source)源点设备产生要传输的数据，例如，从计算机的键盘输入汉字，计算机产生输出的数字比特流。源点又称为源站或信源。</li><li>发送器通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。现在很多计算机使用内置的调制解调器（包含调制器和解调器)，用户在计算机外面看不见调制解调器。</li></ul><p>目的系统一般也包括以下两个部分：</p><ul><li>接收器接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li>终点(destination)终点设备从接收器获取传送来的数字比特流，然后把信息输出(例如，把汉字在计算机屏幕上显示出来)。终点又称为目的站或信宿。</li></ul><p>在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统。</p><p>下面我们先介绍一些常用术语</p><p>通信的目的是传送<strong>消息</strong>(message)。话音、文字、图像、视频等都是消息。<strong>数据</strong>(data)是运送消息的实体。根据<strong>RFC4949</strong>给出的定义，数据是使用特定方式表示的信息，通常是有意义的符号序列。这种信息的表示可用计算机或其他机器（或人）处理或产生。<strong>信号</strong>(signal)则是数据的电气或电磁的表现。</p><p>根据信号中代表消息的参数的取值方式不同，信号可分为以下两大类：</p><ul><li>模拟信号，或连续信号——代表消息的参数的取值是连续的。例如在上图中，用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。</li><li>数字信号，或离散信号——代表消息的参数的取值是离散的。例如在上图中，用户家中的计算机到调制解调器之间或在电话网中继线上传送的就是数字信号。在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一种代表1状态。</li></ul><h5 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h5><p>在许多情况下，我们要使用“<strong>信道</strong>(channel)”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条<strong>通信电路</strong>往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li>单向通信</li></ul><p>又称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>线电广播或有线电广播以及电视广播就属于这种类型。</p><ul><li>双向交替通信</li></ul><p>又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式是一方发送另一方接收，过一段时间后可以再反过来。</p><ul><li>双向同时通信</li></ul><p>又称为全双工通信，即通信的双方可以同时发送和接收信息。单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道（每个方向各一条)。显然，双向同时通信的传输效率最高。</p><p>这里注意，有时人们也常用<strong>“单工</strong>”这个名词表示“<strong>双向交替通信</strong>”。如常说的“单工电台”并不是只能进行单向通信。正因为如此，ITU-T才不采用“单工”“半双工”和“全双工”这些容易弄混的术语作为正式的名词。来自信源的信号常称为<strong>基带信号</strong>（即基本频带信号）。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含较多的低频分量，甚至有直流分量，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带<strong>信号进行调制</strong>(modulation)。</p><p>调制可分为两大类。一类是仅仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为<strong>编码</strong>(coding)。另一类调制则需要使用载波(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>(即仅在一段频率范围内能够通过信道)，而使用载波的调制称为<strong>带通调制</strong>。</p><h6 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h6><ul><li><p>不归零制：正电平代表1，负电平代表0。</p></li><li><p>归零制：正脉冲代表1，负脉冲代表0。</p></li><li><p>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。但也可反过来定义。</p></li><li><p>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</p></li></ul><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908134543743.png" class="" title="image-20230908134543743"><p>从信号波形中可以看出，曼彻斯特(Manchester)编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力)，而曼彻斯特编码具有自同步能力。</p><h6 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h6><ul><li>调幅(AM)：即载波的振幅随基带数字信号而变化。例如，0或1分别对应于无载波或有载波输出。</li><li>调频(FM)：即载波的频率随基带数字信号而变化。例如，0或1分别对应于频率f1或f2。</li><li>调相(PM)：即载波的初始相位随基带数字信号而变化。例如，0或1分别对应于相位0度或180度。</li></ul><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908135030466.png" class="" title="image-20230908135030466"><p>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。例如，正交振幅调制QAM(Quadrature Amplitude Modulation)。</p><h5 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h5><p>几十年来，通信领域的学者一直在努力寻找提高数据传输速率的途径这个问题很复杂，因为任何实际的信道都不是理想的，都不可能以任意高的速率进行传送。我们知道，数字通信的优点就是：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要我们从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就可视为无影响。例如，图a表示信号通过实际的信道传输后虽然有失真，但在接收端还可识别并恢复出原来的码元。但图b就不同了，这时信号的失真已很严重，在接收端无法识别码元是1还是0。码元传输的速率越高、信号传输的距离越远、噪声干扰越大或传输媒体质量越差，在接收端的波形的失真就越严重。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908135730608.png" class="" title="image-20230908135730608"><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个。</p><ul><li>信道能够通过的频率范围</li></ul><p>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。像上图所示的发送信号是一种典型的矩形脉冲信号，它包含很丰富的高频分量。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。这样，在接收端收到的信号波形就失去了码元之间的清晰界限。这种现象叫作码间串扰。严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。早在1924年，奈奎斯特(Nyquist)就推导出了著名的<strong>奈氏准则</strong>。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。奈氏准则的推导已超出本书的范围，这可在通信原理教科书中查阅到。这里我们只需要知道奈氏准则的结论，这就是：<strong>在带宽为W(Hz)的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W(码元&#x2F;秒)。传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别)成为不可能。</strong>例如，信道的带宽为4000Hz,那么最高码元传输速率就是每秒8000个码元。</p><ul><li>信噪比</li></ul><p>噪声存在于所有的电子设备和通信信道中。由于噪声是随机产生的，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误(1误判为0或0误判为1)。但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。因此，信噪比就很重要。所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为<strong>S&#x2F;N</strong>。但通常大家都是使用分贝(dB)作为度量单位。即：<br>$$<br>信噪比(dB)&#x3D;10 log_{10}(S&#x2F;N)(dB)<br>$$<br>在1948年，信息论的创始人<strong>香农(<strong>Shannon)推导出了著名的香农公式。香农公式指出：</strong>信道的极限信息传输速率C</strong>是<br>$$<br>C&#x3D;Wlog_2(1+S&#x2F;N)(bit&#x2F;s)<br>$$<br>式中，W为信道的带宽（以Hz为单位），S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。香农公式的推导可在通信原理教科书中找到。这里只给出其结果。</p><p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。香农公式指出了信息传输速率的上限。香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。不过，香农没有告诉我们具体的实现方法。这要由研究通信的专家去寻找。<br>从以上所讲的不难看出，对于频带宽度已确定的信道，如果信噪比也不能再提高了，并且码元传输速率也达到了上限值，那么还有什么办法提高信息的传输速率呢？这就是用编码的方法让<strong>每一个码元携带更多比特的信息量</strong>。</p><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><p><strong>传输媒体</strong>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即<strong>导引型传输媒体</strong>和非导引型传输媒体（这里的“导引型”的英文就是guided,.也可译为“导向传输媒体”)。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播：而非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。</p><h5 id="引导下传输媒体"><a href="#引导下传输媒体" class="headerlink" title="引导下传输媒体"></a>引导下传输媒体</h5><ul><li>双绞线</li></ul><p>双绞线也称为双扭线，是最古老但又是最常用的传输媒体。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合(ws)起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。使用双绞线最多的地方就是到处都有的电话系统。几乎所有的电话都用双绞线连接到电话交换机。这段从用户电话机到交换机的双绞线称为<strong>用户线</strong>或用<strong>户环路</strong>(subscriberloop)。通常将一定数量的这种双绞线捆成电缆，在其外面包上护套。现在的以太网（主流的计算机局域网)基本上也是使用各种类型的双绞线电缆进行连接的。</p><p><strong>无屏蔽双绞线UTP</strong>(Unshielded Twisted Pair)的价格较便宜。当数据的传送速率增高时，可以采用屏蔽双绞线(Shielded Twisted Pair,简称为STP)。</p><ul><li>同轴电缆</li></ul><p>同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及绝缘保护套层所组成。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p><ul><li>光纤</li></ul><p>从20世纪70年代到现在，通信和计算机都发展得非常快。据统计，计算机的运行速度大约每10年提高10倍。在通信领域里，信息的传输速率则提高得更快，从20世纪70年代的56kbit&#x2F;s(使用铜线)提高到现在的数百Gbit&#x2F;s(使用光纤)，并且这个速率还在继续提高。因此，光纤通信成为现代通信技术中的一个十分重要的领域。</p><p>光纤通信就是利用光导纤维（以下简称为光纤）传递光脉冲来进行通信的。有光脉冲相当于1，而没有光脉冲相当于0。由于可见光的频率非常高，约为108MHz的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤的优点，而且还具有其他的一些特点：</p><ul><li>具有通信容量非常大</li><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在现有电缆管道已拥塞不堪的情况下特别有利。</li></ul><h5 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>无线传输可使用的频段很广。从前面给出的图以看出，人们现在已经利用了好几个波段进行通信。紫外线和更高的波段目前还不能用于通信。图2-5的最下面一行还给出了ITU对波段取的正式名称。例如，LF波段的波长是从1km-10km(对应于30kHz-300kHz)。LF,MF和HF的中文名字分别是低频、中频(300kHz-3MHz)和高频(3MHz-30MHz)。更高的频段中的V,U,S和E分别对应于Very,Ultra,Super和Extremely,.相应的频段的中文名字分别是甚高频(30MHz-300MHz)、特高频(300MHz-3GHz)、超高频(3GHz-30GHz)和极高频(30GHz-300GHz),最高的一个频段中的T是Tremendously,目前尚无标准译名。在低频LF的下面其实还有几个更低的频段，如甚低频VLF、特低频ULF、超低频SLF和极低频ELF等，因不用于一般的通信，故未画在图中。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908142801389.png" class="" title="image-20230908142801389"><p>无线电微波通信在当前的数据通信中占有特殊重要的地位。微波的频率范围为300MHz-300GHz(波长1m-1mm),但主要使用2GHz~40GHz的频举范围。微波在空间主要是直线传播，由于地球表面是个曲面，因此其传播距离受到限制，一般只有50k左右。但若采用100m高的天线塔，则传播距离可增大到100km。微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。</p><p>短波通信（即高频通信）主要靠电离层的反射。但电离层的不稳定所产生的衰落现象，以及电离层反射所产生的多径效应，使得短波信道的通信质量较差。当利用无线信道传送数字信号时，必须使误码率（即比特错误率）不大于可容许的范围。下图中的曲线是根据通信理论计算出的，我们这里只需知道有关的三个基本概念。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908151235595.png" class="" title="image-20230908151235595"><ul><li>对于给定的调制方式和数据率，信噪比越大，误码率就越低。这个结论的得出是符合直觉的。当我们在嘈杂的餐厅用餐时，同桌的人可能听不清你说的话。提高嗓门会使说话的效果好些，但太大声说话也会影响周围顾客正常用餐。手机的情况也相似。若提高手机的发射功率，固然可以提高信噪比，但这必将缩短电池的使用时间。若增大电池的体积和重量，又会使手机携带不方便。过大的发射功率，还会干扰临近手机的正常通信，或影响人体健康。可见，如何提高信噪比需要综合考虑。</li><li>对于同样的信噪比，具有更高数据率的调制技术的误码率也更高。例如，当信噪比为10dB时，若采用1Mbit&#x2F;s数据率的二进制相移键控BPSK调制技术，则误码率小于107。但若采用4Mbit&#x2F;s数据率的正交振幅调制16QAM,则误码率为10，己经无法使用了。又如，当信噪比为20dB时，若采用4Mbit&#x2F;s数据率的正交振幅调制16QAM,则误码率小于107。但若采用1Mbit&#x2F;s数据率的二进制相移键控BPSK,则误码率变得非常小，从图中的曲线已无法查到其数值。</li><li>如果移动用户在进行通信时还在不断改变自己的地理位置，就会引起无线信道特性的改变，因而信噪比和误码率都会发生变化。因此，用户的移动设备的物理层应当有一定的自适应能力，可以根据所处的环境特性选择最合适的调制和编码技术，以便在保证容许的误码率的条件下，获得尽可能高的数据传输速率。为实现远距离通信必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站把前一站送来的信号经过放大后再发送到下一站，这种通信方式称为“微波接力”。大多数长途电话业务使用4GHz~6GHz的频率范围。</li></ul><p>常用的卫星通信方法是在地球站之间利用位于约3万6千公里高空的人造同步地球卫星作为中继器的一种微波接力通信。对地静止通信卫星就是在太空的无人值守的微波通信的中继站。可见卫星通信的主要优缺点大体上应当和地面微波通信差不多。卫星通信的最大特点是通信距离远，且通信费用与通信距离无关。同步地球卫星发射出的电磁波能辐射到地球上的通信覆盖区的跨度达1万8千多公里，面积约占全球的三分之一。只要在地球赤道上空的同步轨道上，等距离地放置3颗相隔120度的卫星，就能基本上实现全球的通信。</p><p>卫星通信的另一特点就是具有<strong>较大的传播时延</strong>。由于各地球站的天线仰角并不相同，因此不管两个地球站之间的地面距离是多少（相隔一条街或相隔上万公里），从一个地球站经卫星到另一地球站的传播时延均在250~300ms之间。一般可取为270ms。这和其他的通信有较大差别（请注意：这和两个地球站之间的距离没有什么关系）。对比之下，地面微波接力通信链路的传播时延一般取为3.3us&#x2F;km。请注意，“卫星信道的传播时延较大”并不等于“用卫星信道传送数据的时延较大”。这是因为传送数据的总时延除了传播时延，还有发送时延、处理时延和排队时延等部分。传播时延在总时延中所占的比例有多大，取决于具体情况。但利用卫星信道进行交互式的网上游戏显然是不合适的。在十分偏远的地方，或在离大陆很远的海洋中，要进行通信就几乎完全要依赖于卫星通信。卫星通信还非常适合于广播通信，因为它的覆盖面很广。但从安全方面考虑，卫星通信系统的保密性则相对较差。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概述(一)</title>
    <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>这是对作为一个互联网（网中网）的 Internet 进行概述，讨论 Internet 的组成部分。这个目标的部分内容为介绍协议分层和 TCP&#x2F;IP 协议簇</p><span id="more"></span><h3 id="计算机网络在信息时代中的作用"><a href="#计算机网络在信息时代中的作用" class="headerlink" title="计算机网络在信息时代中的作用"></a>计算机网络在信息时代中的作用</h3><p>Internet的中文译名并不统一。现有的Internet译名有两种：<br>        因特网，这个译名是全国科学技术名词审定委员会推荐的。虽然因特网这个译名较为准确，但却长期未得到推广。本书的前几版都采用因特网这个译名。<br>        互联网，这是目前流行最广的、事实上的标准译名。现在我国的各种报刊杂志、政府文件以及电视节目中都毫无例外地使用这个译名。Internet是由数量极大的各种计算机网络互连起来的，采用互联网这个译名能够体现出Internet最主要的特征。本书从第7版开始，改用“互联网”作为Internet的译名。</p><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>计算机网络（简称为<strong>网络</strong>）由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成。网络中的节点可以是计算机、集线器、交换机或路由器等（在后续的两章我们将会介绍集线器、交换机和路由器等设备的作用)。下图给出了一个具有四个节点和三条链路的网络。我们看到，有三台计算机通过三条链路连接到一个集线器上。这是一个非常简单的计算机网终（可简称为网终)又加在下图中，有多个网悠通过二些路由器相互连接起来，构成了一个覆盖范围更大的计算机网络。这样的网铭称为互连网internetwork或internet)。因此互连网是“网络的网络”(network of networks)甲一朵云表示一个网络的好处，就是可以先不考虑每一个网络中的细节，而是集中精力讨论与这个互连网有关的一些问题。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171508256.png" class="" title="image-20230829171508256"><p>请读者注意，当我们使用一朵云来表示网络时，可能会有两种不同的情况。一种情况如图(a)所示，用云表示的网络已经包含了网络中的计算机。但有时为了讨论问题的方便例如，要讨论几个计算机之间如何进行通信)，也可以把有关的计算机画在云的外面，如下图所示。习惯上，与网络相连的计算机常称为主机（host)。在互连网中不可缺少的路由器，是一种特殊的计筒机（有中央处理器、存储器、操作系统等），但不能称为主机。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171654918.png" class="" title="image-20230829171654918"><p>这样，我们初步建立了下面的基本概念：<br>网络把许多计算机连接在一起，而互连网则把许多网络通过一些路由器连接在一起。与网络相连的计算机常称为主机。</p><h4 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h4><ol><li>第一阶段是从单个网络ARPANET向互连网发展的过程</li><li>第二阶段的特点是建成了三级结构的互联网</li><li>第三阶段的特点是逐渐形成了全球范围的多层次ISP结沟的旦肤网。</li></ol><h4 id="互联网的标准化工作"><a href="#互联网的标准化工作" class="headerlink" title="互联网的标准化工作"></a>互联网的标准化工作</h4><p>制定互联网的正式标准要经过以下三个阶段：</p><ul><li>互联网草案(nternet Draft)一互联网草案的有效期只有六个月。在这个阶段还不能算是RFC文档。</li><li>建议标准(Proposed Standard)一从这个阶段开始就成为RFC文档。</li><li>互联网标准(nternet Standard)一如果经过长期的检验，证明了某个建议标准可以成为互联网标准时，就给它分配一个标准编号，记为STDxx,这里STD是“Standard”的英文缩写，而“xx”是标准的编号（有时也写成4位数编号，如STD0005)。一个互联网标准可以和多个RFC文档关联。</li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul><li>边缘部分:由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829172920816.png" class="" title="image-20230829172920816"><ul><li>核心部分:由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换)</li></ul><h4 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h4><p>我们先要明确下面的概念。我们说：“主机A和主机B进行通信”，实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式(C&#x2F;S方式)和对等方式(P2P方式)下面分别对这两种方式进行介绍。</p><p>1.客户-服务器方式</p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服多和被服务的关系。在下图中，主机A运行客户程序而主机B运行服务器程序。在这种情况下，A是客户而B是服务器。客户A向服务器B发出请求服务，而服务器B向客户A提供服务。这里最主要的特征就是：客户是服务请求方，服务器是服务提供方。<br>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829173123722.png" class="" title="image-20230829173123722">在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点。<p>客户程序：</p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p>服务器程序：</p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般需要有强大的硬件和高级的操作系统支持。客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</li></ul><p>2.对等连接方式</p><p>是指两台主机在通信时，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件(P2P软件)，它们就可以进行平等的对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为P2P方式。</p><p>在下图中，主机C,D,E和F都运行了P2P程序，因此这几台主机都可进行对等通信（如C和D,E和F,以及C和F)。实际上，对等连接方式从本质上看仍然使用客户服务器方式，只是对等连接中的每一台主机既是客户同时又是服务器。例如主机C,当C请求D的服务时，C是客户，D是服务器。但如果C又同时向F提供服务，那么C又同时起着服务器的作用。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174035901.png" class="" title="image-20230829174035901"><h4 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h4><p>网络核心部分是互联网中最复杂的部分，因为网络中的核心部分要向网络边缘部分中的大量主机提供连通性，使边缘部分中的任何一台主机都能够与其他主机通信。在网络核心部分起特殊作用的是<strong>路由器</strong>(router),它是一种专用计算机（但不叫作主机)。路由器是实现<strong>分组交换</strong>(packet switching)的关键构件，其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能。</p><p>1、电路交换的特点</p><p>从通信资源的分配角度来看，<strong>交换</strong>(switching)就是按照某种方式动态地分配传输线路的资源。在使用电路交换打电话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条<strong>专用的物理通路</strong>。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的<br>物理通路（即把刚才占用的所有通信资源归还给电信网）。这种必须经过“<strong>建立连接（占用通信资源)→通适（一直占用通信贪源→释放连接（归还通信资源）</strong>”三个步骤的交换方式称为电路交换。如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后再重新拨号。</p><p>2、分组交换的特点</p><p>分组交换则采用存储转发技术。下图表示把一个报文划分为几个分组后再进行传送。通常我们把要发送的整块数据称为一个<strong>报文</strong>(message)。在发送报文之前，先把较长的报文划分为一个个更小的等长数据段，例如，视频讲解每个数据段为1024bit。在每一个数据段前面，加上一些必要的控制信息组成的首部(header)后，就构成了一个<strong>分组</strong>(packet)。分组又称为“包”，而分组的首部也可称为“包头”。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174914172.png" class="" title="image-20230829174914172"><p>位于<strong>网络边缘部分的主机</strong>和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器则用来转发分组，即进行分组交换。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地（有时会经过几十个不同的路由器）以存储转发的方式，把分组交付最终的<br>目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175504654.png" class="" title="image-20230829175504654"><p>图的最下方归纳了三种交换方式在数据传送阶段的主要特点：</p><ul><li>电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换—整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。</li><li>分组交换—单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175607493.png" class="" title="image-20230829175607493"><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><h4 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h4><p>关于计算机网络的较好的定义是这样的[PETE12]1:计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h4 id="几种不同类别的计算机网络"><a href="#几种不同类别的计算机网络" class="headerlink" title="几种不同类别的计算机网络"></a>几种不同类别的计算机网络</h4><ul><li>按照网络的作用范围进行分类</li></ul><p>广域网WAN(Wide Area Network)广域网的作用范围通常为几十到几千公里，因而有时也称为远程网(long haul network)</p><p>城域网MAN(Metropolitan Area Network)城域网的作用范围一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5~50km。</p><p>局域网LAN(Local Area Network)局域网一般用微型计算机或工作站通过高速通信线路相连（速率通常在10Mbit&#x2F;s以上），但地理上则局限在较小的范围（如1km左右）。</p><p>个人区域网PAN(Personal Area Network)个人区域网就是在个人工作的地方把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络，因此也常称为无线个人区域网WPAN(Wireless PAN),其范围很小，大约在I0m左右。</p><ul><li>按照网络的使用者进行分类</li></ul><p>公用网(public network)这是指电信公司（国有或私有）出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为公众网。</p><p>专用网(private network)这是某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</p><ul><li>用来把用户接入到互联网的网络</li></ul><p>这种网络就是接入网AN(Access Network),它又称为本地接入网或居民接入网</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><ul><li>速率</li></ul><p>计算机发送的信号都是数字形式的。比特(bit)来源于binary digit,意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率,它也称为数据率(data rate)或比特率(bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit&#x2F;s(比特每秒)</p><ul><li>带宽</li></ul><p>“带宽”(bandwidth)有以下两种不同的意义：</p><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。例如，在传统的通信线路上传送的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,即话音的主要成分的频率范围)。这种意义的带宽的单位是赫(或千赫、兆赫、吉赫等)。在过去很长的一段时间，通信的主干线路传送的是模拟信号(即连续变化的信号)。因此，表示某信道允许通过的信号频带范围就称为该信道的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”。在本书中提到“带宽”时，主要是指这个意思。这种意义的带宽的单位就是数据率的单位bit&#x2F;s,是“比特每秒”。</li></ol><ul><li>吞吐量</li><li>时延</li></ul><p>时延(delay或latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或迟延。</p><p>发送时延：发送时延(transmission delay)是主机或路由器发送数据帧所需要的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182020809.png" class="" title="image-20230829182020809"><p>传播时延：是电磁波在信道中传播一定的距离需要花费的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182128702.png" class="" title="image-20230829182128702"><p>处理时延：处理时延主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找转发表等，这就产生了处理时延</p><p>排队时延：排队时延分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><ul><li>时延带宽积</li></ul><p>时延带宽积&#x3D;传播时延×带宽</p><ul><li>往返时间PTT</li></ul><p>在计算机网络中，往返时间RTT(Round-Trip Time)也是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。例如，A向B发送数据。如果数据长度是100MB,发送速率是1O0Mhit&#x2F;s.那么</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194040018.png" class=""><p>假定B正确收完100MB的数据后，就立即向A发送确认。再假定A只有在收到B的确认信息后，才能继续向B发送数据。显然，这就要等待一个往返时间RTT(这里假定确认信息很短，可忽略B发送确认的发送时延)。如果RTT&#x3D;2s,那么可以算出A向B发送数据的有效数据率。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194236316.png" class="" title="image-20230829194236316"><ul><li>利用率</li></ul><h4 id="计算机网络的非性能特征"><a href="#计算机网络的非性能特征" class="headerlink" title="计算机网络的非性能特征"></a>计算机网络的非性能特征</h4><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于维护和管理</li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h4><h6 id="网络协议三个要素组成："><a href="#网络协议三个要素组成：" class="headerlink" title="网络协议三个要素组成："></a>网络协议三个要素组成：</h6><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：即事件实现顺序的详细说明</li></ul><h6 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h6><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194710875.png" class="" title="image-20230829194710875"><ul><li>应用层(application layer)</li></ul><p>应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程就是指主机中正在运行的程序。对于不同的网络应用需要有不同的应用层协议。互联网中的应用层协议很多，如域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议，等等。我们把应用层交互的数据单元称为报文(message)。</p><ul><li>运输层(transport layer)</li></ul><p>运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。所谓“通用的”，是指并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议：</p><ol><li>传输控制协议TCP(Transmission Control Protocol)提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。</li><li>用户数据报协议UDP(User Datagram Protocol)—提供无连接的尽最大努力(besteffort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。</li></ol><ul><li>网络层(network layer)</li></ul><p>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用P协议，因此分组也叫作P数据报，或简称为数据报。本书把“分组”和“数据报”作为同义词使用。请注意：不要将运输层的“用户数据报协议UDP”和网络层的“IP数据报”弄混。此外，无论在哪一层传送的数据单元，都可笼统地用“分组”来表示。</p><ul><li>数据链路层(data link layer)</li></ul><p>数据链路层常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing),在两个相邻节点间的链路上传送帧(frame)。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p><ul><li>物理层(physical layer)</li></ul><p>在物理层上所传数据的单位是比特。发送方发送1（或0）时，接收方应当收到1（或0)而不是0（或1）。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。当然，解释比特代表的意思，不是物理层的任务。请注意，传递信息所利用的一些物理传输媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而是在物理层协议的下面。因此也有人把物理层下面的物理传输媒体当作第0层。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829195444407.png" class="" title="image-20230829195444407"> <h4 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h4><ul><li>实体：实体(entity)这一较为抽象的名词表示任何可发送或接收信息的硬件或软件进程。在许多情况下，实体就是一个特定的软件模块。</li><li>协议：协议是控制两个对等实体（或多个实体)进行通信的规则的集合。</li></ul><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</p><p>首先，协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。也就是说，下面的协议对上面的实体是透明的。其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体“看得见”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>在同一系统中相邻两层的实体进行交互（即交换信息）的地方，通常称为服务访问点SAP(Service Access Point)。服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口，有点像邮政信箱（可以把邮件放入信箱和从信箱中取走邮件），但这种层间接口和两个设备之间的硬件接口（并行的或串行的）并不一样。OSI把层与层之间交换的数据的单位称为服务数据单元SDU(Service Data Unit),它可以与PDU不一样。例如，可以是多个SDU合成为一个PDU,也可以是一个SDU划分为几个PDU。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200113587.png" class="" title="image-20230829200113587"><h4 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP&#x2F;IP的体系结构"></a>TCP&#x2F;IP的体系结构</h4><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200230496.png" class="" title="image-20230829200230496">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机的运算方法(五)</title>
    <link href="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍参与运算的各类数据（包括无符号数和有符号数、定点数和浮点数等)，以及它们在计算机中的算术运算方法。</p><span id="more"></span><h3 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h3><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>计算机中的数均放在寄存器中，通常称寄存器的位数为机器字长。所谓无符号数，即没有符号的数，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。以机器字长为16位为例，无符号数的表示范围为0-65535，而有符号数的表示范围为-32768~+32767</p><h4 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h4><h6 id="1-机器数与真值"><a href="#1-机器数与真值" class="headerlink" title="1.机器数与真值"></a>1.机器数与真值</h6><p>对有符号数而言，符号的“正”、“负”机器是无法识别的，但由于“正”、“负”恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。</p><h6 id="2-原码表示法"><a href="#2-原码表示法" class="headerlink" title="2.原码表示法"></a>2.原码表示法</h6><p>原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为带符号的绝对值表示。</p><p>原码表示简单明了，并易于和真值转换。但用原码进行加减运算时，却带来了许多麻烦。例如，当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。运算步骤既复杂又费时，而且本来是加法运算却要用减法器实现。那么能否在计算机中只设加法器，只作加法操作呢？如果能找到一个与负数等价的正数来代替该负数，就可把减法操作用加法代替。而机器数采用补码时，就能满足此要求。</p><h6 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="3.反码表示法"></a>3.反码表示法</h6><p>正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变</p><p>4.补码表示</p><p>补码：正数的补码与原码一致，负数的补码是该数的反码加1</p><table><thead><tr><th>真值</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>+0.1011（小数）</td><td>0.1011</td><td>0.1011</td><td>0.1011</td></tr><tr><td>-0.1011（小数）</td><td>1.1011</td><td>1.0100</td><td>1.0101</td></tr><tr><td>+1100（整数）</td><td>0，1100</td><td>0，1100</td><td>0，1100</td></tr><tr><td>-1100（整数）</td><td>1，1100</td><td>1，0011</td><td>1，0100</td></tr></tbody></table><p>综上所述，三种机器数的特点可归纳如下：</p><ul><li>三种机器数的最高位均为符号位。符号位和数值部分之间可用“.”（对于小数）或“，”(对于整数)隔开。</li><li>当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同。</li><li>当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”。</li></ul><p>列出了8位寄存器中所有二进制代码组合与无符号数、原码、补码和反码所代表的真值的对应关系</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906130657434.png" class="" title="image-20230906130657434"><p>由此可得出一个结论：由于“苓”在补码中只有一种表示形式，故补码比原码和反码可以多表示一个负数。</p><h6 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906131249269.png" class="" title="image-20230906131249269"><p>进一步观察发现，同一个真值的移码和补码仅差一个符号位，若将补码的符号位由“0”改为“1”,或从“1”改为“0”，即可得该真值的移码。表列出了真值、补码和移码的对应关系。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906131448857.png" class="" title="image-20230906131448857"><h3 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h3><h4 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h4><p>小数点固定在某一位置的数为定点数，有以下两种格式。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906131903561.png" class="" title="image-20230906131903561"><p>当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数决定了定点机中数的表示范围。</p><p>在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。</p><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><p>浮点数的表示<br>$$<br>N&#x3D;S×r^j<br>$$<br>式中，S为尾数（可正可负），j为阶码（可正可负），r是基数（或基值）。在计算机中，基数可取2，<br>4、8或16等。</p><p>浮点数在机器中的形式如下所示。采用这种数据格式的机器称为浮点机。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906133321911.png" class="" title="image-20230906133321911"><p>浮点数由阶码j和尾数S两部分组成。阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围及小数点的实际位置；尾数是小数，其位数反映了浮点数的精度；尾数的符号Sf代表浮点数的正负</p><h6 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h6><p>以通式N&#x3D;S×r^j为例，设浮点数阶码的数值位取m位，尾数的数值位取n位，当浮点数为非规格化时</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906133656953.png" class="" title="image-20230906133656953"><p>一且浮点数的位数确定后，合理分配阶码和尾数的位数，直接影响浮点数的表示范围和精度。通常对于短实数（总位数为32位），阶码取8位（含阶符1位），尾数取24位（含数符1位）；对于长实数（总位数为64位），阶码取11位（含阶符1位），尾数取53位（含数符1位）；对于临时实数（总位数为80位），阶码取15位（含阶符1位），尾数取65位（含数符1位）。</p><h6 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h6><p>为了提高浮点数的精度，其尾数必须为规格化数。如果不是规格化数，就要通过修改阶码并同时左右移尾数的办法，使其变成规格化数。将非规格化数转换成规格化数的过程称为规格化。对于基数不同的浮点数，因其规格化数的形式不同，规格化过程也不同。</p><p>r &#x3D; 2 尾数最高位为 1 </p><p>r &#x3D; 4 尾数最高2位不全为 0 </p><p>r &#x3D; 8 尾数最高3位不全为 0</p><ul><li>当基数为2时，尾数最高位为1的数为规格化数。规格化时，尾数左移一位，阶码减1（这种规格化称为向左规格化，简称左规)；尾数右移一位，阶码加1（这种规格化称为向右规格化，简称右规)</li><li>当基数为4时，尾数的最高两位不全为零的数为规格化数。规格化时，尾数左移两位，阶码减1：尾数右移两位，阶码加1。</li><li>当基数为8时，尾数的最高三位不全为零的数为规格化数。规格化时，尾数左移三位，阶码减1；尾数右移三位，阶码加1。</li></ul><p>基数 r 越大，可表示的浮点数的范围越大 基数不同，浮点数的规格化形式不同 基数 r 越大，浮点数的精度降低</p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p>定点运算包括移位、加、减、乘、除几种。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><h6 id="移位的意义"><a href="#移位的意义" class="headerlink" title="移位的意义"></a>移位的意义</h6><p>移位运算在日常生活中常见。例如，15m可写成1500cm,单就数字而言，1500相当于数15相对于小数点左移了两位，并在小数点前面添了两个0；同样15也相当于1500相对于小数点右移了两位，并删去了小数点后面的两个0。可见，当某个十进制数相对于小数点左移位时，相当于该数乘以10；右移n位时，相当于该数除以10”。</p><p>移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。</p><h6 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h6><p>对于正数，由于[x]原&#x3D;[x]补&#x3D;[x]反&#x3D;真值，故移位后出现的空位均以0添之。对于负数，由于原码、补码和反码的表示形式不同，故当机器数移位时，对其空位的添补规则也不同。表列出了三种不同码制的机器数（整数或小数均可），分别对应正数或负数移位后的添补规则。必须注意的是：不论是正数还是负数，移位后其符号位均不变，这是算术移位的重要特点。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906141531767.png" class="" title="image-20230906141531767"><ul><li>机器数为正时，不论是左移还是右移，添补代码均为0。</li><li>由于负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添0即可。</li><li>由于负数的反码各位除符号位外与负数的原码正好相反，故移位后所添的代码应与原码相反，即全部添1。</li><li>分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。</li></ul><h6 id="算数移位的硬件实现"><a href="#算数移位的硬件实现" class="headerlink" title="算数移位的硬件实现"></a>算数移位的硬件实现</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906142456879.png" class="" title="image-20230906142456879"><p>算数移位和逻辑移位的区别</p><p>有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。逻辑移位的规则是：逻辑左移时，高位移丢，低位添0：逻辑右移时，低位移丢，高位添0。</p><h4 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h4><p>加减法运算是计算机中最基本的运算，因减法运算可看做被减数加上一个减数的负值，即A一B&#x3D;A+（一B),故在此将机器中的减法运算和加法运算合在.一起讨论。现代计算机中都采用补码作加减法运算。</p><h6 id="补码加减法的公式"><a href="#补码加减法的公式" class="headerlink" title="补码加减法的公式"></a>补码加减法的公式</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906142949477.png" class="" title="image-20230906142949477"><p>即补码表示的两个数在进行加法运算时，可以把符号位与数值位同等处理，只要结果不超出机器能表示的数值范围，运算后的结果按2^n+1取模（对于整数）或按2取模（对于小数），就能得到本次加法的运算结果。</p><p>若机器数采用补码，当求A-B时，只需先求[-B]补（称[-B]补为“求补”后的减数)，就可按补码加法规则进行运算。而[-B]补由[B]补连同符号位在内，每位取反，末位加1而得。</p><h6 id="溢出判定"><a href="#溢出判定" class="headerlink" title="溢出判定"></a>溢出判定</h6><ul><li>一位符号位判溢出</li></ul><p>参加操作的 两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作 数的符号不同，即为溢出</p><ul><li>两位符号位判溢出</li></ul><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906144809676.png" class="" title="image-20230906144809676"><h6 id="补码加减法的硬件配置"><a href="#补码加减法的硬件配置" class="headerlink" title="补码加减法的硬件配置"></a>补码加减法的硬件配置</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906144900824.png" class="" title="image-20230906144900824"><p>图中寄存器A、X、加法器的位数相等，其中A存效被加数（或被减数）的补码，X存放加数(或减数)的补码。当作减法时，由“求补控制逻辑”将X送至加法器，并使加法器的最末位外来进位为1，以达到对减数求补的目的。运算结果溢出时，通过溢出判断电路置“1”溢出标记V。G为加法标记，Gs为减法标记。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230906145455941.png" class="" title="image-20230906145455941"><h4 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h4><p>在计算机中，乘法运算是一种很重要的运算，有的机器由硬件乘法器直接完成乘法运算，有的机器内没有乘法器，但可以按机器作乘法运算的方法，用软件编程实现。因此，学习乘法运算方法不仅有助于乘法器的设计，也有助于乘法编程。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907132124668.png" class="" title="image-20230907132124668"><p>可见，这里包含着被乘数A的多次左移，以及4个位积的相加运算。<br>若计算机完全模仿笔算乘法步骤，将会有两大困难：其一，将4个位积一次相加，机器难以实现；其二，乘积位数增长了一倍，这将造成器材的浪费和运算时间的增加。为此，对笔算乘法进行改进。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907132311831.png" class="" title="image-20230907132311831"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907133118854.png" class="" title="image-20230907133118854"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907133319912.png" class="" title="image-20230907133319912"><p>上述运算过程可归纳如下：</p><ul><li>乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。</li><li>由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，由次低位作新的末位，空出最高位放部分积的最低位。</li><li>每次做加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置。计算机很容易实现这种运算规则。用一个寄存器存放被乘数，一个寄存器存放乘积的高位，另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。</li></ul><h6 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h6><p>由于原码表示与真值极为相似，只差一个符号，而乘积的符号又可通过两数符号的逻辑异或求得，因此，上述讨论的结果可以直接用于原码一位乘，只需加上符号位处理即可。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134154514.png" class="" title="image-20230907134154514"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134437551.png" class="" title="image-20230907134437551"><h6 id="原码一位乘所需的硬件配置"><a href="#原码一位乘所需的硬件配置" class="headerlink" title="原码一位乘所需的硬件配置"></a>原码一位乘所需的硬件配置</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134722507.png" class="" title="image-20230907134722507"><p>图中A、X、Q均为+1位的寄存器，其中X存放被乘数的原码，Q存放乘数的原码。移位和加控制电路受末位乘数Q。的控制（当Q.&#x3D;1时，A和X内容相加后，A、Q右移一位；当Q&#x3D;0时，只作A、Q右移一位的操作)。计数器C用于控制逐位相乘的次数。S存放乘积的符号。G为乘法标记。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907134924199.png" class="" title="image-20230907134924199"><h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907175018650.png" class="" title="image-20230907175018650"> 其特点可归纳如下：<ul><li>每次上商都是由心算来比较余数（被除数)和除数的大小，确定商为“1”还是“0”。</li><li>每做一次减法，总是保持余数不动，低位补0，再减去右移后的除数。</li><li>上商的位置不固定。</li><li>商符单独处理。</li></ul><p>如果将上述规则完全照搬到计算机内，实现起来有一定困难，主要问题如下：</p><ul><li>机器不能“心算”上商，必须通过比较被除数（或余数）和除数绝对值的大小来确定商值，即|x|-|y|,若差为正（够减）上商1，差为负（不够减）上商0。</li><li>按照每次减法总是保持余数不动低位补0，再减去右移后的除数这一规则，则要求加法器的位数必须为除数的两倍。仔细分析发现，右移除数可以用左移余数的方法代替，其运算结果是一样的，但对线路结构更有利。不过此刻所得到的余数不是真正的余数，只有将它乘上2“才是真正的余数。</li><li>笔算求商时是从高位向低位逐位求的，而要求机器把每位商直接写到寄存器的不同位置也是不可取的。计算机可将每一位商直接写到寄存器的最低位，并把原来的部分商左移一位，这样更有利于硬件实现。综上所述便可得原码除法运算规则。</li></ul><h5 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h5><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907180627287.png" class="" title="image-20230907180627287"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907180807171.png" class="" title="image-20230907180807171"><h6 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h6><p>恢复余数法的特点是：当余数为负时，需加上除数，将其恢复成原来的余数。</p><p>由上所述，商值的确定是通过比较被除数和除数的绝对值大小，即**[x*]补—[y*]<strong>补实现的，而计算机内只设加法器，故需将</strong>[x*]补—[y*]补** 操作变为**[x*]补+[一y*]**补的操作。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907181417188.png" class="" title="image-20230907181417188"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907181435758.png" class="" title="image-20230907181435758"><h6 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190034295.png" class="" title="image-20230907190034295"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190114504.png" class="" title="image-20230907190114504"><ul><li>上商n+1次</li><li>第一次上商判溢出</li><li>移n次，加n+1次</li><li>用移位的次数判断除法是否结束</li></ul><h6 id="原码加减交替法所需的硬件配置"><a href="#原码加减交替法所需的硬件配置" class="headerlink" title="原码加减交替法所需的硬件配置"></a>原码加减交替法所需的硬件配置</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190801544.png" class="" title="image-20230907190801544"><p>除法开始前，Q寄存器被清零，准备接收商，被除数的原码放在A中，除数的原码放在X中，计数器C中存放除数的位数。除法开始后，首先通过异或运算求出商符，并存于S。接着将被除数和除数变为绝对值，然后开始用第一次上商判断是否溢出。若溢出，则置溢出标记V为1，停止运算，进行中断处理，重新选择比例因子；若无溢出，则先上商，接着A、Q同时左移一位，然后再根据上一次商值的状态，决定是如还是减除数，这样重复次后，再上最后一次商（共上商n+1次)，即得运算结果。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907190927432.png" class="" title="image-20230907190927432"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907191002919.png" class="" title="image-20230907191002919"><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>机器中任何一个浮点数都可写成</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230908160307301.png" class="" title="image-20230908160307301"><p>的形式。其中，S,为浮点数的尾数，一般为绝对值小于1的规格化数（补码表示时允许为-1），机器中可用原码或补码表示：，为浮点数的阶码，一般为整数，机器中大多用补码或移码表示；”为浮点数的基数，常用2、4、8或16表示。以下以基数为2进行讨论。</p><h5 id="浮点加减法运算"><a href="#浮点加减法运算" class="headerlink" title="浮点加减法运算"></a>浮点加减法运算</h5><p>设两个浮点数</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230908160404208.png" class="" title="image-20230908160404208"><p>由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。</p><ul><li>对阶，使两数的小数点位置对齐。</li><li>尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。</li><li>规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。</li><li>舍入，为提高精度，要考虑尾数右移时丢失的数值位。</li><li>溢出判断，即判断结果是否溢出。</li></ul><h6 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h6><p>对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此；首先要求出阶差，再按小阶向大阶看齐的原则，使阶小的尾数向右移位，每右移一位，阶码加1，直到两数的阶码相等为止。右移的次数正好等于阶差。尾数右移时可能会发生数码丢失，影响精度。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907192128330.png" class="" title="image-20230907192128330"><h6 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h6><p>将对阶后的两个尾数按定点加（减）运算规则进行运算。</p><h6 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907192712579.png" class="" title="image-20230907192712579"><h6 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h6><p>在对阶和右规过程中，可能出现尾数末位丢失引起误差，需考虑舍入</p><ul><li>0舍1入法</li><li>横置“1”法</li></ul><h6 id="判断溢出"><a href="#判断溢出" class="headerlink" title="判断溢出"></a>判断溢出</h6><p>与定点加减法一样，浮点加减运算最后一步也需判断滋出。在浮点规格化中已指出，当尾数之和（差）出现01.××·×或10.××…×时，并不表示溢出，只有将此数右规后，再根据阶码来判断浮点运算结果是否溢出。若机器数为补码，尾数为规格化形式，并假设阶符取2位，阶码的数值部分取7位，数符取2位，尾数的数值部分取n位，则它们能表示的补码在数轴上的表示范围如图6.14所示。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907193049182.png" class="" title="image-20230907193049182"><h5 id="浮点乘除运算"><a href="#浮点乘除运算" class="headerlink" title="浮点乘除运算"></a>浮点乘除运算</h5><p>两个浮点数相乘，乘积的阶码应为相乘两数的阶码之和，乘积的尾数应为相乘两数的尾数之积。两个浮点数相除，商的阶码为被除数的阶码减去除数的阶码，尾数为被除数的尾数除以除数的尾数所得的商，可用下式描述。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907193337603.png" class="" title="image-20230907193337603"><h3 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h3><p>针对每一种算术运算，都必须有一个相对应的基本硬件配置，其核心部件是加法器和寄存器。当需要完成逻辑运箅时，势必需要配置相应的逻辑电路，而ALU电路是既能完成算术运算又能完成逻辑运算的部件。</p><h5 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h5><p>图ALU框图。图中Ai和Bi为输入变量；ki为控制信号，ki的不同取值可决定该电路作哪一种算术运算或哪一种逻辑运算；Fi是输出函数。<img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907193543006.png" class="" title="image-20230907193543006"></p><h5 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h5><p>随着操作数位数的增加，电路中进位的速度对运算时间的影响也越来越大，为了提高运算速度，本节将通过对进位过程的分析设计快速进位链。</p><h6 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h6><p>并行加法器由若千个全加器组成，如图所示。n+1个全加器级联就组成了一个n+1位的并行加法器。</p><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194049974.png" class="" title="image-20230907194049974"><h6 id="串行进位链"><a href="#串行进位链" class="headerlink" title="串行进位链"></a>串行进位链</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194223481.png" class="" title="image-20230907194223481"><h6 id="并行进位链"><a href="#并行进位链" class="headerlink" title="并行进位链"></a>并行进位链</h6><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194421536.png" class="" title="image-20230907194421536"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194504727.png" class="" title="image-20230907194504727"><img src="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20230907194525634.png" class="" title="image-20230907194525634">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器(三)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此<br>外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。</p><span id="more"></span><h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><h5 id="3-1-1存储器的分类"><a href="#3-1-1存储器的分类" class="headerlink" title="3.1.1存储器的分类"></a>3.1.1存储器的分类</h5><p>按存储介质分类：</p><ul><li>半导体存储器TTL 、MOS</li><li>磁表面存储器    磁头、磁载体</li><li>磁芯存储器        硬磁材料、环中元件</li><li>光盘存储器        激光、磁光材料</li></ul><p>按存取方式分类：</p><p>​存取时间与物理地址无关（随机访问）</p><ul><li>随机存取器       在程序的执行过程中可读可写</li><li>只读存储器       在程序的执行过程中只读</li></ul><p>​存取时间与物理地址有关（串行访问）</p><ul><li>顺序存取存储器     磁带</li><li>直接存取存储器     磁盘</li></ul><p>按在计算机中的作用分类：</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114021837.png" class="" title="image-20230828114021837"><h5 id="3-1-2存储器的层次结构"><a href="#3-1-2存储器的层次结构" class="headerlink" title="3.1.2存储器的层次结构"></a>3.1.2存储器的层次结构</h5><ul><li>存储器三个主要特性的关系</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114241506.png" class="" title="image-20230828114241506"><ul><li>缓存 -主存层次和主存 -辅存层次</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114428289.png" class="" title="image-20230828114428289"><h4 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h4><h5 id="3-2-1概述"><a href="#3-2-1概述" class="headerlink" title="3.2.1概述"></a>3.2.1概述</h5><p>主存储器（简称主存）的基本结构已在第1章介绍过。实际上，根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p><h6 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114829534.png" class="" title="image-20230828114829534"><h6 id="主存与CPU的联系"><a href="#主存与CPU的联系" class="headerlink" title="主存与CPU的联系"></a>主存与CPU的联系</h6><p>现代计算机的主存都由半导体集成电路构成，图中的驱动器、译码器和读写电路均制作在存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和CPU芯片可通过总线连接</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115057618.png" class="" title="image-20230828115057618"><p>当要从存储器读出某一信息字时，首先由CPU将该字的地址送到MAR,经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读至数据总线上，至于该信息由MDR送至什么地方，这已不是主存的任务，而是由CPU决定的。若要向主存存入一个信息字时，首先CPU将该字所在主存单元的地址经MAR到地址总线，并将信息字送入MDR,然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写人到对应地址线指出的主存单元中。</p><h6 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h6><p>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写人一个存储字。不同的机器存储字长也不同，为了满足字符处理的需要，常用8位二进制数表示一个字节，因此存储字长都取8的倍数。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370机的字长为32位，它可按字节寻址，即它的每一个存储字包含4个可独立寻址的字节，其地址分配如图所示。字地址是用该字高位字节的地址来表示，故其字地址是4的整数倍，正好用地址码的末两位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115954328.png" class="" title="image-20230828115954328"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120051543.png" class="" title="image-20230828120051543"><p>由图所示，对24位地址线的主存而言，按字节寻址的范围是16M,按字寻址的范围<br>为4M。由图所示，对24位地址线而言，按字节寻址的范围仍为16M,但按字寻址的范<br>围为8M。</p><h6 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h6><ul><li>存储容量：主存 存放二进制代码的总位数<ul><li>存储容量&#x3D;存储单元个数 ×存储字长</li></ul></li><li>存储速度<ul><li>存取时间：存储器的访问时间、读出时间、写入时间</li><li>存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间读周期 写周期</li></ul></li><li>存储器带宽：位&#x2F;秒</li></ul><h5 id="3-2-2半导体存储芯片介绍"><a href="#3-2-2半导体存储芯片介绍" class="headerlink" title="3.2.2半导体存储芯片介绍"></a>3.2.2半导体存储芯片介绍</h5><h6 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120855844.png" class="" title="image-20230828120855844"><ul><li><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读&#x2F;写电路的配合下完成对被选中单元的读&#x2F;写操作。</p></li><li><p>读&#x2F;写电路包括读出放大器和写人电路，用来完成读&#x2F;写操作。</p></li><li><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p></li><li><p>地址线是单向输入的，其位数与芯片容量有关。</p></li><li><p>数据线是双向的（有的芯片可用成对出现的数据线分别作为输入或输出），其位数与芯片可<br>读出或写人的数据位数有关。数据线的位数与芯片容量有关。</p></li><li><p>地址线和数据线的位数共同反映存储芯片的容量。例如，地址线为10根，数据线为4根，测芯片容量为2×4&#x3D;4K位；又如地址线为14根，数据线为1根，则其容量为16K位。</p></li><li><p>控制线主要有读&#x2F;写控制线与片选线两种。不同存储芯片的读&#x2F;写控制线和片选线可以不同。有的芯片的读&#x2F;写控制线共用1根（如2114），有的分用两根（如6264）；有的芯片的片选线用1根（如2114），有的用2根（如6264)。读&#x2F;写控制线决定芯片进行读&#x2F;写操作，片选线用来选择存储芯片。由于半导体存储器是由许多芯片组成的，为此需用片选信号来确定哪个芯片被选中。例如，一个64K×8位的存储器可由32片16K×1位的存储芯片组成，如图所示。但每次读出一个存储字时，只需选中8片。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828122056796.png" class="" title="image-20230828122056796"></li></ul><h6 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h6><p>半导体存储芯片的译码驱动方式有两种：线选法和重合法</p><ul><li>线选法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123207033.png" class="" title="image-20230828123207033"><p>图是一个16×1字节线选法存储芯片的结构示意图。它的特点是用一根字选择线（字线)，直接选中一个存储单元的各位（如一个字节）。这种方式结构较简单，但只适于容量不大的存储芯片。如当地址线为1111时，则第15根字线被选中，对应图4.9中的最后一行8位代码便可直接读出或写人。</p><ul><li>重合法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123235418.png" class=""><p>图是一个1K×1位重合法结构示意图。显然，只要用64根选择线(X、Y两个方向各32根)，便可选择32×32矩阵中的任一位。例如，当地址线为全0时，译码输出X。和Y。有效，矩阵中第0行、第0列共同选中的那位即被选中。由于被选单元是由X、Y两个方向的地址决定的，故称为重合法。当欲构成1K×1字节的存储器时，只需用8片如图4.10所示的芯片即可。</p><h5 id="3-2-3随机存储器"><a href="#3-2-3随机存储器" class="headerlink" title="3.2.3随机存储器"></a>3.2.3随机存储器</h5><h6 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h6><p>存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路，图4.11是一个由6个MOS管组成的基本单元电路。</p><p>图中T1-T4是一个由MOS管组成的触发器基本电路，T5、T6犹如一个开关，受行地址选择信号控制。由T1~T6。这6个M0S管共同构成一个基本单元电路。T7、T8。受列地址选择控制，分别与位线A’和A相连，它们并不包含在基本单元电路内，而是芯片内同一列的各个基本单元电路所共有的。</p><p>假设触发器已存有“1”信号，即A点为高电平。当需读出时，只要使行、列地址选择信号均有效，则使T5、T6、T7、T8均导通，A点高电平通过T6后，再由位线A通过T8作为读出放大器的输入信号，在读选择有效时，将“1”信号读出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904132216809.png" class="" title="image-20230904132216809"><p>写入时不论触发器原状态如何，只要将写入代码送至图的D端，在写选择有效时，经两个写放大器，使两端输出为相反电平。当行、列地址选择有效时，使T5、T6、T7、T8导通，并将A与A’点置成完全相反的电平。这样，就把欲写人的信息写入到该基本单元电路中。如欲写人“1”,即D&#x3D;1,经两个写放大器使位线A为高电平，位线A’为低电平，结果使A点为高，A’点为低，即写人了“1”信息。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904133958930.png" class="" title="image-20230904133958930"><p>2114RAM芯片的结构示意图如图所示。图中存储矩阵由64×64个基本单元电路组成，列I&#x2F;0电路即读&#x2F;写电路。10根地址线分为行地址A8-A3和列地址A9、A2、A1、A0,4根数据线为I&#x2F;O4-I&#x2F;O0,,它们是受输入&#x2F;输出三态门控制的双向总线，当CS和WE均为低电平时，输人三态门打开，I&#x2F;O4-I&#x2F;O0,上的数据即写人到指定地址单元中。当CS为低电平、WE为高电平时，输出三态门打开，列1&#x2F;0电路的输出经片内总线输出至数据线I&#x2F;O4~I&#x2F;O0上。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904134637357.png" class="" title="image-20230904134637357"><p>2114RAM芯片内的存储矩阵结构如图所示。其中每一个小方块均为一个由6个M0S管组成的基本单元电路，排列成64×64矩阵，64列对应64对T7,、T8管。又将64列分成4组，每组包含16列，并与一个读&#x2F;写电路相连，读&#x2F;写电路受WE和CS控制，4个读&#x2F;写电路对应4根数据线I&#x2F;O0-I&#x2F;O4。由图中可见，行地址经译码后可选中某一行；列地址经译码后可选中4组中的对应列，共4列。当对某个基本单元电路进行读&#x2F;写操作时，必须被行、列地址共同选中。例如，当A9-A0为全0时，对应行地址A8-A3为000000，列地址A、A2、A,、A。也为0000，则第0行的第0、16、32、48这4个基本单元电路被选中。此刻，若做读操作，则CS为低电平，WE为高电平，在读&#x2F;写电路的输出端1&#x2F;O1-I&#x2F;O4便输出第0行的第0、16、32、48这4个基本单元电路所存的信息。若做写操作，将写人信息送至I&#x2F;O0-I&#x2F;O4端口，并使CS为低电平、WE为低电平，同样这4个输人信息将分别写入到第0行的第0、16、32、48这4个单元之中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135156790.png" class="" title="image-20230904135156790"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135227371.png" class="" title="image-20230904135227371"><h6 id="动态RAM-DRAM"><a href="#动态RAM-DRAM" class="headerlink" title="动态RAM(DRAM)"></a>动态RAM(DRAM)</h6><p>常见的动态RAM基本单元电路有三管式和单管式两种，它们的共同特点都是靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。电容上的电荷一般只能维持1~2s,因此即使电源不掉电，信息也会自动消失。为此，必须在2s内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。由于它与静态RAM相比，具有集成度更高、功耗更低等特点，目前被各类计算机广泛应用。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135533598.png" class="" title="image-20230904135533598"><p>读出时，先对预充电管T4置一预充电信号（在存储矩阵中，每一列共用一个T4管)，使读数据线达高电平VDD。然后由读选择线打开T2,若T1的极间电容Cg存有足够多的电荷（被认为原存“1”)，使T1导通，则因T2、T1导通接地，使读数据线降为零电平，读出“0”信息。若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，由读出线的高低电平可区分其是读“1”，还是读“0”，只是它与原存信息反相。写入时，将写人信号加到写数据线上，然后由写选择线打开T3,这样，C.便能随输入信息充电（写“1”）或放电（写“0”）。</p><p>为了提高集成度，将三管电路进一步简化，去掉T1,把信息存在电容Cs上，将T2、T3合并成一个管子T,便得到单管M0S动态RAM基本单元电路，如图4.18所示。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904140145043.png" class="" title="image-20230904140145043"><p>读出时，字线上的高电平使T导通，若C,有电荷，经T管在数据线上产生电流，可视为读出“1”。若Cs无电荷，则数据线上无电流，可视为读出“0”。读操作结束时，Cs的电荷已释放完毕，故是破坏性读出，必须再生。写人时，字线为高电平使T导通，若数据线上为高电平，经T管对0，充电，使其存“1”；若数据线为低电平，则C,经T放电，使其无电荷而存“0”。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164519993.png" class="" title="image-20230904164519993"><p>这是一个1K×1位的存储芯片，图中每一小方块代表由3个M0S管组成的动态RAM基本单元电路。它们排列成32×32的矩阵，每列都有一个刷新放大器(用来形成再生信息)和一个预充电管（图中未画），芯片有10根地址线，采用重合法选择基本单元电路。</p><p>读出时，先置以预充电信号，接着按行地址A9-A5经行译码器给出读选择信号，同时由列地址A4~A0。经列译码器给出列选择信号。只有在行、列选择信号共同作用下的基本单元电路才能将其信息经读数据线送到读&#x2F;写控制电路，并从数据线D输出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164942057.png" class="" title="image-20230904164942057"><p>写入时，在受行地址控制的行译码器给出的写选择信号的作用下；选中芯片的某一行，并在列地址的作用下，由列译码器的输出控制读&#x2F;写控制电路，只将数据线D的信息送到被选中列的写数据线上，信息即被写人到行列共同选中的基本单元电路中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165055182.png" class="" title="image-20230904165055182"><p>16K×1位的存储芯片共有16K个单管M0S基本单元电路，它们排列成128×128的矩阵，如图所示。图中的行线就是图4.18中的字线，列线就是图4.18中的数据线。128行分布在读放大器的左、右两侧（左侧为0<del>63行，右侧为64</del>127行）。每根行选择线与128个M0S管的栅极相连。128列共有128个读放大器，它的两侧又分别与64个M0S管相连，每根列线上都有一个列地址选择管。128个列地址选择管的输出又互相并接在一起与I&#x2F;0缓冲器相连，I&#x2F;0缓冲器的一端接输出驱动器，可输出数据；另一端接输入器，供数据输入</p><p>读出时，行、列地址受RAS和CAS控制，分两次分别存人行、列地址缓存器。行地址经行译码后选中一行，使该行上所有的M0S管均导通，并分别将其电容C,上的电荷反映到128个读放大器的某一侧（第0-63行反映到读放大器的左侧，第64-127行反映到读放大器的右侧）。读放大器的工作原理像一个撬撬板电路，类似于一个触发器，其左右两侧电平相反。此外列地址经列译码后选中某一列，该列上的列地址选择管导通，即可将读放大器右侧信号经读&#x2F;写线、I&#x2F;0缓冲器输出至Dout端。例如，选中第63行、第0列的单管MOS电路，若其C。有电荷为“1”状态，则反映到第0列读放大器的左侧为“1”，右侧为“0”，经列地址选择管输出至Dout为0，与原存信息反相。同理，第0-62行经读放大器至输出线Dout的信息与原存信息均反相。而读出第64~127行时，因它们的电容C。上的电荷均反映到读放大器的右侧，故经列地址选择管输出至Dout的信息均同相。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165802445.png" class="" title="image-20230904165802445"><p>写人时，行、列地址也要分别送人芯片内的行、列地址缓存器，经译码可选中某行、某列。输入信息D通过数据输人器，经I&#x2F;0缓冲器送至读&#x2F;写线上，但只有被选中的列地址选择管导通，可将读&#x2F;写线上的信息送至该列的读放大器右侧，破坏了读放大器的平衡，使读放大器的右侧与输人信息同相，左侧与输入信息反相，读放大器的信息便可写入到选中行的C,中。例如，选中第64行、第127列，输入信息为“1”，则第127列地址选择管导通，将“1”信息送至第127列的读放大器的右侧。虽然第64行上的128个M0S管均导通，但惟有第64行、第127列的M0S管能将读放大器的右侧信息“1”对C,充电，使其写入“1”。值得注意的是写人读放大器左侧行的信息与输入信息都是反相的，而由读出过程分析又知，对读放大器左侧行进行读操作时，读出的信息也是反相的，故最终结果是正确的。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165825227.png" class="" title="image-20230904165825227"><h6 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h6><p>由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的渎&#x2F;写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2s,这个时间称为刷新周期，又称再生周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证动态RAM内的信息不丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。</p><ul><li>集中刷新</li></ul><p>集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读&#x2F;写操作。例如，对128×128矩阵的存储芯片进行刷新时，若存取周期为0.55，刷新周期为2s(占4000个存取周期)，则对128行集中刷新共儒64us(占128个存取周期)，其余的1936s(共3872个存取周期)用来读&#x2F;写或维持信息，如图所示。由于在这64us时间内不能进行读&#x2F;写操作，故称为“死时间”，又称访存“死区”，所占比率28&#x2F;4000×100%&#x3D;3.2%,称为死时间率。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170137608.png" class="" title="image-20230904170137608"><ul><li>分散刷新</li></ul><p>分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期tc分成两段，前半段tm用来读&#x2F;写或维持信息，后半tr段用来刷新，即c&#x3D;tm+tr。若读&#x2F;写周期为0.5us,则存取周期为1s。仍以128×128矩阵的存储芯片为例，刷新按行进行，每隔128s就可将存储芯片全部刷新一遍，如图所示。这比允许的间隔2ms要短得多，而且也不存在停止读&#x2F;写操作的死时间，但存取周期长了，整个系统速度降低了。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170449800.png" class="" title="image-20230904170449800"><ul><li>异步刷新</li></ul><p>异步刷新是前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为2s的特点。例如，对于存取周期为0.5us,排列成128×128的存储芯片，可采取在2ms内对128行各刷新一遍，即每隔15.6s(2000s÷128≈15.6s)刷新一行，而每行刷新的时间仍为0.5s,如图所示。这样，刷新一行只停业一个存取周期，但对每行来说，刷新间隔时间仍为2ms,而“死时间”缩短为0.5心8。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170623026.png" class="" title="image-20230904170623026"><h6 id="动态RAM与静态RAM比较"><a href="#动态RAM与静态RAM比较" class="headerlink" title="动态RAM与静态RAM比较"></a>动态RAM与静态RAM比较</h6><p>目前，动态RAM的应用比静态RAM要广泛得多。其原因如下：</p><ul><li>在同样大小的芯片中，动态RAM的集成度远高于静态RAM,如动态RAM的基本单元电路为一个MOS管，静态RAM的基本单元电路可为4~6个MOS管。</li><li>动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少。</li><li>动态RAM的功耗比静态RAM小。</li><li>动态RAM的价格比静态RAM的价格便宜。当采用同一档次的实现技术时，动态RAM的容量大约是静态RAM容量的4-8倍，静态.RAM的存取周期比动态RAM的存取周期快8-16倍，但价格也贵8~16倍。.</li></ul><p>动态RAM也有缺点：</p><ul><li>由于使用动态元件（电容），因此它的速度比静态RAM低。</li><li>动态RAM需要再生，故需配置再生电路，也需要消耗一部分功率。通常，容量不大的高速缓冲存储器大多用静态RAM实现。</li></ul><h5 id="3-2-4只读存储器-ROM"><a href="#3-2-4只读存储器-ROM" class="headerlink" title="3.2.4只读存储器(ROM)"></a>3.2.4只读存储器(ROM)</h5><p>按R0M的原始定义，一且注入原始信息即不能改变，但随着用户的需要，总希望能任意修改ROM内的原始信息。这便出现了PROM、EPROM和EEPROM等。对半导体ROM而言，基本器件为两种：MOS型和TL型。</p><ul><li>掩模ROM(MROM)<ul><li>行列选择线交叉处有MOS管为“1”</li><li>行列选择线交叉处无MOS管为“0”</li></ul></li><li>PROM(一次性编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171603204.png" class="" title="image-20230904171603204"><ul><li>EPROM(多次编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171626849.png" class="" title="image-20230904171626849"><ul><li><p>EEPROM(多次性编程)</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul></li><li><p>Flash Memory(闪速型存储器)</p></li></ul><p>进入到20世纪.80年代，又出现了一种闪速存储器(lash Memory),又称快擦型存储器，它是在EPROM和EEPROM工艺基础上产生的一种新型的、具有性能价格比更好、可靠性更高的可擦写非易失性存储器。它既有EPROM的价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性。它具有整片擦除的特点，其擦除、重写的速度快。一块1M位的闪速存储芯片的擦除、重写时间小于5s,比一般标准的EEPROM快得多，已具备了RAM的功能，可与CPU直接连接。它还具有高速编程的特点，例如，采用快速脉冲编程算法对28256闪速存储芯片每字节的编程时间仅需100s。此外，该器件具有存储器访问周期短，功耗低及与计算机接口简单等优点。</p><h5 id="3-2-5存储器与CPU的连接"><a href="#3-2-5存储器与CPU的连接" class="headerlink" title="3.2.5存储器与CPU的连接"></a>3.2.5存储器与CPU的连接</h5><h6 id="存储芯片的扩展"><a href="#存储芯片的扩展" class="headerlink" title="存储芯片的扩展"></a>存储芯片的扩展</h6><ul><li>位扩展</li></ul><p>位扩展是指增加存储字长，例如，2片1K×4位的芯片可组成1K×8位的存储器，如图所示。图中2片2114的地址线A9-A0,、CS、WE都分别连在一起，其中一片的数据线作为高4位D7-D4,另一片的数据线作为低4位D3~D0。这样，便构成了一个1K×8位的存储器。（10根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172431505.png" class="" title="image-20230904172431505"><ul><li>字扩展</li></ul><p>字扩展是指增加存储器字的数量。例如，用2片1K×8位的存储芯片可组成一个2K×8位的存储器，即存储字增加了一倍，如图所示。在此，将A10用做片选信号。由于存储芯片的片选输入端要求低电平有效，故当A10为低电平时，CS0有效，选中左边的1K×8位芯片；当A10为高电平时，反相后CS1有效，选中右边的1K×8位芯片。（11根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172643451.png" class="" title="image-20230904172643451"><ul><li>位、字扩展</li></ul><p>字、位扩展是指既增加存储字的数量，又增加存储字长。图示意用8片1K×4位的芯片组成4K×8位的存储器。（12根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172920491.png" class="" title="image-20230904172920491"><p>由图中可见，每2片构成一组1K×8位的存储器，4组便构成4K×8位的存储器。地址线A11、A10经片选译码器得到4个片选信号CS0、CS1、CS2、CS3,分别选择其中1K×8位的存储芯片。WE为读&#x2F;写控制信号。</p><h6 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h6><p>存储芯片与CPU芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。</p><ul><li>地址线的连接</li></ul><p>存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU地址线的低位与存储芯片的地址线相连。CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。例如，设CPU地址线为16位A15-A0。,1K×4位的存储芯片仅有10根地址线A9-A0。,此时，可将CPU的低位地址A9-A0与存储芯片地址线A9-A0相连。又如，当用16K×1位存储芯片时，则其地址线有14根A13-A0。,此时，可将CPU的低位地址A13-A0。与存储芯片地址线A13~A0相连。</p><ul><li>数据线的连接</li></ul><p>同样，CPU的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p><ul><li>读&#x2F;写命令线的连接</li></ul><p>CPU读&#x2F;写命令线一般可直接与存储芯片的读&#x2F;写控制端相连，通常高电平为读，低电平为写。有些CPU的读&#x2F;写命令线是分开的，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p><ul><li>片选线的连接</li></ul><p>片选线的连接是CPU与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。片选有效信号与CPU的访存控制信号MREQ(低电平有效)有关，因为只有当CPU要求访存时，才需选择存储芯片。若CPU访问I&#x2F;O，则MRE0为高电平，表示不要求存储器工作。此外，片选有效信号还和地址有关，因为CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。通常需用到一些逻辑电路，如译码器及其他各种门电路，来产生片选有效信号。</p><ul><li>合理选择存储芯片</li></ul><p>合理选择存储芯片主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽重使连线简单方便。</p><h5 id="3-2-6存储器的校验"><a href="#3-2-6存储器的校验" class="headerlink" title="3.2.6存储器的校验"></a>3.2.6存储器的校验</h5><p>在计算机运行过程中，由于种种原因致使数据在存储过程中可能出现差错。为了能及时发现错误并及时纠正错误，通常可将原数据配成汉明编码。</p><h6 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h6><p>任意两组合法代码之间二进制位数的最少差异编码的纠错、检错能力与编码的最小距离有关</p><p>L-1&#x3D;D+C(D&gt;&#x3D;C)</p><ul><li>L:编码的最小距离  L&#x3D;3</li><li>D:检测错误的位数 具有一<strong>位</strong>纠错</li><li>C:纠正错误的位数</li></ul><p>汉明码是具有一位纠错能力的编码</p><h6 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h6><p>汉明码的三要素</p><ul><li>汉明码的组成需增添？位检测位</li></ul><p>$$<br>2^k&gt;&#x3D;n+k+1<br>$$</p><ul><li>检测位的位置?</li></ul><p>$$<br>2^i(i&#x3D;0,1,2,3,……)<br>$$</p><ul><li>检测为的取值？</li></ul><p>检测位的取值与该位所在的检测“小组”中承担的奇偶校验任务有关</p><h5 id="3-2-7提高访存速度的措施"><a href="#3-2-7提高访存速度的措施" class="headerlink" title="3.2.7提高访存速度的措施"></a>3.2.7提高访存速度的措施</h5><p>随着计算机应用领域的不断扩大，处理的信息量越来越多，对存储器的工作速度和容量要求也越来越高。此外，因CPU的功能不断增强，&#x2F;0设备的数量不断增多，致使主存的存取速度已成为计算机系统的瓶颈。可见，提高访存速度也成为迫不及待的任务。为了解决此问题，除了寻找高速元件和采用层次结构以外，调整主存的结构也可提高访存速度。</p><ul><li>单体多字系统</li></ul><p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可以在一个存取周期内，从同一地址取出4条指令，然后再逐条将指令送至CPU执行，即每隔1&#x2F;4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183437547.png" class="" title="image-20230904183437547"><p>图中示意了一个单体四字结构的存储器，每字W位。按地址在一个存取周期内可读出4×W位的指令或数据，使主存带宽提高到4倍。显然，采用这种办法的前提是：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p><ul><li>多体并行系统</li></ul><p>多体并行系统就是采用多体模块组成的存储器。每个模块有相同的容量和存取速度，各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读&#x2F;写电路，它们能并行工作，又能交叉工作。并行工作即同时访问N个模块，同时启动，同时读出，完全并行地工作（不过，同时读出的N个字在总线上需分时传送)。图4.42是适合于并行工作的高位交叉编址的多体存储器结构示意图，图中程序因按体内地址顺序存放（一个体存满后，再存人下一个体），故又有顺序存储之称。显然，高位地址可表示体号，低位地址为体内地址。按这种编址方式，只要合理调动，使不同的请求源同时访问不同的体，便可实现并行工作。例如，当一个体正与CPU交换信息时，另一个体可同时与外部设备进行直接存储器访问，实现两个体并行工作。这种编址方式由于一个体内的地址是连续的，有利于存储器的扩充。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183724260.png" class="" title="image-20230904183724260"><p>下图是按低位交叉编址的多体模块结构示意图。由于程序连续存放在相邻体中，故又有交叉存储之称。显然低位地址用来表示体号，高位地址为体内地址。这种编址方法又称为模M编址(M等于模块数)，表4.3列出了模4交叉编址的地址号。一般模块数M取2的方幂，使硬件电路比较简单。有的机器为了减少存储器冲突，采用质数个模块，例如，我国银河机的M为31,其硬件实现比较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183908836.png" class="" title="image-20230904183908836"><ul><li>高性能存储芯片<ul><li>SDRAM(同步DRAM):在系统时钟的控制下进行读入和写出，CPU无需等待</li><li>RDRAM:有Rambus开发，只要解决存储宽带问题</li><li>带Cache的DRAM:在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</li></ul></li></ul><h4 id="3-3高速缓冲存储器"><a href="#3-3高速缓冲存储器" class="headerlink" title="3.3高速缓冲存储器"></a>3.3高速缓冲存储器</h4><h5 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h5><p>在多体并行存储系统中，由于I&#x2F;O设备向主存请求的级别高于CPU访存，这就出现了CPU等待&#x2F;0设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU的工作效率。为了避免CPU与I&#x2F;O设备争抢访存，可在CPU与主存之间加一级缓存，这样，主存可将CPU要取的信息提前送至缓存，一旦主存在与&#x2F;0设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。从另一角度来看，主存速度的提高始终跟不上CPU的发展。据统计，CPU的速度平均每年改进60%，而组成主存的动态RAM速度平均每年只改进7%，结果是CPU和动态RAM之间的速度间隙平均每年增大50%。例如，100MHz的Pentium处理器平均每10ns就执行一条指令，而动态RAM的典型访问时间为60~120ns。这也希望由高速缓存Cache来解决主存与CPU速度的不匹配问题。</p><p>Cache的出现使CPU可以不直接访问主存，而与高速Cache交换信息。那么，这是否可能呢？通过大量典型程序的分析，发现CPU从主存取指令或取数据，在一定时间内，只是对主存局部地址区域的访问。这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用（如子程序、循环程序和一些常数），即指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性，这就称为程序访问的局部性原理。根据这一原理，很容易设想，只要将CPU近期要用到的程序和数据提前从主存送到Cache,那么就可以做到CPU在一定时间内只访问Cache.。一般Cache采用高速的SRAM制作，其价格比主存贵，但因其容量远小于主存，因此能很好地解决速度和成本的矛盾。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904184832650.png" class="" title="image-20230904184832650"><h6 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h6><p>任何时刻都有一些主存块处在缓存块中。CPU欲读取主存某字时，有两种可能：一种是所需要的字已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字)；另一种是所需的字不在Cache内，此时需将该字所在的主存整个字块一次调入Cache中(Cache与主存之间是字块传送)。如果主存块已调入缓存块，侧称该主存块与缓存块建立了对应关系。</p><p>上述第一种情况为CPU访问Cache命中，第二种情况为CPU访问Cache不命中。由于缓存的块数C远小于主存的块数M,因此，一个缓存块不能惟一地、永久地只对应一个主存块，故每个缓存块需设一个标记，用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位（或m位中的一部分）与缓存块的标记进行比较，以判断所读的信息是否已在缓存中。</p><p>Cache的容量与’块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。命中率是指CPU要访问的信息已在Cache内的比率。</p><h6 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904190947078.png" class="" title="image-20230904190947078"><ul><li>Cache存储体</li></ul><p>Cache存储体以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高。</p><ul><li>地址映射变换机构</li></ul><p>地址映射变换机构是将CPU送来的主存地址转换为Cache地址。由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。而地址变换又与主存地址以什么样的函数关系映射到Cache中（称为地址映射）有关</p><ul><li>替换机构</li></ul><p>当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache.。有关替换算法详见特别需指出的是，Cache对用户是透明的，即用户编程时所用到的地址是主存地址，用户根术不知道这些主存块是否已调入Cache内。因为，将主存块调入Cache的任务全由机器硬件自动完成。</p><ul><li>Cache的读写操作</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904195651008.png" class="" title="image-20230904195651008"><p>写操作比较复杂，因为对Cache块内写人的信息，必须与被映射的主存块内的信息完全一致。当程序运行过程中需对某个单元进行写操作时，会出现如何使Cache与主存内容保持一致的问题。目前主要采用以下几种方法。</p><ul><li>写直达法</li></ul><p>写直达法(Write-through),又称为存直达法（Store-through),即写操作时数据既写入Cache又写入主存。它能随时保证主存和Cache的数据始终一致，但增加了访存次数。</p><ul><li>写回法</li></ul><p>写回法(Write-back),又称为拷回法(Copy-back),即写操作时只把数据写入Cache而不写入主存，但当Cache数据被替换出去时才写回主存。可见写回法Cache中的数据会与主存中的不一致。为了识别Cache中的数据是否与主存一致，Cache中的每一块要增设一个标志位，该位有两个状态：“清”（表示未修改过，与主存一致）和“浊”（表示修改过，与主存不一致)。在Cache替换时，“清”的Cache块不必写回主存，因为此时主存中相应块的内容与Cache块是一致的。在写Cache时，要将该标志位设置为“浊”，替换时此Cache块要写回主存，同时要使标志位为“清”。</p><h6 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h6><p>Cache刚出现时，典型系统只有一个缓存，近年来普遍采用多个Cache。其含义.有两方面：一是增加Cache的级数；二是将统一的Cache变成分立的Cache</p><ul><li>单一缓存和二级缓存：片内Cache、片外Cache</li><li>统一缓存和分立缓存：统一缓存是指指令和数据都存放在同一缓存内的Cache;分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令Cache,一个称为数据Cache。.两种缓存的选用主要考虑如下两个因素。其一，它与主存结构有关，如果计算机的主存是统一的（指令、数据存储在同一主存内），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。其二，它与机器对指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般都采用分立缓存。</li></ul><h5 id="3-3-2-Cache——主存地址映射"><a href="#3-3-2-Cache——主存地址映射" class="headerlink" title="3.3.2 Cache——主存地址映射"></a>3.3.2 Cache——主存地址映射</h5><p>由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射（固定的映射关系)、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。</p><ul><li>直接映射</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201458711.png" class="" title="image-20230904201458711"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201608551.png" class="" title="image-20230904201608551"><p>这种方式的优点是实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。由图可见，主存地址高m位被分成两部分：低c位是指Cace的字块地址，高t位(t&#x3D;m一c)是指主存字块标记，它被记录在建立了对应关系的缓存块的“标记”位中。当缓存接到CPU送来的主存地址后，只儒根据中间c位字段（假设为00…01）找到Cache字块1，然后根据字块1的“标记”是否与主存地址的高t位相符来判断，若符合且有效位为“1”（有效位用来识别Cache存储块中的数据是否有效，因为有时Cache中的数据是无效的，例如，在初始时刻Cache应该是“空”的，其中的内容是无意义的)，表示该Cache块已和主存的某块建立了对应关系（即已命中)，则可根据b位地址从Cace中取得信息；若不符合，或有效位为“0”（即不命中)，则从主存读人新的字块来替代旧的字块，同时将信息送往CPU,并修改Cache“标记”。如果原来有效位为“0”，还得将有效位置成“1”。</p><p>直接映射方式的缺点是不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><ul><li>全相联映射</li></ul><p>全相联映射允许主存中每一字块映射到Cache中的任何一块位置上，如图所示。这种映射方式可以从已被占满的Cache中替换出任一旧字块。显然，这种方式灵活，命中率也更高，缩小了块冲突率。与直接映射相比，它的主存字块标记从t位增加到：t+c位，这就使Cache“标记”的位数增多，而且访问Cache时主存字块标记需要和Cache的全部“标记”位进行比较，才能判断出所访问主存地址的内容是否已在Cache内。这种比较通常采用“按内容寻址”的相联存储器（见附录4A)来完成。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904202232710.png" class="" title="image-20230904202232710"><p>总之，这种方式所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。</p><ul><li>组相联映射</li></ul><p>组相联映射是对直接映射和全相联映射的一种折中。它把Cache分为Q组，每组有R块，并有以下关系：</p><p>i&#x3D;j mod Q</p><p>其中，i为缓存的组好，j为主存的块号。某一主存块按模Q将其映射到级存的第i组内</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904203103631.png" class="" title="image-20230904203103631"><ul><li>直接 ：某一 主存块只能固定映射到某一缓存块 </li><li>全相联 ：某一主存块能映射到任一缓存块</li><li>组相联  ：某一主存块只能映射到某一缓存组中的任一块</li></ul><h5 id="3-3-3替换策略"><a href="#3-3-3替换策略" class="headerlink" title="3.3.3替换策略"></a>3.3.3替换策略</h5><ul><li>先进先出（First-In-First-Out,FIFO）</li></ul><p>FIF0算法选择最早调入Cache的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，开销小，但没有根据访存的局部性原理，故不能提高Cache的命中率。因为最早调人的信息可能以后还要用到，或者经常要用到，如循环程序。</p><ul><li>近期最少使用算法(Least Recently Used,LRU）</li></ul><p>LRU算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它需要随时记录Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU算法的平均命中率比FIFO的高。</p><ul><li>随机法</li></ul><p>随机法是随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块，但它也没有根据访存的局部性原理，故不能提高Cache的命中率。</p><h4 id="3-4辅助存储器"><a href="#3-4辅助存储器" class="headerlink" title="3.4辅助存储器"></a>3.4辅助存储器</h4><h5 id="3-4-1概述"><a href="#3-4-1概述" class="headerlink" title="3.4.1概述"></a>3.4.1概述</h5><p>辅助存储器作为主存的后援设备又称为外部存储器，简称外存，它与主存一起组成了存储器系统的主存一辅存层次。与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。而主存具有速度快、成本高、容量小等特点，而且大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。</p><p>目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。</p><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul><li>不能直接与CPU交换信息</li></ul><h6 id="磁表面存储技术"><a href="#磁表面存储技术" class="headerlink" title="磁表面存储技术"></a>磁表面存储技术</h6><ul><li>记录密度</li><li>存储容量</li><li>平均寻址时间 </li><li>数据传输率 </li><li>误码率 辅存的速</li></ul><h5 id="3-4-2磁记录原理和记录方式"><a href="#3-4-2磁记录原理和记录方式" class="headerlink" title="3.4.2磁记录原理和记录方式"></a>3.4.2磁记录原理和记录方式</h5><ul><li>磁记录原理</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204226140.png" class="" title="image-20230904204226140"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204245123.png" class="" title="image-20230904204245123"><ul><li>磁表面存储器的记录方式</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204359480.png" class="" title="image-20230904204359480"><h5 id="3-4-3硬度磁盘存储器"><a href="#3-4-3硬度磁盘存储器" class="headerlink" title="3.4.3硬度磁盘存储器"></a>3.4.3硬度磁盘存储器</h5><h6 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h6><ul><li>固定磁头和移动磁头 </li><li>可换盘和固定盘</li></ul><h6 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204604155.png" class="" title="image-20230904204604155"><p>硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片3大部分组成</p><ul><li>磁盘驱动器</li></ul><p>磁盘驱动器是主机外的一个独立装置，又称磁盘机。大型磁盘驱动器要占用一个或几个机柜，温盘只是一个比砖还小的小匣子。驱动器主要包括主轴、定位驱动及数据控制等3部分。图示意了磁盘驱动器的主轴系统和定位驱动系统。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204817860.png" class="" title="image-20230904204817860"><ul><li><p>磁盘控制器</p><ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令 </li><li>实现主机和驱动器之间的数据格式转换 </li><li>控制磁盘驱动器读写</li></ul><p>磁盘控制器是主机与磁盘驱动器之间的接口</p></li><li><p>盘片：由硬质铝合金材料制成</p></li></ul><h5 id="3-4-4软磁盘存储器"><a href="#3-4-4软磁盘存储器" class="headerlink" title="3.4.4软磁盘存储器"></a>3.4.4软磁盘存储器</h5><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>高</td><td>低</td></tr><tr><td>磁头</td><td>固定、活动、浮动</td><td>活动</td></tr><tr><td>盘片</td><td>固定盘、盘组 大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>环境</td><td>苛刻</td><td></td></tr></tbody></table><h5 id="3-4-7光盘存储器"><a href="#3-4-7光盘存储器" class="headerlink" title="3.4.7光盘存储器"></a>3.4.7光盘存储器</h5><p>采用光存储技术 采用非磁性介质 采用磁性介质 </p><p>第一代光存储技术 不可擦写</p><p>第二代光存储技术  可擦写</p><h6 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h6><p>只读型和只写一次型 热作用（物理或化学变化）</p><p>可擦写光盘  热磁效应 </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线(二)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章着重介绍系统总线的基本概念及其分类、结构和总线控制，逻辑。要求读者能对系统总<br>线在计算机硬件结构中的地位和作用有所了解。</p><span id="more"></span><h4 id="2-1系统总线的基本概念"><a href="#2-1系统总线的基本概念" class="headerlink" title="2.1系统总线的基本概念"></a>2.1系统总线的基本概念</h4><h5 id="2-1-1什么是总线？"><a href="#2-1-1什么是总线？" class="headerlink" title="2.1.1什么是总线？"></a>2.1.1什么是总线？</h5><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p><h5 id="2-1-2总线上的信息传送"><a href="#2-1-2总线上的信息传送" class="headerlink" title="2.1.2总线上的信息传送"></a>2.1.2总线上的信息传送</h5><p>串行</p><p>并行</p><h4 id="2-2-总线的分类"><a href="#2-2-总线的分类" class="headerlink" title="2.2 总线的分类"></a>2.2 总线的分类</h4><h5 id="2-2-1-片内总线"><a href="#2-2-1-片内总线" class="headerlink" title="2.2.1 片内总线"></a>2.2.1 片内总线</h5><p>片内总线：指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间，寄存器与算逻单元ALU之间都由片内总线连接</p><h5 id="2-2-2-系统总线"><a href="#2-2-2-系统总线" class="headerlink" title="2.2.2 系统总线"></a>2.2.2 系统总线</h5><p>系统总线分三类：数据总线、地址总线、控制总线</p><p>数据总线：用来传输各个功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关</p><p>地址总线：主要用来指出数据总线上的源数据或目的数据在主存单元的地址或I&#x2F;O设备地址，单项传输，与存储地址、I&#x2F;O地址有关</p><p>控制总线：用来发出各种控制信号的传输线，控制信号有输入（存储器读、存储器写、总线允许、中断确认）；控制信号有输出（中断请求、总线请求）</p><p>常见的控制型号如下：</p><ul><li>时钟：用来同步各个操作</li><li>复位：初始化所有部件</li><li>总线请求：表示某部件需获得总线使用权</li><li>总线允许：表示需要获得总线使用权的部件以获得控制权</li><li>中断请求：表示某部件提出中断请求</li><li>中断响应：表示中断请求已被接收</li><li>存储器写：将数据总线上的数据写至存储器的指定单元内</li><li>存储器读：将指定存储单元中的数据读到数据总线上</li><li>I&#x2F;O读：从指定的I&#x2F;O端口将数据读到数据总线上</li><li>I&#x2F;O写：将数据总线上的数据输出到指定的I&#x2F;O端口内</li><li>传输响应:表示数据应被接受，或已将数据送至数据总线上</li></ul><h5 id="2-2-3-通信总线"><a href="#2-2-3-通信总线" class="headerlink" title="2.2.3 通信总线"></a>2.2.3 通信总线</h5><p>通信总线：用于计算机系统之间或计算机系统与其他系统（控制仪表、移动通信等）之间的通信</p><p>传输方式：串行通信总线、并行同行总线</p><p>串行总线：是指数据在单条1位宽的传输线上，一位一位地按顺序分时传送，如1字节的数据，在串行传送中，1字节的数据要通过8此有地位到高位按顺序逐位传输</p><p>并行总线：是指数据在多条并行在1位宽的传输线上，同时由源传送到目的地，如1字节的数据，在并行传送中，要通过8条并行传输线同时由源传送到目的地。</p><h4 id="2-3总线特性及性能指标"><a href="#2-3总线特性及性能指标" class="headerlink" title="2.3总线特性及性能指标"></a>2.3总线特性及性能指标</h4><h5 id="2-3-1-总线的特征"><a href="#2-3-1-总线的特征" class="headerlink" title="2.3.1 总线的特征"></a>2.3.1 总线的特征</h5><ul><li>机型特性：尺寸、形状、管脚数 及排列顺序</li><li>电器特性：传输方向和有效的电平范围</li><li>功能特性：每根传输线的功能</li></ul><p>​功能分类：地址、数据、控制</p><p>​地址总线：用来指出地址码</p><p>​数据总线：用来传递数据</p><p>​控制总线：发出信号控制，既有从CPU发出的如存储器的读&#x2F;写、I&#x2F;O的读&#x2F;写，也有I&#x2F;O向CPU发来的，如中断请求、DMA请求</p><ul><li>时间特性：信号的时序关系</li></ul><h5 id="2-3-2-总线性能指标"><a href="#2-3-2-总线性能指标" class="headerlink" title="2.3.2 总线性能指标"></a>2.3.2 总线性能指标</h5><ul><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟同步&#x2F;异步：同步、不同步</li><li>总线复用：地址线与数据线复用</li><li>信号线数：地址线、数据线、控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、技术</li><li>其他指标：负载能力</li></ul><h5 id="2-3-3总线标准"><a href="#2-3-3总线标准" class="headerlink" title="2.3.3总线标准"></a>2.3.3总线标准</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110537846.png" class="" title="image-20230828110537846"><h4 id="2-4总线结构"><a href="#2-4总线结构" class="headerlink" title="2.4总线结构"></a>2.4总线结构</h4><h5 id="2-4-1-单总线结构"><a href="#2-4-1-单总线结构" class="headerlink" title="2.4.1 单总线结构"></a>2.4.1 单总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110613375.png" class="" title="image-20230828110613375"><h5 id="2-4-2多总线结构"><a href="#2-4-2多总线结构" class="headerlink" title="2.4.2多总线结构"></a>2.4.2多总线结构</h5><p>双总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110652825.png" class="" title="image-20230828110652825"><h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110711335.png" class="" title="image-20230828110711335"><p>三总线的另一结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110728329.png" class="" title="image-20230828110728329"><h5 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110750849.png" class="" title="image-20230828110750849"><h5 id="2-4-3总线结构举例"><a href="#2-4-3总线结构举例" class="headerlink" title="2.4.3总线结构举例"></a>2.4.3总线结构举例</h5><p>传统微型机总线</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110815002.png" class="" title="image-20230828110815002"><p>VL-BUS局部总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110840540.png" class="" title="image-20230828110840540"><p>PCI总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110904069.png" class="" title="image-20230828110904069"><p>多层 PCI 总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110922273.png" class="" title="image-20230828110922273"><h4 id="2-5总线控制"><a href="#2-5总线控制" class="headerlink" title="2.5总线控制"></a>2.5总线控制</h4><h5 id="2-5-1-总线判优控制"><a href="#2-5-1-总线判优控制" class="headerlink" title="2.5.1 总线判优控制"></a>2.5.1 总线判优控制</h5><p>基本概念：</p><ul><li><p>主模块对总线有控制权</p></li><li><p>从模块        响应从主设备发来的总线命令</p></li><li><p>总线判优控制：集中式、分布式</p><p>集中式包括：</p><ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li></ul><p>链式查询方式</p><p>下图为链式查询，图中控制总线有3根线用于总线控制（BS总线忙、BR总线请求、BG总线统一），其中总线同意是串行的一个I&#x2F;O接口送至下一个I&#x2F;O接口。如果BG达到的接口有请求，BG信号就不再往下传，意味着改接口获得了总线的使用全，并建立总线忙BS信号，表示它占用了总线，可见在链式查询中，离总线控制部件最近的设备具有最高的优先级。这种方式的特点是：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，！对电路故障很敏感，且优光级别低的设备可能很难获得请求。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111006976.png" class="" title="image-20230828111006976"><p>计数器定时查询方式</p><p>下图是计数器定时查询方式。与链式查询方式相比，多了一组设备地址线，少了一<br>根总线同意线BG。总线控制部件接到由BR送来的总线请求信号后，在总线未被使用(BS&#x3D;0)<br>的情况下，总线控制部件屮的计数器开始计数，并通过设备地址线.向各设备发出一组地址信号。<br>当某个请求占用总线的设备地址与计数值一致时，便获得总线使用权，此吋终止计数查询。这种<br>方式的特点是：计数可以从“0”开始，此时一且设备的优先次序被固定，设备的优先级就按<br>0,1,…,n的顺序降序排列，而且固定不变；计数也可以从上一次计数的终止点开始，即是一种循<br>环方法，此时设备使用总线的优先级相等；计数器的初始值还可由程序设置，战优先次序可以改变。<br>这种方式对电路故障不如链式查询方式敏感，但增加了控制线（设备地址）数，控制也较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111057390.png" class="" title="image-20230828111057390"><p>​独立亲求方式</p><p>下图是独立请求方式。由图中可见，每一台设备均有一对总线请求线BR,和总线同意线BG:。当设备要求使用总线时，便发出该设备的请求信号。总线挖制部件中有一排队电路，可根据优先次序确定响应哪一台设备的靖求。这种方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），似控制线数量多，总线控删更复杂。链式查询中仪用两根线确定总线使用权属于哪个设备，在计数器查询巾大致用log2 n根线，其中n是允许接纳的最大设备数，而独立请求方式需采用2n根线。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111148122.png" class="" title="image-20230828111148122"><h5 id="1-5-2总线通信控制"><a href="#1-5-2总线通信控制" class="headerlink" title="1.5.2总线通信控制"></a>1.5.2总线通信控制</h5><p>目的：解决通信双方协调配合问题</p><p>总线传输周期：</p><ul><li>中请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者。</li><li>寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与木次传输的从模块。</li><li>传数阶段：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流人目的模块。</li><li>结束阶段：主模块的有关信息均从系统总线上撒除，让出总线使用权。</li></ul><p>总线通信的四种方式：</p><ul><li>同步通信：有统一时标控制数据传送</li><li>异步通信：采用应答方式，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统 总线每个瞬间的潜力</li></ul><p>某个输入设备向CPU传输数据的同步通信（同步式数据输入传输）</p><p>对于读命令，其传输周期如下：</p><ul><li>T1:主模块发地址。</li><li>T2:主模块发读命令。</li><li>T3:从模块提供数据。</li><li>T4:主模块撤销读命令，从模央撤销数据。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111244151.png" class="" title="image-20230828111244151"><p>图中总线传输周期是连接在总线上的两个部件完成一次完整且可靠的信息传输时间，它包<br>含4个时钟周期T1、T2、T3、T4。<br>        CPU在T1上升沿发出地址信息；在T2的上升沿发出读命令；与地址信号相符合的输入设备<br>按命令进行一系列内部操作，且必须在T3的上升沿到来之前将CPU所需的数据送到数据总线<br>上：CPU在T3时钟周期内，将数据线上的信息送到其内部寄存器中；CPU在T4的上升沿撤销读<br>命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。如果总线采用三态驱动<br>电路，则从T4起，数据总线呈浮空状态。</p><p>同步式数据输出传输</p><p>对于写命令，其传输周期如下：</p><ul><li>T1:主模块发地址</li><li>T1.5：主模块提供数据。</li><li>T2：主模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到<br>地址总线所指明的单元中。</li><li>T4：主模块撤销写命令和数据等信号。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111309016.png" class="" title="image-20230828111309016"><p>这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性“同步”，必须在限定时问内完成规定的要求。并对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而市，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏贝活性。</p><p>同步通信一般用于总线长度较短、各部件存取时问比较一致的场合。</p><p>在同步通信的总线系统中，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率。</p><p>异步通信</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111331035.png" class="" title="image-20230828111331035"><p>1、不互锁方式</p><p>主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块<br>已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并<br>且经过一段时问（这段时问的设置对不同设备而言是不同的）确认主模块已收到回答信号后，自<br>动撤销回答信号。可见通信双方并无互锁关系。例如，CPU向主存写信息，CPU要先后给出地<br>址信号、写命令以及写入数据，即采用此种方式。</p><p>2、半互锁方式</p><p>主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系：而<br>从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一<br>段时间后自动撒销其回答信号，无互锁关系。由于一方存在互锁关系，一方不存在互锁关系，故<br>称半互锁方式。例如，在多机系统中，某个CPU需访问共享存储器（供所有CPU访问的存储器）<br>时，该CPU发出访存命令后，必须收到存储器未被占用的回答信号，才能真正进行访存操作。</p><p>3、全互锁</p><p>主模块发出请求信号，必须待从模块回答后再撤销其请求信号；从模块发出回答信号，必须<br>待获知主模块请求信号已撤销后，再撤销其回答信号。双方存在互锁关系，故称为全互锁方式。<br>例如，在网络通信中，通信双方采用的就是全互锁方式。</p><p>半同步通信（同步、异步结合）</p><ul><li>同步:发送方用系统 时钟前沿 发信号；接收方用系统 时钟后沿 判断、识别</li><li>异步：允许不同速度的模块和谐工作，增加一条 “等待”响应信号 WAIT</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828112117228.png" class="" title="image-20230828112117228"><p>以输入数据为例的半通信时序</p><ul><li><p>T1:主模块发出地址信息</p></li><li><p>T2：主模块发出命令</p></li><li><p>T2当WAIT为低电平时，进入等待，Tw的宽度与T的宽度一致。</p></li><li></li><li></li><li></li><li><p>T3:从模块提供数据。</p></li><li><p>T4:主模块撤销读命令，从模块撤销数据。</p></li></ul><p>上述三种通信的共同电：</p><ul><li>主模块发地址、命令占用总线</li><li>从模块准备数据        不占用总线  总线空闲</li><li>从模块向主模块发数据     占用总线</li></ul><p>分离式通信</p><p>以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结束。在整个传输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期，发现除了中请总线这一阶段外，其余时间主要花费在如下3个方面。<br>①主模块通过传输总线向从模块发送地址和命令。<br>②从模块按照命令进行读数据的必要淮备。<br>③从模块经数据总线向主模块提供数据。·<br>由②可见，对系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待，为了克服和利用这种消极等待，尤其在大型计算机系统中，总线的负载已处于饱和状态，充分挖掘系统总线每瞬间的潜力，对提高系统性能起到极大作用。为此人们又提出了“分离式”的通信方式，其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第一个子周期中，主模块A在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号（当有多个主模块时，此编号尤为重要)发到系统总线上，经总线传输后，由有关的从模块B接收下来。主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使州权，以便其他模块使用。在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将A模块所需的数据准备好，使出B模块中请总线使用权，一旦获谁，B模块便将A模块的编号、B模块的地址、A模块所器的数据等一系列信息送到总线上，供A模块接收。很明显，上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。</p><p>分离式通信特点：</p><ul><li>各模块欲占用总线使用权都必须提出申请。</li><li>在得到总线使用权后，主模块在限定的刷间内向对方传送信总，采用同步方式传送，不再等待对方的回答信号。</li><li>各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。</li><li>总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概论(一)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍计算机的组成概貌及工作原理，旨在使读者对计算机总体结构有一个概括的<br>了解，为深入学习后面各章打下基础。</p><span id="more"></span><h4 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h4><h5 id="1-1-1-计算机的软硬件概念"><a href="#1-1-1-计算机的软硬件概念" class="headerlink" title="1.1.1 计算机的软硬件概念"></a>1.1.1 计算机的软硬件概念</h5><p><strong>计算机系统有“硬件”和“软件”两大部分组成。</strong></p><p>​<strong>硬件</strong>：计算机的实体，如主机、外设等</p><p>​<strong>软件</strong>：由具有各类特殊的功能的信息（程序）组成</p><p>软件可以分为</p><p>​<strong>系统软件</strong>：用来管理整个计算机系统 。如 语言处理程序、操作系统、服务型程序、数据库管理系统、网络软件</p><p>​<strong>应用软件</strong>：按任务需要编制成的各种程序</p><h5 id="1-1-2-计算机系统的成层次结构"><a href="#1-1-2-计算机系统的成层次结构" class="headerlink" title="1.1.2 计算机系统的成层次结构"></a>1.1.2 计算机系统的成层次结构</h5><p><strong>方向：M4→M3→M2→M1→M0</strong></p><p>虚拟机器M4(高级语言机器)用编译程序翻译成汇编语言程序</p><p>虚拟机器M3(汇编语言机器)用汇编程序翻译成机器语言程序</p><p>虚拟机器M2(操作系统机器)用机器语言解释操作系统</p><p>传统机器M1(机器语言机器)用微程序解释机器指令</p><p>微程序机器M0(微指令系统)有硬件直接执行微指令</p><h5 id="1-1-3计算机组成和计算机体系结构"><a href="#1-1-3计算机组成和计算机体系结构" class="headerlink" title="1.1.3计算机组成和计算机体系结构"></a>1.1.3计算机组成和计算机体系结构</h5><p><strong>计算机体系结构</strong>：是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。计算机系统的属性通常是指用机器语言编程的程序员所能看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术、I&#x2F;O机理等，大都属于抽象概念</p><p><strong>计算机组成</strong>：是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。例如，指令系统体现了机器的属性，这属于<em>计算机结构</em>的问题。但是指令的实现，即如何取出指令，分析指令，取操作数、运算、送结果等，这些属于<em>计算机组成问题</em></p><h4 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h4><h5 id="1-2-1冯·诺伊曼计算机的特点"><a href="#1-2-1冯·诺伊曼计算机的特点" class="headerlink" title="1.2.1冯·诺伊曼计算机的特点"></a>1.2.1冯·诺伊曼计算机的特点</h5><ul><li>计算机有运算器、存储器、控制器、输入设备、输出设备五大部件组成</li><li>指令和数据以同等的地位存放与存储器内，并可按地址访问</li><li>指令和数据均用二进制数表示</li><li>指令有操作码和地址码组成，操作码可以用来表示操作的性质，地址码可以用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定的条件下，可以根据运算结果或根据设定的条件改变执行的顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ul><h5 id="1-2-2计算机的硬件框图"><a href="#1-2-2计算机的硬件框图" class="headerlink" title="1.2.2计算机的硬件框图"></a>1.2.2计算机的硬件框图</h5><p>典型的冯·诺伊曼计算机解构框图</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201047407.png" class="" title="image-20230827201047407"><p>图中各部件的功能如下：</p><ul><li>运算器用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内</li><li>存储器用来存放数据指令和程序</li><li>控制器用来控制、指挥程序和数据的输入、运行及处理运算结果</li><li>输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有鼠标、键盘等</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等</li></ul><p>由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往集成在同一个芯片上，因此，通常将他们合起来称作中央处理器（Central Processing Unit,CPU）。把输入输出设备简称为I&#x2F;O设备（Input&#x2F;Output Equipment）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201352277.png" class=""><p>主存储器是存储器子系统中的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类成为辅助存储器，简称辅存，又称外存。</p><p>算数逻辑单元（Arithmetic Logic Unit,ALU）简称算逻部件，用来完成算术逻辑运算。</p><p>控制单元（Control Unit ,CU）用来解释存储器中的指令，并发出各种操作命令来执行指令。</p><p>ALU和CU是CPU的核心</p><p>I&#x2F;O设备也受CU控制，用来完成相对应的输入和输出操作</p><h5 id="1-2-3计算机的工作步骤"><a href="#1-2-3计算机的工作步骤" class="headerlink" title="1.2.3计算机的工作步骤"></a>1.2.3计算机的工作步骤</h5><p>用计算机解决问题有两大步骤。一是上机前的准备，另一个是上机运行</p><h6 id="上机前的准备"><a href="#上机前的准备" class="headerlink" title="上机前的准备"></a>上机前的准备</h6><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h6 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202137512.png" class="" title="image-20230827202137512"><h6 id="存储器的基本组成："><a href="#存储器的基本组成：" class="headerlink" title="存储器的基本组成："></a>存储器的基本组成：</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201750247.png" class=""><p>主存储器包括存储体、各种逻辑部件及控制电路，存储体由很多存储单元组成，每个存储单元又包括若干个存储元件，每个存储元件存放一个二进制代码“0”和“1”。一个存储单元可以储存一串二进制代码，称这串二进制代码为一个存储字，这串二进制代码的位数成为存储字长。</p><ol><li>存储单元:存放一串二进制代码</li><li>存储字:存储单元中二进制代码的组合</li><li>存储字长:存储单元中二进制代码的位数 每个存储单元赋予一个地址号</li></ol><p>为了实现按地址访问的形式，主存中还得必须配置两个寄存器MAR和MDR</p><ol><li>MAR:存储器地址寄存器，反映存储单元的个数</li><li>MDR:存储器数据寄存器，反映存储字节长度</li></ol><p>设RAM&#x3D;4 位  MDR&#x3D;8位则 存储单元个数位16个，存储字长为8</p><h6 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h6><p>运算器最少包括三个寄存器和一个算数逻辑单元（ALU）其中ACC是累加器，MQ为乘商寄存器，X为操作数寄存器</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202644280.png" class="" title="image-20230827202644280"><p>M表示存储器的任意地址号，[M]表示对应M地址单元中的内容；X表示X寄存器,[X]表示X寄存器的内容；ACC表示累加器，[ACC]表示累加器中的内容；MQ表示乘商寄存器，[MQ]表示乘商寄存器中的内容</p><p>加法操作过程</p><p>假设ACC已经有前一时刻的运算运算结果，并作为下述运算中的一个操作数</p><p>即将[ACC]中看作被加数，先从主存中取一个存放在M地址号单元的加数[M]，送至运算器的X寄存器中，然后将被加数[ACC]与加数[X]相加，结果(和)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202827546.png" class="" title="image-20230827202827546"><p>减法操作过程</p><p>即将[ACC]中看作被减数，先从主存中取一个存放在M地址号单元的减数[M]，送至运算器的X寄存器中，然后将[ACC]-[X]，结果(差)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202846884.png" class="" title="image-20230827202846884"><p>乘法操作过程</p><p>即将[ACC]看作被乘数，先取出存放在主存M号地址单元中的乘数[M]并送入乘商寄存器MQ,在把被乘数送入X寄存器，并将ACC清“0”,然后[X]和[MQ]相乘，结果（积）的高位保留在ACC中，地位保留MQ中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202907215.png" class="" title="image-20230827202907215"><p>除法操作过程</p><p>即将[ACC]看作被除数，先取出存放在M地址单元内的除数[M]并送至X寄存器，然后[ACC]除以[X]，结果（商）暂留与MQ,[ACC]为余数R。若需要将商保留在ACC中，只需要做一步[MQ]→ACC即可</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202931819.png" class="" title="image-20230827202931819"><p>控制器</p><p>控制器由程序计数器（Program Counter,PC）、指令寄存器（Instruction Register,IR）以及控制单元（CU）组成</p><p>PC：用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路且具有自动加1的功能，即可自动形成下一条指令的地址。</p><p>IR:用来存放当前的指令，IR的内来自主存的MDR。IR中的操作码（OP(IR)）送至CU,记作OP(IR)→CU,用来分析指令；其地址码（Ad(IR)）作为操作数的地址送至存储器的MAR,记作Ad(IR)→MAR。</p><p>CU：用来分析当前的指令所需完成的操作，并发出各种微操作命令序号，用以控制所有被控制对象</p><p>完成一条指令需要三个步骤：取指令、分析指令、执行指令</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203029187.png" class="" title="image-20230827203029187"><p>主机完成一条指令的过程</p><p>取指数为例</p><ol><li><p>PC把指令送给MAR</p></li><li><p>MAR把指令送给存储体</p></li><li><p>在控制器的控制下，把存储体指定存储单元中的那条取数指令取出，并送入MDR中</p></li><li><p>将取出的指令送入IR中</p><hr></li><li><p>把IR的操作码送入CU</p></li><li><p>CU经过译码后，在控制器的控制下，把指令中的地址部分送给存储器，以便数据从存储体中取出</p></li><li><p>MAR将地址送给存储体</p></li><li><p>在控制器的控制之下，把存储体中我们需要取的数送至MDR中</p></li><li><p>然后将MDR的数据送入ACC</p></li></ol><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203302609.png" class="" title="image-20230827203302609"><p>例子：</p><p>首先按下图的有序指令和数据，通过键盘输入到主从第0号至第12号单元中，并置PC的初始值为0（令程序的首选地址为0）。启动机器后，计算机便自动按存储器中所存放的指令顺序有序地逐条完成取指令、分析指令、和执行指令，直至最后一条指令为止。</p><p>例如</p><ul><li>PC→MAR,并命令存储器做读操作，此时0号单元中的内容”0000010000001000”,便被送入到MDR内</li><li>MDR→IR,完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000001”为取数指令</li><li>于是CU将IR中的地址码“0000001000”送至MAR(记作Ad(IR)→MAR),并命令存储器做只读操作</li><li>将地址单元的操作数X送至MDR</li><li>再由MDR中送至ACC中，完成指令的执行过程，此时完成第一条取数指令的全过程，即操作数在X送至运算器ACC中</li><li>PC完成自动加1操作，形成下一条指令的地址“1”</li><li>PC将第二条指令送入MAR中，命令主存储器做只读操作，将“0001000000001001”送入MDR中</li><li>MDR→IR，完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000100”为乘法指令</li><li>CU向存储体发出读命令，取出对应地址为“0000001001”单元的操作数a</li><li>a经MDR送至运算器MQ</li><li>CU在向运算器发送乘法操作命令，完成ax的运算，并把结果ax存放在ACC中</li><li>PC+1→PC,形成下一条指令的地址“2”号</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203825422.png" class="" title="image-20230827203825422">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
