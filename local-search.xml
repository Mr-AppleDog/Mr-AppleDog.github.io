<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring的Xml</title>
    <link href="/2024/03/05/spring%E7%9A%84xml/"/>
    <url>/2024/03/05/spring%E7%9A%84xml/</url>
    
    <content type="html"><![CDATA[<p>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><p>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。</p><span id="more"></span><h3 id="Spring5-的概述"><a href="#Spring5-的概述" class="headerlink" title="Spring5 的概述"></a>Spring5 的概述</h3><ol><li>Spring 是轻量级的开源的 JavaEE 框架 </li><li>Spring 可以解决企业应用开发的复杂性 </li><li>Spring 有两个核心部分：IOC 和 Aop <ul><li>IOC：控制反转，把创建对象过程交给 Spring 进行管理 </li><li>Aop：面向切面，不修改源代码进行功能增强</li></ul></li><li>Spring 特点 <ul><li>方便解耦，简化开发 </li><li>Aop 编程支持 </li><li>方便程序测试 </li><li>方便和其他框架进行整合</li><li>方便进行事务操作 </li><li>降低 API 开发难度</li></ul></li></ol><h4 id="Spring5-入门案例"><a href="#Spring5-入门案例" class="headerlink" title="Spring5 入门案例"></a>Spring5 入门案例</h4><p>目录结构</p><img src="/2024/03/05/spring%E7%9A%84xml/image-20240305214126752.png" class="" title="image-20240305214126752"><p>Xml中注册bean</p><img src="/2024/03/05/spring%E7%9A%84xml/image-20240305214200452.png" class="" title="image-20240305214200452"><p>一个简单的类</p><img src="/2024/03/05/spring%E7%9A%84xml/image-20240305214257836.png" class="" title="image-20240305214257836"><p>测试</p><img src="/2024/03/05/spring%E7%9A%84xml/image-20240305214405979.png" class="" title="image-20240305214405979"><h3 id="IOC概念与原理"><a href="#IOC概念与原理" class="headerlink" title="IOC概念与原理"></a>IOC概念与原理</h3><ol><li>什么是 IOC<ol><li>控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理</li><li>使用 IOC 目的：为了耦合度降低</li><li>做入门案例就是 IOC 实现</li></ol></li><li>IOC 底层原理<ol><li>xml 解析、工厂模式、反射</li></ol></li><li>画图讲解 IOC 底层原理</li></ol><img src="/2024/03/05/spring%E7%9A%84xml/%E5%9B%BE2.png" class="" title="图2"><h4 id="IOC（BeanFactory-接口）"><a href="#IOC（BeanFactory-接口）" class="headerlink" title="IOC（BeanFactory 接口）"></a>IOC（BeanFactory 接口）</h4><ol><li>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂</li><li>Spring 提供 IOC 容器实现两种方式：（两个接口）<ol><li>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 * 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</li><li>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用 * 加载配置文件时候就会把在配置文件对象进行创建</li></ol></li><li>ApplicationContext 接口有实现类</li></ol><img src="/2024/03/05/spring%E7%9A%84xml/image-20240305215126968.png" class="" title="image-20240305215126968"><h3 id="IOC-操作-Bean-管理（概念）"><a href="#IOC-操作-Bean-管理（概念）" class="headerlink" title="IOC 操作 Bean 管理（概念）"></a>IOC 操作 Bean 管理（概念）</h3><ol><li>什么是 Bean 管理（Bean 管理指的是两个操作）<ol><li>Spring 创建对象</li><li>Spirng 注入属性</li></ol></li><li>Bean 管理操作有两种方式<ol><li>基于 xml 配置文件方式实现</li><li>基于注解方式实现</li></ol></li></ol><h3 id="IOC-操作-Bean-管理（基于-xml-方式）"><a href="#IOC-操作-Bean-管理（基于-xml-方式）" class="headerlink" title="IOC 操作 Bean 管理（基于 xml 方式）"></a>IOC 操作 Bean 管理（基于 xml 方式）</h3><h4 id="1、基于-xml-方式创建对象"><a href="#1、基于-xml-方式创建对象" class="headerlink" title="1、基于 xml 方式创建对象"></a>1、基于 xml 方式创建对象</h4><img src="/2024/03/05/spring%E7%9A%84xml/image-20240305215449829.png" class="" title="image-20240305215449829"><ul><li>在Spring的配置文件中使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</li><li>在 bean 标签有很多属性，介绍常用的属性<ul><li>id 属性：唯一标识</li><li>class 属性：类全路径（包类路径）</li></ul></li><li>创建对象时候，默认也是执行无参数构造方法完成对象创建</li></ul><h4 id="2、基于-xml-方式注入属性"><a href="#2、基于-xml-方式注入属性" class="headerlink" title="2、基于 xml 方式注入属性"></a>2、基于 xml 方式注入属性</h4><h5 id="使用set进行注入"><a href="#使用set进行注入" class="headerlink" title="使用set进行注入"></a>使用set进行注入</h5><ol><li>首先写一个类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookName</span><span class="hljs-params">(String bookName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookName = bookName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthor</span><span class="hljs-params">(String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;bookName=&#x27;&quot;</span> + bookName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​2.编写xml文件，并注入属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.Book&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Java&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​3.测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">book</span><span class="hljs-params">()</span>&#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;book.xml&quot;</span>);<br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;book&quot;</span>, Book.class);<br>        System.out.println(book);<br>    &#125;<br><span class="hljs-comment">//结果：Book&#123;bookName=&#x27;Java&#x27;, author=&#x27;张三&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="使用有参构造注入"><a href="#使用有参构造注入" class="headerlink" title="使用有参构造注入"></a>使用有参构造注入</h5><p>1、更改上面的book类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String bookName, String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookName = bookName;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Book&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;bookName=&#x27;&quot;</span> + bookName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, author=&#x27;&quot;</span> + author + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、修改xml 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mysql&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">book</span><span class="hljs-params">()</span>&#123;<br>    ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;book.xml&quot;</span>);<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;book&quot;</span>, Book.class);<br>    System.out.println(book);<br>&#125;<br><span class="hljs-comment">//结果Book&#123;bookName=&#x27;Mysql&#x27;, author=&#x27;李四&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3、xml-注入其他类型属性"><a href="#3、xml-注入其他类型属性" class="headerlink" title="3、xml 注入其他类型属性"></a>3、xml 注入其他类型属性</h4><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;author&quot;</span>&gt;<br>    &lt;<span class="hljs-literal">null</span>/&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><h5 id="属性值包含特殊符号"><a href="#属性值包含特殊符号" class="headerlink" title="属性值包含特殊符号"></a>属性值包含特殊符号</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;property name=<span class="hljs-string">&quot;author&quot;</span>&gt;<br>    &lt;value&gt;&lt;![CDATA[&lt;&lt;张三&gt;&gt;]]&gt;&lt;/value&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><h5 id="注入属性-外部-bean"><a href="#注入属性-外部-bean" class="headerlink" title="注入属性-外部 bean"></a>注入属性-外部 bean</h5><p>​创建两个类 UserService和UserDaoImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test..service&quot;</span>);<br>        userDao.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cxy.dao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test...dao...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建配置文件 （用外联的方式注入一个bean）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    创建UserService对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.service.UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    创建UserDaoImpl对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userService</span><span class="hljs-params">()</span>&#123;<br>    ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;UserService.xml&quot;</span>);<br>    <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>    System.out.println(userService);<br>    userService.test();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">结果</span><br><span class="hljs-comment">com.cxy.service.UserService@cb0ed20</span><br><span class="hljs-comment">test..service</span><br><span class="hljs-comment">test...dao...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="注入属性-内部-bean"><a href="#注入属性-内部-bean" class="headerlink" title="注入属性-内部 bean"></a>注入属性-内部 bean</h5><p>为上述的两个类个添加以私有属性，通过set注入属性值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> String userServiceName;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserServiceName</span><span class="hljs-params">(String userServiceName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userServiceName = userServiceName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test..service&quot;</span>);<br>        userDao.test();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UserService&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;userServiceName=&#x27;&quot;</span> + userServiceName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, userDao=&quot;</span> + userDao +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">private</span> String userDaoImplName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDaoImplName</span><span class="hljs-params">(String userDaoImplName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userDaoImplName = userDaoImplName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test...dao...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UserDaoImpl&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;userDaoImplName=&#x27;&quot;</span> + userDaoImplName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编写xml 用set 方式注入一个bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.service.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userServiceName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;serviceTest&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDaoImplName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;daoTest&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="注入属性-级联赋值"><a href="#注入属性-级联赋值" class="headerlink" title="注入属性-级联赋值"></a>注入属性-级联赋值</h5><p>将{注入属性-内部 bean}的xml 改为下面这种</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    创建UserService对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.service.UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userServiceName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;serviceTest&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    创建UserDaoImpl对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDaoImplName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;daoTest&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4、xml-注入集合属性"><a href="#4、xml-注入集合属性" class="headerlink" title="4、xml 注入集合属性"></a>4、xml 注入集合属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span> &#123;<br>    <span class="hljs-comment">//数组</span><br>    <span class="hljs-keyword">private</span> String[] courses;<br>    <span class="hljs-comment">//列表</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list;<br>    <span class="hljs-comment">//map</span><br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; maps;<br>    <span class="hljs-comment">//set</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; set;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourses</span><span class="hljs-params">(String[] courses)</span> &#123;<br>        <span class="hljs-built_in">this</span>.courses = courses;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setList</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaps</span><span class="hljs-params">(Map&lt;String, String&gt; maps)</span> &#123;<br>        <span class="hljs-built_in">this</span>.maps = maps;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSet</span><span class="hljs-params">(Set&lt;String&gt; set)</span> &#123;<br>        <span class="hljs-built_in">this</span>.set = set;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stu&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;courses=&quot;</span> + Arrays.toString(courses) +<br>                <span class="hljs-string">&quot;, list=&quot;</span> + list +<br>                <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>                <span class="hljs-string">&quot;, set=&quot;</span> + set +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.Stu&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        数组--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;courses&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--        list--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--        map--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maps&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;Java&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;Mysql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mysql&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!--        set--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;set&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stu</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;ListAll.xml&quot;</span>);<br>    <span class="hljs-type">Stu</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;stu&quot;</span>, Stu.class);<br>    System.out.println(stu);<br>&#125;<br><span class="hljs-comment">//结果Stu&#123;courses=[1, 2, 3], list=[A, B, C], maps=&#123;Java=java, Mysql=Mysql&#125;, set=[a, b, c]&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5、FactoryBean"><a href="#5、FactoryBean" class="headerlink" title="5、FactoryBean"></a>5、FactoryBean</h4><ol><li>Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</li><li>普通 bean：在配置文件中定义 bean 类型就是返回类型</li><li>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.Book;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.FactoryBean;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//模拟</span><br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>        book.setBookName(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-keyword">return</span> book;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> FactoryBean.<span class="hljs-built_in">super</span>.isSingleton();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.factoryBean.MyBean&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;mybean.xml&quot;</span>);<br>    Book book=applicationContext.getBean(<span class="hljs-string">&quot;myBean&quot;</span>,Book.class);<br>    System.out.println(book);<br>&#125;<br><span class="hljs-comment">//结果Book&#123;bookName=&#x27;Java&#x27;, author=&#x27;null&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="6、bean-作用域"><a href="#6、bean-作用域" class="headerlink" title="6、bean 作用域"></a>6、bean 作用域</h4><ol><li>在Spring 里面，设置创建 bean 实例是单实例还是多实例</li><li>在 Spring 里面，默认情况下，bean 是单实例对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookName</span><span class="hljs-params">(String bookName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookName = bookName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthor</span><span class="hljs-params">(String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>编写xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.Book&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Java&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;张三&gt;&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">book</span><span class="hljs-params">()</span>&#123;<br>    ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;book.xml&quot;</span>);<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book1</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;book&quot;</span>, Book.class);<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book2</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;book&quot;</span>, Book.class);<br>    System.out.println(book1);<br>    System.out.println(book2);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">结果</span><br><span class="hljs-comment">com.cxy.Book@4e718207</span><br><span class="hljs-comment">com.cxy.Book@4e718207</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>3.如何设置单实例还是多实例</p><p>在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p><ul><li>默认值，singleton，表示是单实例对象</li><li>prototype，表示是多实例对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.Book&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Java&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;张三&gt;&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">book</span><span class="hljs-params">()</span>&#123;<br>    ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;book.xml&quot;</span>);<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book1</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;book&quot;</span>, Book.class);<br>    <span class="hljs-type">Book</span> <span class="hljs-variable">book2</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;book&quot;</span>, Book.class);<br>    System.out.println(book1);<br>    System.out.println(book2);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">j</span><br><span class="hljs-comment">com.cxy.Book@553a3d88</span><br><span class="hljs-comment">com.cxy.Book@7a30d1e6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="7、bean-生命周期"><a href="#7、bean-生命周期" class="headerlink" title="7、bean 生命周期"></a>7、bean 生命周期</h4><ol><li>通过构造器创建 bean 实例（无参数构造）</li><li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization </li><li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</li><li>bean 可以使用了（对象获取到了）</li><li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li></ol><h4 id="8、xml-自动装配"><a href="#8、xml-自动装配" class="headerlink" title="8、xml 自动装配"></a>8、xml 自动装配</h4><p>bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值： </p><ul><li>byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样</li><li>byType 根据属性类型注入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    创建UserService对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.service.UserService&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;--&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    创建UserDaoImpl对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cxy.dao.impl.UserDaoImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDaoImplName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="IOC-操作-Bean-管理-基于注解方式"><a href="#IOC-操作-Bean-管理-基于注解方式" class="headerlink" title="IOC 操作 Bean 管理(基于注解方式)"></a>IOC 操作 Bean 管理(基于注解方式)</h3><h4 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h4><ul><li>注解是代码特殊标记，格式：@注解名称(属性名称&#x3D;属性值, 属性名称&#x3D;属性值..)</li><li>使用注解，注解作用在类上面，方法上面，属性上面</li><li>使用注解目的：简化 xml 配置</li></ul><h4 id="Spring-针对-Bean-管理中创建对象提供注解"><a href="#Spring-针对-Bean-管理中创建对象提供注解" class="headerlink" title="Spring 针对 Bean 管理中创建对象提供注解"></a>Spring 针对 Bean 管理中创建对象提供注解</h4><ul><li>@Component</li><li>@Service</li><li>@Controller</li><li>@Repository</li></ul><p>上面四个注解功能是一样的，都可以用来创建 bean 实例</p><h4 id="基于注解方式实现对象创建"><a href="#基于注解方式实现对象创建" class="headerlink" title="基于注解方式实现对象创建"></a>基于注解方式实现对象创建</h4><p>第一步 引入依赖</p><p>第二步 开启组件扫描</p><ul><li>引入 context 名称空间</li><li>开启组件扫描</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--    开启组件扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cxy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第三步 创建类，在类上面添加创建对象注解</p><ul><li>在注解里面 value 属性值可以省略不写</li><li>默认值是类名称，首字母小写</li></ul><p>第四步 基于注解方式实现属性注入</p><ul><li>@Autowired：根据属性类型进行自动装配</li><li>@Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test..service&quot;</span>);<br>        userDao.test();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;test...dao...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类，替代 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">//（1）创建配置类，替代 xml 配置文件</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类注解，作为配置类代替xml</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.annotation.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServlet</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testServlet</span><span class="hljs-params">()</span>&#123;<br>        userDao.test();<br>        System.out.println(<span class="hljs-string">&quot;servlet.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.annotation.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;userDao.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span><br>            <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);<br>    <span class="hljs-type">UserServlet</span> <span class="hljs-variable">userServlet</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userServlet&quot;</span>, UserServlet.class);<br>    System.out.println(userServlet);<br>    userServlet.testServlet();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">结果</span><br><span class="hljs-comment">com.annotation.servlet.UserServlet@3f0846c6</span><br><span class="hljs-comment">userDao.....</span><br><span class="hljs-comment">servlet.....</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h4><ul><li>面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</li><li>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</li><li>使用登录例子说明 AOP</li></ul><img src="/2024/03/05/spring%E7%9A%84xml/%E5%9B%BE3.png" class="" title="图3"><h4 id="AOP（底层原理）"><a href="#AOP（底层原理）" class="headerlink" title="AOP（底层原理）"></a>AOP（底层原理）</h4><p>（1）有两种情况动态代理 </p><ul><li>第一种 有接口情况，使用 JDK 动态代理</li><li>第二种 没有接口情况，使用 CGLIB 动态代理</li></ul><img src="/2024/03/05/spring%E7%9A%84xml/%E5%9B%BE4.png" class="" title="图4"><h4 id="AOP（JDK-动态代理）"><a href="#AOP（JDK-动态代理）" class="headerlink" title="AOP（JDK 动态代理）"></a>AOP（JDK 动态代理）</h4><p>使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建接口，定义方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>    String <span class="hljs-title function_">update</span><span class="hljs-params">(String id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> dao.UserDao;<br><span class="hljs-comment">//创建接口实现类，实现方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">update</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">//创建代理对象代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">// 把创建的是谁的代理对象，把谁传递过来</span><br>    <span class="hljs-comment">// //有参数构造传递</span><br>    <span class="hljs-keyword">private</span> Object object;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-built_in">this</span>.object=object;<br>    &#125;<br>    <span class="hljs-comment">//增强逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="hljs-string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));<br>        <span class="hljs-comment">//使用反射来调用object上的method方法，并传递args参数。这样，我们就间接地调用了原始对象上的方法，并在调用前后添加了额外的逻辑。</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(object, args);<br>        System.out.println(<span class="hljs-string">&quot;执行后&quot;</span>+object);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><br>     <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//使用 Proxy 类创建接口代理对象</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Proxy.newProxyInstance()</span><br><span class="hljs-comment">        第一参数，类加载器</span><br><span class="hljs-comment">        第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</span><br><span class="hljs-comment">        第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         */</span><br>        UserDaoImpl userDaoImpl=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>        Class[] interfaces= &#123;UserDao.class&#125;;<br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> (UserDao) Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), interfaces, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProxy</span>(userDaoImpl));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> userDao.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AOP（术语）"><a href="#AOP（术语）" class="headerlink" title="AOP（术语）"></a>AOP（术语）</h4><ul><li>连接点:类里面哪些方法可以被增强，这些方法称为连接点</li><li>切入点:实际被真正增强的方法，称为切入点</li><li>通知（增强）<ul><li>实际增强的逻辑部分称为通知（增强）</li><li>通知有多钟类型:<ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知</li></ul></li></ul></li><li>切面:把通知应用到切入点过程</li></ul><h4 id="AOP-操作（注解准备工作）"><a href="#AOP-操作（注解准备工作）" class="headerlink" title="AOP 操作（注解准备工作）"></a>AOP 操作（注解准备工作）</h4><ul><li><p>Spring 框架一般都是基于 AspectJ 实现 AOP 操作</p><p>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作</p></li><li><p>基于 AspectJ 实现 AOP 操作</p><ol><li>基于 xml 配置文件实现 </li><li>基于注解方式实现（使用）</li></ol></li><li><p>在项目工程里面引入 AOP 相关依赖</p></li><li><p>切入点表达式</p><ol><li>切入点表达式作用：知道对哪个类里面的哪个方法进行增强 </li><li>语法结构： execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a> )</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cxy.springaop;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 创建对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;add.......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> &#123;<br>    <span class="hljs-meta">@Before(value = &quot;execution(* com.cxy.springaop.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">proxyAdd</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;proxyAdd.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--    开启组件扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cxy.springaop&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-comment">&lt;!--    开启 Aspect 生成代理对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置不同的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 生成代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> &#123;<br>    <span class="hljs-comment">//相同的切入点抽取</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;execution(* com.cxy.springaop.User.add(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointdemo</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-meta">@Before(value = &quot;pointdemo()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">proxyAdd</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Before.....&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterReturning(value = &quot;pointdemo()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterReturning</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AfterReturning.....&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(value = &quot;pointdemo()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">After</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;After.....&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterThrowing(value = &quot;pointdemo()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterThrowing</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AfterThrowing.....&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Around(value = &quot;pointdemo()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;Around 前.....&quot;</span>);<br>        proceedingJoinPoint.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Around 后.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AOP（全注解开发）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">（<span class="hljs-number">1</span>）创建配置类，不需要创建 xml 配置文件 <br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.cxy.springaop&quot;&#125;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigAop</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="AOP-操作（AspectJ-配置文件）"><a href="#AOP-操作（AspectJ-配置文件）" class="headerlink" title="AOP 操作（AspectJ 配置文件）"></a>AOP 操作（AspectJ 配置文件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    &lt;bean id=<span class="hljs-string">&quot;user&quot;</span> class=<span class="hljs-string">&quot;com.cxy.springaop.User&quot;</span>&gt;&lt;/bean&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;userProxy2&quot;</span> class=<span class="hljs-string">&quot;com.cxy.springaop.UserProxy2&quot;</span>&gt;&lt;/bean&gt;<br>&lt;!--    配置aop增强--&gt;<br>    &lt;aop:config&gt;<br>&lt;!--        切入点--&gt;<br>        &lt;aop:pointcut id=<span class="hljs-string">&quot;p&quot;</span> expression=<span class="hljs-string">&quot;execution(* com.cxy.springaop.User.add(..))&quot;</span>/&gt;<br>&lt;!--        配置切面--&gt;<br>        &lt;aop:aspect ref=<span class="hljs-string">&quot;userProxy2&quot;</span>&gt;<br>&lt;!--            增强具体方法--&gt;<br>            &lt;aop:after method=<span class="hljs-string">&quot;After&quot;</span> pointcut-ref=<span class="hljs-string">&quot;p&quot;</span>&gt;&lt;/aop:after&gt;<br>        &lt;/aop:aspect&gt;<br>    &lt;/aop:config&gt;<br></code></pre></td></tr></table></figure><h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><h4 id="什么是-JdbcTemplate"><a href="#什么是-JdbcTemplate" class="headerlink" title="什么是 JdbcTemplate"></a>什么是 JdbcTemplate</h4><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.POJO.User;<br><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServlet</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.addUser(user);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.updateUser(user);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.deleteUser(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectOneUser</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.selectOne(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectLitUser</span><span class="hljs-params">(Integer first, Integer second)</span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.selectListUser(first, second);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(Integer id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查单个用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    User <span class="hljs-title function_">selectOne</span><span class="hljs-params">(Integer id)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询用户列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> first</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> second</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectListUser</span><span class="hljs-params">(Integer first, Integer second)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.POJO.User;<br><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;insert into sys_user(username,user_pwd) values(?,?)&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">insert</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql, user.getUserName(), user.getUserPwd());<br>        <span class="hljs-keyword">return</span> insert;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;update sys_user set username=? ,user_pwd=? where uid=?&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql, user.getUserName(), user.getUserPwd(), user.getUid());<br>        <span class="hljs-keyword">return</span> update;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(Integer id)</span> &#123;<br>      String sql=<span class="hljs-string">&quot;delete from sys_user where uid=?&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">delete</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql, id);<br>        <span class="hljs-keyword">return</span> delete;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectOne</span><span class="hljs-params">(Integer id)</span> &#123;<br>     String sql=<span class="hljs-string">&quot;select uid, username userName,user_pwd userPwd from sys_user where uid=?&quot;</span>;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), id);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectListUser</span><span class="hljs-params">(Integer first ,Integer second)</span> &#123;<br>        String sql=<span class="hljs-string">&quot;select uid ,username userName, user_pwd userPwd from sys_user where uid between ? and ? &quot;</span>;<br>        List&lt;User&gt; query = jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), first, second);<br>        <span class="hljs-keyword">return</span> query;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.POJO.User;<br><span class="hljs-keyword">import</span> com.cxy.servlet.UserServlet;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUserTest</span><span class="hljs-params">()</span>&#123;<br>        User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUserName(<span class="hljs-string">&quot;张三&quot;</span>);<br>        user.setUserPwd(<span class="hljs-string">&quot;123456&quot;</span>);<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;web.xml&quot;</span>);<br>        <span class="hljs-type">UserServlet</span> <span class="hljs-variable">userServlet</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userServlet&quot;</span>, UserServlet.class);<br>        userServlet.addUser(user);<br><br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUserTest</span><span class="hljs-params">()</span>&#123;<br>        User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUid(<span class="hljs-number">5</span>);<br>        user.setUserName(<span class="hljs-string">&quot;张四&quot;</span>);<br>        user.setUserPwd(<span class="hljs-string">&quot;123456&quot;</span>);<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;web.xml&quot;</span>);<br>        <span class="hljs-type">UserServlet</span> <span class="hljs-variable">userServlet</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userServlet&quot;</span>, UserServlet.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userServlet.updateUser(user);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUserTest</span><span class="hljs-params">()</span>&#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;web.xml&quot;</span>);<br>        <span class="hljs-type">UserServlet</span> <span class="hljs-variable">userServlet</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userServlet&quot;</span>, UserServlet.class);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userServlet.deleteUser(<span class="hljs-number">20009</span>);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectOneUserTest</span><span class="hljs-params">()</span>&#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;web.xml&quot;</span>);<br>        <span class="hljs-type">UserServlet</span> <span class="hljs-variable">userServlet</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userServlet&quot;</span>, UserServlet.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userServlet.selectOneUser(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectListUserTest</span><span class="hljs-params">()</span>&#123;<br>        ApplicationContext applicationContext=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;web.xml&quot;</span>);<br>        <span class="hljs-type">UserServlet</span> <span class="hljs-variable">userServlet</span> <span class="hljs-operator">=</span> applicationContext.getBean(<span class="hljs-string">&quot;userServlet&quot;</span>, UserServlet.class);<br>        List&lt;User&gt; user = userServlet.selectLitUser(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    数据库连接池--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///schedule_system&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;chen&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;chen&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--    配置jdbcTemplate--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--    开启注解扫描--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cxy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="jdbcTemplate-方法总结："><a href="#jdbcTemplate-方法总结：" class="headerlink" title="jdbcTemplate 方法总结："></a>jdbcTemplate 方法总结：</h4><p>添加、修改、删除：jdbcTemplate.update(String sql, @Nullable Object… args)</p><p>查询：</p><ul><li><p>单个值：jdbcTemplate.queryForObject(String sql, Class<T> requiredType, @Nullable Object… args)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, String.class, id);<br></code></pre></td></tr></table></figure></li><li><p>封装成一个对象：queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object… args)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), id);<br></code></pre></td></tr></table></figure></li><li><p>封装成集合：query(String sql, RowMapper<T> rowMapper, @Nullable Object… args)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; query = jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyRowMapper</span>&lt;User&gt;(User.class), first, second)<br></code></pre></td></tr></table></figure></li></ul><p>jdbcTemplate 批量操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">batchDeleteUser</span><span class="hljs-params">(List&lt;Object[]&gt; batchArgs)</span> &#123;<br>    String sql=<span class="hljs-string">&quot;delete from sys_user where uid=?&quot;</span>;<br>    <span class="hljs-type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);<br>    <span class="hljs-keyword">return</span> ints.length;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事务操作（事务概念）"><a href="#事务操作（事务概念）" class="headerlink" title="事务操作（事务概念）"></a>事务操作（事务概念）</h3><h4 id="什么事务"><a href="#什么事务" class="headerlink" title="什么事务"></a>什么事务</h4><p>事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败</p><h4 id="事务四个特性（ACID）"><a href="#事务四个特性（ACID）" class="headerlink" title="事务四个特性（ACID）"></a>事务四个特性（ACID）</h4><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ol><h4 id="Spring-事务管理介绍"><a href="#Spring-事务管理介绍" class="headerlink" title="Spring 事务管理介绍"></a>Spring 事务管理介绍</h4><ol><li>事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</li><li>在 Spring 进行事务管理操作</li><li>有两种方式：编程式事务管理和声明式事务管理（使用）</li><li>声明式事务管理<ul><li>基于注解方式（使用）</li><li>基于 xml 配置文件方式</li></ul></li><li>在 Spring 进行声明式事务管理，底层使用 AOP 原理</li><li>Spring 事务管理 API</li></ol><h4 id="示例注解形式："><a href="#示例注解形式：" class="headerlink" title="示例注解形式："></a>示例注解形式：</h4><p>在 spring 配置文件配置事务管理器</p><p>在 spring 配置文件，开启事务注解</p><ul><li>​在 spring 配置文件引入名称空间 tx</li><li>开启事务注解</li></ul><p>在 service 类上面（或者 service 类里面方法上面）添加事务注解</p><ul><li>@Transactional，这个注解添加到类上面，也可以添加方法上面</li><li>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</li><li>如果把这个注解添加方法上面，为这个方法添加事务</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    开启扫描注解--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cxy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--    数据库连接池--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///world&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;chen&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;chen&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--    配置jdbcTemplate--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--    开启事物管理器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        注入数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--    开启事物注解--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:jta-transaction-manager</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:jta-transaction-manager</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.cxy.dao.UserDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.beans.Transient;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Transient</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> i=userDao.subMoney();<br>        System.out.println(<span class="hljs-string">&quot;减---&quot;</span>+i);<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>/<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=userDao.addMoney();<br>        System.out.println(<span class="hljs-string">&quot;加+++&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addMoney</span><span class="hljs-params">()</span> &#123;<br>        String sql=<span class="hljs-string">&quot;update user set money=money+100 where uid=1&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql);<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subMoney</span><span class="hljs-params">()</span> &#123;<br>        String sql=<span class="hljs-string">&quot;update user set money=money-100 where uid=2&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql);<br>        <span class="hljs-keyword">return</span> sub;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h4><p>propagation：事务传播行为:当一个事务方法被另外一个事务方法调用时候，这个事务方法如何进行</p><p>ioslation：事务隔离级别</p><p>timeout：超时时间</p><p>rollbackFor：回滚</p><p>noRollbackFor：不回滚</p><h4 id="XML-声明式事务管理"><a href="#XML-声明式事务管理" class="headerlink" title="XML 声明式事务管理"></a>XML 声明式事务管理</h4><h4 id="在-spring-配置文件中进行配置"><a href="#在-spring-配置文件中进行配置" class="headerlink" title="在 spring 配置文件中进行配置"></a>在 spring 配置文件中进行配置</h4><p>第一步 配置事务管理器</p><p>第二步 配置通知</p><p>第三步 配置切入点和切面</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>Xml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2024/02/27/JDBC/"/>
    <url>/2024/02/27/JDBC/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC?"></a>什么是JDBC?</h4><ol><li>jdbc是(Java Database Connectivity)单词的缩写,翻译为java连接数据库</li><li>jdbc是java程序连接数据库的<strong>技术统称</strong></li><li>jdbc由**java语言的规范(接口)*<em>和*<em>各个数据库厂商的实现驱动(jar)组成</em></em></li><li>*<em>jdbc是一种典型的*</em>*<em>面向接口编程</em>*</li><li>jdbc优势<ol><li>只需要学习jdbc规范接口的方法,即可操作<strong>所有的数据库软件</strong></li><li>项目中期切换数据库软件,只需要更换对应的数据库驱动jar包,不需要更改代码</li></ol></li></ol><h4 id="jdbc核心api和使用路线"><a href="#jdbc核心api和使用路线" class="headerlink" title="jdbc核心api和使用路线"></a>jdbc核心api和使用路线</h4><p><strong>DriverManager*<em>**获取连接；接着建立连接；****PreparedStatement****（最常用）发送sql语句；若是查询操作，则对应的查询结果放在**</em>*Result*<em>**中**</em>*。</strong></p><ul><li><strong>DriverManager</strong><ol><li>将第三方数据库厂商的实现驱动jar注册到程序中</li><li>可以根据数据库连接信息获取connection</li></ol></li><li>Connection [建立连接]<ul><li>和数据库建立的连接,在连接对象上,可以多次执行数据库curd动作</li><li>可以获取statement和 preparedstatement,callablestatement对象</li></ul></li><li>Statement【适用静态sql路线 没有动态值的】 | <strong>PreparedStatement</strong>【预编译sql 有动态值语句】 | CallableStatement<ul><li>具体发送SQL语句到数据库管理软件的对象</li><li>不同发送方式稍有不同! **preparedstatement **使用为重点!</li></ul></li><li>Result【对查询语句才有】（查询的结果）<ul><li><strong>面向对象思维的产物</strong>(抽象成数据库的查询结果表)</li><li>存储DQL查询数据库结果的对象</li><li>需要我们进行解析,获取具体的数据库数据</li></ul></li></ul><h4 id="jdbc基本使用步骤分析-6步"><a href="#jdbc基本使用步骤分析-6步" class="headerlink" title="jdbc基本使用步骤分析(6步)"></a>jdbc基本使用步骤分析(6步)</h4><ol><li>注册驱动【依赖的jar包 进行安装】</li><li>获取连接【connection建立连接】</li><li>创建发送sql语句对象【statement 创建发送sql语句的statement】</li><li>发送sql语句，并获取返回结果【statement发送sql语句到数据库 并且取得返回结构】</li><li>结果集解析【将result结果解析出来】</li><li>资源关闭【释放resultset、statement、connection】</li></ol><h5 id="基于statement演示查询"><a href="#基于statement演示查询" class="headerlink" title="基于statement演示查询"></a>基于statement演示查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册驱动</span><br>      Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>      <span class="hljs-comment">//获取connection对象</span><br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/schedule_system&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>);<br><span class="hljs-comment">//创建statement对象</span><br>      <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br>      String sql=<span class="hljs-string">&quot;insert into sys_user(username,user_pwd) values (\&quot;yu\&quot;,\&quot;yu\&quot;)&quot;</span>;<br>      <span class="hljs-comment">//发送sql</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> statement.executeUpdate(sql);<br>      <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>          System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>      &#125;<br><span class="hljs-comment">//关闭资源</span><br>      statement.close();<br>      connection.close();<br></code></pre></td></tr></table></figure><ol><li><p>SQL语句需要字符串拼接,比较麻烦（示例代码在：执行SQL语句 [动态SQL语句,需要字符串拼接]）</p></li><li><p>只能拼接字符串类型,其他的数据库类型无法处理</p></li><li><p><strong>可能发生注入攻击</strong></p><blockquote><p>动态值充当了SQL语句结构,影响了原有的查询结果!</p></blockquote></li></ol><h5 id="基于preparedStatement方式优化"><a href="#基于preparedStatement方式优化" class="headerlink" title="基于preparedStatement方式优化"></a>基于preparedStatement方式优化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>      <span class="hljs-comment">//获取connection对象</span><br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/schedule_system&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>);<br>      <span class="hljs-comment">//需要sqk语句结构，动态值只能用？ 占位符</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into sys_user values(?,?,?)&quot;</span>;<br><span class="hljs-comment">//创建preparedStatement,需要传入SQL语句结构</span><br>      <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-comment">//设置占位数参数，int 占位符的下角标 object 占位符的值</span><br>      preparedStatement.setObject(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>      preparedStatement.setObject(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;chen&quot;</span>);<br>      preparedStatement.setObject(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;chen&quot;</span>);<br>      <span class="hljs-comment">//发送sql</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br>      <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>          System.out.println(<span class="hljs-string">&quot;添加成功&quot;</span>);<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          System.out.println(<span class="hljs-string">&quot;添加失败&quot;</span>);<br>      &#125;<br>      preparedStatement.close();<br>      connection.close();<br></code></pre></td></tr></table></figure><p>步骤总结：</p><p>1.注册驱动 </p><p>2.获取连接 </p><p>3.编写SQL语句 </p><p>4.创建preparedstatement并且传入SQL语句结构 </p><p>5.占位符赋值 </p><p>6.发送SQL语句,并且获取结果  </p><p>7.结果集解析</p><p>8.关闭资源</p><h4 id="jdbc自增长主键回显"><a href="#jdbc自增长主键回显" class="headerlink" title="jdbc自增长主键回显"></a>jdbc自增长主键回显</h4><p>功能需求：java程序获取插入数据时mysql维护自增长维护的主键id值，这就是主键回显</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS，告诉statement携带回数据库生成的主键！</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);<br><span class="hljs-comment">//一行一列的数据！里面就装主键值！固定用getGeneratedKeys</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.getGeneratedKeys();<br>    resultSet.next();<br><span class="hljs-comment">//拿到的是id值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">anInt</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-number">1</span>);<span class="hljs-comment">//指向第一列</span><br><br></code></pre></td></tr></table></figure><h4 id="批量数据插入性能提升"><a href="#批量数据插入性能提升" class="headerlink" title="批量数据插入性能提升"></a>批量数据插入性能提升</h4><p>批量数据插入优化</p><p>提升大量数据插入效率</p><p>改动了三处：（1）路径（2）必写values，且后面不加;（3）装货addBatch()最后executeBatch(); </p><p> 批量细节：    </p><p>1.url?rewriteBatchedStatements&#x3D;true</p><p>2.insert 语句必须使用 values    </p><p>3.语句后面不能添加分号;     </p><p>4.语句不能直接执行，每次需要装货  addBatch() 最后 executeBatch();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        <span class="hljs-comment">//获取connection对象</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/schedule_system&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>, <span class="hljs-string">&quot;chen&quot;</span>);<br>        <span class="hljs-comment">//设置sql和参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into sys_user(username,user_pwd) values(?,?)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        Long start=System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            preparedStatement.setObject(<span class="hljs-number">1</span>, RandomStringGenerator.getRandomString());<br>            preparedStatement.setObject(<span class="hljs-number">2</span>, RandomStringGenerator.getRandomString());<br>           preparedStatement.addBatch();<br>        &#125;<br>        preparedStatement.executeBatch();<br>        Long end=System.currentTimeMillis();<br>        System.out.println(end-start);<br></code></pre></td></tr></table></figure><h4 id="jdbc事物实现"><a href="#jdbc事物实现" class="headerlink" title="jdbc事物实现"></a>jdbc事物实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sql开启事务方式【事务都在一个连接中】</span><br>   针对自动提交: 关闭自动提交即可,多条语句添加以后,最终手动提交或者回滚! (推荐)<br>     <br>      <span class="hljs-type">SET</span> <span class="hljs-variable">autocommit</span> <span class="hljs-operator">=</span> off; <span class="hljs-comment">//关闭当前连接connection自动事务提交方式</span><br>      # 只有当前连接有效<br>      # 编写SQL语句即可<br>      SQL<br>      SQL<br>      SQL<br>      #手动提交或者回滚 【结束当前的事务】<br>      COMMIT / ROLLBACK ;  <br>     <br>   手动开启事务: 开启事务代码,添加SQL语句,事务提交或者事务回滚! (不推荐)<br><br><span class="hljs-comment">// 呼应jdbc技术</span><br> <br>  <span class="hljs-keyword">try</span>&#123;<br>    connection.setAutoCommit(<span class="hljs-literal">false</span>); <span class="hljs-comment">//关闭自动提交了</span><br>    <span class="hljs-comment">//connection.setAutoCommit(false)也就类型于SET autocommit = off</span><br>    <br>    <span class="hljs-comment">//注意,只要当前connection对象,进行数据库操作,都不会自动提交事务</span><br>    <span class="hljs-comment">//数据库动作!</span><br>    <span class="hljs-comment">//statement - 单一的数据库动作 c u r d </span><br>    <span class="hljs-comment">//connection - 操作事务 </span><br>    <br>    connection.commit();<br>  &#125;<span class="hljs-keyword">catch</span>(Execption e)&#123;<br>    connection.rollback();<br>  &#125;<br></code></pre></td></tr></table></figure><p>表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE t_bank(<br>   id INT PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;账号主键&#x27;,<br>   account VARCHAR(20) NOT NULL UNIQUE COMMENT &#x27;账号&#x27;,<br>   money  INT UNSIGNED COMMENT &#x27;金额,不能为负值&#x27;) ;<br>   <br>INSERT INTO t_bank(account,money) VALUES<br>  (&#x27;ergouzi&#x27;,1000),(&#x27;lvdandan&#x27;,1000);<br><br>```<br></code></pre></td></tr></table></figure><p>jdbc事物实现</p><p>BankServer层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankService</span> &#123;<br><br><span class="hljs-comment">//一个事物最基本的是在同一个连接中connection，一个转账方法是一个事物，将connection传入dao</span><br><span class="hljs-comment">//实现层即可，dao层不用关闭connection，由事物统一关闭</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转账业务方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> addAccount  加钱账号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> subAccount  减钱账号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money  金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(String addAccount,String subAccount, <span class="hljs-type">int</span> money)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;addAccount = &quot;</span> + addAccount + <span class="hljs-string">&quot;, subAccount = &quot;</span> + subAccount + <span class="hljs-string">&quot;, money = &quot;</span> + money);<br><br>        <span class="hljs-comment">//注册驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>        <span class="hljs-comment">//获取连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection<br>                                (<span class="hljs-string">&quot;jdbc:mysql:///atguigu&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//利用try代码块,调用dao</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//开启事务(关闭事务自动提交)</span><br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-type">BankDao</span> <span class="hljs-variable">bankDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BankDao</span>();<br>            <span class="hljs-comment">//调用加钱 和 减钱</span><br>            bankDao.addMoney(addAccount,money,connection);<br>            System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>            bankDao.subMoney(subAccount,money,connection);<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//不报错,提交事务</span><br>            connection.commit();<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>            <span class="hljs-comment">//报错回滚事务</span><br>            connection.rollback();<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            connection.close();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;转账成功!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;转账失败!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>bankDao层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankDao</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加钱方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> account</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connection 业务传递的connection和减钱是同一个! 才可以在一个事务中!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addMoney</span><span class="hljs-params">(String account, <span class="hljs-type">int</span> money,Connection connection)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_bank set money = money + ? where account = ? ;&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><br>        <span class="hljs-comment">//占位符赋值</span><br>        preparedStatement.setObject(<span class="hljs-number">1</span>, money);<br>        preparedStatement.setString(<span class="hljs-number">2</span>, account);<br><br>        <span class="hljs-comment">//发送SQL语句</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br><br>        <span class="hljs-comment">//输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;加钱执行完毕!&quot;</span>);<br><br>        <span class="hljs-comment">//关闭资源close</span><br>        preparedStatement.close();<br><br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 减钱方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> account</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connection 业务传递的connection和加钱是同一个! 才可以在一个事务中!</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 影响行数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subMoney</span><span class="hljs-params">(String account, <span class="hljs-type">int</span> money,Connection connection)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_bank set money = money - ? where account = ? ;&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><br>        <span class="hljs-comment">//占位符赋值</span><br>        preparedStatement.setObject(<span class="hljs-number">1</span>, money);<br>        preparedStatement.setString(<span class="hljs-number">2</span>, account);<br><br>        <span class="hljs-comment">//发送SQL语句</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> preparedStatement.executeUpdate();<br><br>        <span class="hljs-comment">//输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;减钱执行完毕!&quot;</span>);<br><br>        <span class="hljs-comment">//关闭资源close</span><br>        preparedStatement.close();<br><br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Durid连接池"><a href="#Durid连接池" class="headerlink" title="Durid连接池"></a>Durid连接池</h4><p>存放在<strong>src&#x2F;druid.properties</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"># druid连接池需要的配置参数,key固定命名<br>driverClassName=com.mysql.cj.jdbc.Driver<br>username=root<br>password=root<br>url=jdbc:mysql:jdbc:mysql:<span class="hljs-comment">//localhost:3306/schedule_system</span><br></code></pre></td></tr></table></figure><p>druid声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不直接在java代码编写配置文件！</span><br><span class="hljs-comment"> * 利用工厂模式，传入配置文件对象，创建连接池！</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><br><span class="hljs-comment">//druid.properties直接放在src目录下</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">druidSoft</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">ips</span> <span class="hljs-operator">=</span> DruidDemo.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>);<br>    properties.load(ips);<br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="jdbc封装"><a href="#jdbc封装" class="headerlink" title="jdbc封装"></a>jdbc封装</h4><p>jdbc.properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">driverClassName</span>=com.mysql.cj.jdbc.Driver<br><span class="hljs-attr">url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/schedule_system<br><span class="hljs-attr">username</span>=chen<br><span class="hljs-attr">password</span>=chen<br><span class="hljs-attr">initialSize</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h5 id="JDBCUtil类"><a href="#JDBCUtil类" class="headerlink" title="JDBCUtil类"></a>JDBCUtil类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtil</span> &#123;<br>    <span class="hljs-comment">//本地线程 为了控制事物</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource;<br>    <span class="hljs-comment">// 初始化连接池</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">// 可以帮助我们读取.properties配置文件</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.load(resourceAsStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;       <span class="hljs-keyword">try</span> &#123;<br>            dataSource = DruidDataSourceFactory.createDataSource(properties);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-comment">/*1 向外提供连接池的方法*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/*2 向外提供连接的方法*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == connection) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection = dataSource.getConnection();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            threadLocal.set(connection);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br><br><br>    <span class="hljs-comment">/*定义一个归还连接的方法 (解除和ThreadLocal之间的关联关系) */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != connection) &#123;<br>            threadLocal.remove();<br>            <span class="hljs-comment">// 把连接设置回自动提交的连接</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.setAutoCommit(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 自动归还到连接池</span><br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BaseDao封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseDao</span> &#123;<br>    <span class="hljs-comment">// 公共的查询方法  返回的是单个对象</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">baseQueryObject</span><span class="hljs-params">(Class&lt;T&gt; clazz, String sql, Object ... args)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtil.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 准备语句对象</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">// 设置语句上的参数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                preparedStatement.setObject(i + <span class="hljs-number">1</span>, args[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 执行 查询</span><br>            resultSet = preparedStatement.executeQuery();<br>            <span class="hljs-keyword">if</span> (resultSet.next()) &#123;<br>                t = (T) resultSet.getObject(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != resultSet) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    resultSet.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != preparedStatement) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;<br>            JDBCUtil.releaseConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-comment">// 公共的查询方法  返回的是对象的集合</span><br><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">baseQuery</span><span class="hljs-params">(Class clazz, String sql, Object ... args)</span>&#123;<br>        List&lt;T&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtil.getConnection();<br>        PreparedStatement preparedStatement=<span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 准备语句对象</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">// 设置语句上的参数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                preparedStatement.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 执行 查询</span><br>            resultSet = preparedStatement.executeQuery();<br><br>            <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">metaData</span> <span class="hljs-operator">=</span> resultSet.getMetaData();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> metaData.getColumnCount();<br><br>            <span class="hljs-comment">// 将结果集通过反射封装成实体类对象</span><br>            <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>                <span class="hljs-comment">// 使用反射实例化对象</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span>clazz.getDeclaredConstructor().newInstance();<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= columnCount; i++) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">columnName</span> <span class="hljs-operator">=</span> metaData.getColumnLabel(i);<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> resultSet.getObject(columnName);<br>                    <span class="hljs-comment">// 处理datetime类型字段和java.util.Data转换问题</span><br>                    <span class="hljs-keyword">if</span>(value.getClass().equals(LocalDateTime.class))&#123;<br>                        value= Timestamp.valueOf((LocalDateTime) value);<br>                    &#125;<br>                    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(columnName);<br>                    field.setAccessible(<span class="hljs-literal">true</span>);<br>                    field.set(obj,value);<br>                &#125;<br><br>                list.add((T)obj);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !=resultSet) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    resultSet.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != preparedStatement) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>            JDBCUtil.releaseConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">// 通用的增删改方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">baseUpdate</span><span class="hljs-params">(String sql,Object ... args)</span> &#123;<br>        <span class="hljs-comment">// 获取连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtil.getConnection();<br>        PreparedStatement preparedStatement=<span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 准备语句对象</span><br>            preparedStatement = connection.prepareStatement(sql);<br>            <span class="hljs-comment">// 设置语句上的参数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>                preparedStatement.setObject(i+<span class="hljs-number">1</span>,args[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 执行 增删改 executeUpdate</span><br>            rows = preparedStatement.executeUpdate();<br>            <span class="hljs-comment">// 释放资源(可选)</span><br><br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != preparedStatement) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    preparedStatement.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br><br>            &#125;<br>            JDBCUtil.releaseConnection();<br>        &#125;<br>        <span class="hljs-comment">// 返回的是影响数据库记录数</span><br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组实现队列</title>
    <link href="/2023/12/13/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2023/12/13/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>「队列 queue」是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。</p><p>我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。</p><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><p>为了实现队列，我们需要一种数据结构，可以在一端添加元素，并在另一端删除元素。链表和数组都符合要求。</p><p>在数组中删除首元素的时间复杂度为 O(n)，这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题。</p><p>我们可以使用一个变量 <code>front</code> 指向队首元素的索引，并维护一个变量 <code>size</code> 用于记录队列长度。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向队尾元素之后的下一个位置。</p><p>你可能会发现一个问题：在不断进行入队和出队的过程中，<code>front</code> 和 <code>rear</code> 都在向右移动，<strong>当它们到达数组尾部时就无法继续移动了</strong>。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> front; <span class="hljs-comment">// 队首指针，指向队首元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> queSize;<span class="hljs-comment">// 队列长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arr;<span class="hljs-comment">// 用于存储队列元素的数组</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[capacity];<span class="hljs-comment">//初始化能数组大小</span><br>        front=queSize=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始化队首、队列长度</span><br>    &#125;<br>    <span class="hljs-comment">//获取队列的容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">capacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arr.length;<br>    &#125;<br>    <span class="hljs-comment">//获取队列的长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> queSize;<br>    &#125;<br>    <span class="hljs-comment">//判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> queSize==<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断队列是否满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">boolean</span> result=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(queSize==capacity())&#123;<br>            result=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//添加元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">if</span>(isFull())&#123;<br>            System.out.println(<span class="hljs-string">&quot;队列已满，添加失败&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 通过取余操作，实现 rear 越过数组尾部后回到头部</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rear</span> <span class="hljs-operator">=</span> (front + queSize) % capacity();<br>        arr[rear]=num;<br>        queSize++;<br>    &#125;<br>    <span class="hljs-comment">//删除队首元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125;<br>        front++;<br>        queSize--;<br>    &#125;<br>    <span class="hljs-comment">//查看队首元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[front];<br>    &#125;<br>    <span class="hljs-comment">//把队列数组转化为数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] toArray()&#123;<br>        <span class="hljs-type">int</span>[] res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queSize];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=front;i&lt;queSize;i++,j++)&#123;<br>            res[i]=arr[j%capacity()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组和稀疏数组</title>
    <link href="/2023/12/13/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2023/12/13/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一：什么是稀疏数组"><a href="#一：什么是稀疏数组" class="headerlink" title="一：什么是稀疏数组"></a>一：什么是稀疏数组</h3><p>当一个数组a中大部分元素为0，或者为同一个值，那么可以用稀疏数组b来保存数组a。</p><p>首先，稀疏数组是一个数组，然后以一种特定的方式来保存上述的数组a，具体处理方法：</p><ul><li>记录数组a一共有几行几列</li><li>记录a中有多少个不同的值</li><li>最后记录不同值的元素所在行列，以及具体的值，放在一个小规模的数组里，以缩小程序的规模。</li></ul><p>这个小规模的数组，就是稀疏数组。</p><h3 id="二、场景用法"><a href="#二、场景用法" class="headerlink" title="二、场景用法"></a>二、场景用法</h3><p>比如现在有一个五子棋游戏的程序需求：游戏可以进行存盘，下次打开游戏可以续上盘。</p><p>那么记录五子棋的棋盘内容，其实用二维数组记录非常的直观。</p><h3 id="1-二维数组转稀疏数组思路"><a href="#1-二维数组转稀疏数组思路" class="headerlink" title="1.二维数组转稀疏数组思路"></a>1.二维数组转稀疏数组思路</h3><p>如何转化，思路很简单：</p><ol><li><p>遍历原始二维数组，得到有效数据的个数sum</p></li><li><p>根据sum就可以创建稀疏数组 sparseArray</p></li><li><p>将二维数组的有效数据存入到稀疏数组</p></li></ol><h3 id="2-稀疏数组转二维数组思路"><a href="#2-稀疏数组转二维数组思路" class="headerlink" title="2.稀疏数组转二维数组思路"></a>2.稀疏数组转二维数组思路</h3><p>读盘的时候需要把稀疏再转回二维数组：</p><ol><li><p>先读取稀疏数组的第一行，根据第一行的数据，创建二维数组</p></li><li><p>继续读取稀疏数组后几行的数据，对二维数组赋值。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DataAlgorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sparseArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化二位数组</span><br>        <span class="hljs-type">int</span>[][] array=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">15</span>][<span class="hljs-number">12</span>];<br>        array[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        array[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">2</span>;<br>        array[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//二维数组中值的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历原始二维数组，得到有效数据的个数sum</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(array[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                    sum++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2. 根据sum就可以创建稀疏数组 sparseArray</span><br>        <span class="hljs-type">int</span>[][] sparseArray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=array.length;<br>        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=array[<span class="hljs-number">0</span>].length;<br>        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=sum;<br>        <span class="hljs-comment">//将二维数组的有效数据存入到稀疏数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(array[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                    count++;<br>                   sparseArray[count][<span class="hljs-number">0</span>]=i;<br>                   sparseArray[count][<span class="hljs-number">1</span>]=j;<br>                   sparseArray[count][<span class="hljs-number">2</span>]=array[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//稀疏数组遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sparseArray.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;sparseArray[<span class="hljs-number">0</span>].length;j++)&#123;<br>                System.out.print(sparseArray[i][j]+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        <span class="hljs-comment">//稀疏数组转二维数组</span><br>        <span class="hljs-comment">//先读取稀疏数组的第一行，根据第一行的数据，创建二维数组</span><br>        <span class="hljs-type">int</span>[][] array1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];<br>        <span class="hljs-comment">//继续读取稀疏数组后几行的数据，对二维数组赋值。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;sparseArray.length;i++)&#123;<br>                <span class="hljs-type">int</span> row=sparseArray[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> col=sparseArray[i][<span class="hljs-number">1</span>];<br>                array1[row][col]=sparseArray[i][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-comment">//二维数组输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array1[<span class="hljs-number">0</span>].length;j++)&#123;<br>                System.out.print(array1[i][j]+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法概念</title>
    <link href="/2023/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>「算法 algorithm」是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p><ul><li>问题是明确的，包含清晰的输入和输出定义。</li><li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li><li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li></ul><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>「数据结构 data structure」是计算机中组织和存储数据的方式，具有以下设计目标。</p><ul><li>空间占用尽量少，以节省计算机内存。</li><li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li><li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li></ul><h3 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h3><p>数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。</p><ul><li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li><li>算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li><li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li></ul><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p><h4 id="逻辑结构：线性与非线性"><a href="#逻辑结构：线性与非线性" class="headerlink" title="逻辑结构：线性与非线性"></a>逻辑结构：线性与非线性</h4><ul><li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表。</li><li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li></ul><p>非线性数据结构可以进一步划分为树形结构和网状结构。</p><ul><li><strong>线性结构</strong>：数组、链表、队列、栈、哈希表，元素之间是一对一的顺序关系。</li><li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li><li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li></ul><h4 id="物理结构：连续与分散"><a href="#物理结构：连续与分散" class="headerlink" title="物理结构：连续与分散"></a>物理结构：连续与分散</h4><p><strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 (\geq 3) 的数组）等。</li><li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li></ul><p>基于数组实现的数据结构也称“静态数据结构”，这意味着此类数据结构在初始化后长度不可变。相对应地，基于链表实现的数据结构称“动态数据结构”，这类数据结构在初始化后，仍可以在程序运行过程中对其长度进行调整。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计与实现</title>
    <link href="/2023/12/06/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/12/06/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="开发软件流程"><a href="#开发软件流程" class="headerlink" title="开发软件流程"></a>开发软件流程</h3><img src="/2023/12/06/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" class="" title="未命名文件"><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>以下是一个图书管理系统的需求分析文档示例：</p><p>一、项目背景</p><p>随着图书馆业务的发展和管理水平的提高，传统的图书管理方式已经无法满足需求。为了提高图书馆的管理效率和读者的借阅体验，需要开发一个图书管理系统来实现对图书的自动化管理。</p><p>二、项目目标</p><p>本项目的目标是开发一个功能完善、易用、可扩展的图书管理系统，实现以下功能：</p><ol><li>实现对图书的分类、编目、入库、检索等功能的信息化管理，提高图书管理效率；</li><li>实现对图书借阅、归还等过程的信息化管理，方便读者操作，提高借阅体验；</li><li>实现对读者信息的管理和维护，方便图书馆员进行读者管理；</li><li>实现对借阅数据的统计和分析，为图书馆的运营和发展提供数据支持；</li><li>具备良好的安全性和可靠性，保证数据的安全和系统的稳定运行。</li></ol><p>三、用户需求</p><p>本项目的用户包括图书馆员、读者和管理员等不同角色，他们对系统的需求如下：</p><ol><li>图书馆员需求：</li></ol><ul><li>能够添加、编辑和删除图书信息，包括书名、作者、出版社、ISBN号等信息；</li><li>能够添加、编辑和删除分类信息；</li><li>能够查询读者的借阅信息、归还信息和借阅历史；</li><li>能够进行借阅和归还操作，记录借阅时间、借阅人、图书名称等信息；</li><li>能够统计和查看借阅数据，包括各分类图书的借阅次数、借阅人数等。</li></ul><ol><li>读者需求：</li></ol><ul><li>能够查询可借阅的图书信息；</li><li>能够进行借阅和归还操作，记录借阅时间、归还时间、借阅人等信息；</li><li>能够查询自己的借阅信息、归还信息和借阅历史。</li></ul><ol><li>管理员需求：</li></ol><ul><li>能够管理图书馆员的账号和权限；</li><li>能够查看和导出系统的所有数据，包括图书信息、读者信息、借阅信息等；</li><li>能够设置系统的参数和配置项，例如系统名称、单位名称等信息。</li></ul><h3 id="Spec"><a href="#Spec" class="headerlink" title="Spec"></a>Spec</h3><p>以下是一个图书管理系统的Spec文档示例：</p><p>一、概述</p><p>本Spec文档旨在详细描述图书管理系统的功能需求和其他方面的需求，为开发团队提供设计和开发依据。该图书管理系统旨在提高图书馆的管理效率和读者的借阅体验。</p><p>二、功能需求</p><ol><li>用户登录与权限管理</li></ol><ul><li>管理员可以设置图书馆员的账号和权限；</li><li>图书馆员可以登录系统，进行图书管理、借阅、归还等操作；</li><li>读者可以登录系统，进行图书查询、借阅、归还等操作。</li></ul><ol><li>图书入库管理</li></ol><ul><li>图书馆员可以添加新图书信息，包括书名、作者、出版社、ISBN号等信息；</li><li>图书馆员可以编辑和删除图书信息。</li></ul><ol><li>图书分类管理</li></ol><ul><li>图书馆员可以设置图书分类，例如文学、历史、哲学等；</li><li>图书馆员可以编辑和删除分类信息。</li></ul><ol><li>借阅图书管理</li></ol><ul><li>读者可以查询可借阅的图书信息；</li><li>读者可以借阅图书，系统记录借阅信息，包括借阅时间、借阅人、图书名称等；</li><li>读者可以归还图书，系统记录归还信息，包括归还时间、归还人、图书名称等。</li></ul><ol><li>统计与报表生成</li></ol><ul><li>系统可以统计各类图书的借阅情况，包括各分类图书的借阅次数、借阅人数等；</li><li>系统可以生成借阅报表，包括各时间段、各分类的借阅情况等。</li></ul><p>三、非功能需求</p><ol><li>性能需求</li></ol><ul><li>系统响应时间不超过2秒；</li><li>处理速度满足日常业务需求。</li></ul><ol><li>数据管理需求</li></ol><ul><li>数据存储安全可靠，备份与恢复及时；</li><li>数据传输与处理过程需遵循相关法律法规。</li></ul><ol><li>界面设计需求</li></ol><ul><li>界面简洁明了，易于理解和操作；</li><li>颜色搭配合理，符合视觉习惯。</li></ul><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><p>以下是一个图书管理系统的详细设计文档示例，包括系统架构、功能模块、数据库设计、界面设计等方面的详细描述：</p><p>一、系统架构</p><p>本图书管理系统采用B&#x2F;S架构，即浏览器与服务器架构。用户通过浏览器访问系统，而服务器负责处理用户的请求和数据存储。系统采用三层架构，即数据访问层、业务逻辑层和表现层。</p><ol><li>数据访问层：负责与数据库进行交互，包括数据的查询、插入、更新和删除等操作。</li><li>业务逻辑层：负责处理系统的业务逻辑，包括对图书的管理、借阅、归还等操作。</li><li>表现层：负责展示系统的界面，包括页面布局、控件和样式等。</li></ol><p>二、功能模块</p><p>本图书管理系统包括以下功能模块：</p><ol><li>登录模块：实现用户登录和权限管理功能。</li><li>图书管理模块：实现图书的分类、编目、入库、检索等功能的信息化管理。</li><li>借阅管理模块：实现读者借阅、归还等过程的信息化管理，包括借阅申请、借阅审批、归还等操作。</li><li>读者管理模块：实现读者信息的信息化管理，包括读者注册、信息维护、密码修改等操作。</li><li>统计报表模块：实现借阅数据的统计和分析功能，为图书馆的运营和发展提供数据支持。</li><li>系统设置模块：实现系统的参数设置和配置项管理功能。</li></ol><p>三、数据库设计</p><p>本图书管理系统采用关系型数据库进行数据存储和管理。数据库设计包括以下表结构：</p><ol><li>图书表：包括书名、作者、出版社、ISBN号等信息。</li><li>分类表：包括分类名称和分类ID等信息。</li><li>借阅表：包括借阅人ID、图书ID、借阅时间等信息。</li><li>读者表：包括读者ID、姓名、性别、联系电话等信息。</li><li>系统表：包括系统名称、单位名称等信息。</li></ol><p>四、界面设计</p><p>本图书管理系统的界面设计遵循简洁明了、易于操作的原则，采用常见的Web界面设计风格。主界面包括以下部分：</p><ol><li>菜单栏：包括登录、图书管理、借阅管理、读者管理、统计报表和系统设置等菜单项。</li><li>图书列表：展示图书馆的图书列表，包括书名、作者、出版社等信息。用户可以按照分类进行筛选，也可以进行关键字搜索。</li><li>借阅申请：用户可以在该界面提交借阅申请，选择要借阅的图书和借阅时间等信息。</li><li>借阅审批：图书馆员可以在该界面进行借阅审批操作，审核读者的借阅申请。</li><li>读者信息：该界面展示读者的基本信息，包括姓名、性别、联系电话等信息。图书馆员可以编辑和删除读者的信息。</li><li>统计报表：该界面展示借阅数据的统计和分析结果，包括各分类图书的借阅次数、借阅人数等数据。图书馆员可以导出报表数据进行进一步的分析和决策。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件开发流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2023/10/31/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/31/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型用于表示没有小数部分的数值， 它允许是负数</p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4 字节</td><td>-2 147 483 648 - 2 147 483 647 (正好超过 20 亿)</td></tr><tr><td>short</td><td>2 字节</td><td>-32 768 - 32 767</td></tr><tr><td>long</td><td>8 字节</td><td>-9 223 372 036 854 775 B08 - 9 223 372 036 854 775 807</td></tr><tr><td>byte</td><td>1 字节</td><td>-128 - 127</td></tr></tbody></table><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型用于表示有小数部分的数值</p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位）</td></tr><tr><td>double</td><td>8 字节</td><td>大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位&gt;</td></tr></tbody></table><p>float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默 认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D) 。</p><h3 id="char-类型"><a href="#char-类型" class="headerlink" title="char 类型"></a>char 类型</h3><p>char 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode 字符可以用一个 chai•值描述，另外一些 Unicode 字符则需要两个 char 值。</p><h3 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h3><p>boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制单元的设计（九）</title>
    <link href="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/"/>
    <url>/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>本章以10条机器指令为例，介绍控制单元的两种设计方法，旨在使读者初步掌握设计控制单元的思路，为今后设计计算机打下初步基础。</p><span id="more"></span><h3 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h3><h4 id="组合逻辑控制单元框图"><a href="#组合逻辑控制单元框图" class="headerlink" title="组合逻辑控制单元框图"></a>组合逻辑控制单元框图</h4><p>图示出了控制单元的外特性，其中指令的操作码是决定控制单元发出不同控制信号的关键。为了简化控制单元的逻辑，将存放在IR的n位操作码经过一个译码电路产生2^n^个输出，这样，每对应一种操作码便有一个输出送至CU。当然，若指令的操作码长度可变，指令译码线路将更复杂。</p><p>控制单元的时钟输人实际上是一个脉冲序列，其频率即为机器的主频，它使CU能按一定的节拍(T)发出各种控制信号。节拍的宽度应满足数据信息通过数据总线从源到目的所需的时间。以时钟为计数脉冲，通过一个计数器，义称节拍发生器，便可产生一个与时钟周期等宽的节拍序列。如果将指令译码和节拍发生器从CU中分离出来，便可得简化的控制单元框图</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024205600368.png" class="" title="image-20231024205600368"><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024205708402.png" class="" title="image-20231024205708402"><h4 id="微操作的节拍安排"><a href="#微操作的节拍安排" class="headerlink" title="微操作的节拍安排"></a>微操作的节拍安排</h4><p>假设机器采用同步控制，每个机器周期包含3个节拍，而且CPU内部结构，其中MAR和MDR分别直接和地址总线和数据总线相连，并假设IR的地址码部分与MAR之间有通路。</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024205924958.png" class="" title="image-20231024205924958">安排微操作节拍时应注意以下3点。<ol><li>有些微操作的次序是不容改变的，故安排微操作节拍时必须注意微操作的先后顺序。</li><li>凡是被控制对象不同的微操作，若能在一个节拍内执行，应尽可能安排在同一个节拍内，以节省时间。</li><li>如果有些微操作所占的时间不长，应该将它们安排在一个节拍内完成，并且允许这些微操作有先后次序。</li></ol><h5 id="取指周期微操作的节拍安排"><a href="#取指周期微操作的节拍安排" class="headerlink" title="取指周期微操作的节拍安排"></a>取指周期微操作的节拍安排</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210058741.png" class="" title="image-20231024210058741"><h5 id="间址周期微操作的节拍安排"><a href="#间址周期微操作的节拍安排" class="headerlink" title="间址周期微操作的节拍安排"></a>间址周期微操作的节拍安排</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210128928.png" class="" title="image-20231024210128928"><h5 id="执行周期微操作的节拍安排"><a href="#执行周期微操作的节拍安排" class="headerlink" title="执行周期微操作的节拍安排"></a>执行周期微操作的节拍安排</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210218135.png" class="" title="image-20231024210218135"><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210245332.png" class="" title="image-20231024210245332"><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210300297.png" class="" title="image-20231024210300297"><h5 id="中断周期微操作的节拍安排"><a href="#中断周期微操作的节拍安排" class="headerlink" title="中断周期微操作的节拍安排"></a>中断周期微操作的节拍安排</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210330325.png" class="" title="image-20231024210330325"><h4 id="组合逻辑设计步骤"><a href="#组合逻辑设计步骤" class="headerlink" title="组合逻辑设计步骤"></a>组合逻辑设计步骤</h4><p>组合逻辑设计控制单元时，首先根据上述10条指令微操作的节拍安排，列出微操作命令的操作时间表，然后写出每一个微操作命令（控制信号）的逻辑表达式，最后根据逻辑表达式画出相应的组合逻辑电路图。</p><p>当然，在设计逻辑图时要考虑门的扇入系数和逻辑级数。如果采用现成芯片，还需选择芯片型号。采用组合逻辑设计方法设汁控制单元，思路清晰，简单明了，但因为每一个微操作命令都对应一个逻辑电路，因此一旦设计完毕便会发现，这种控制单元的线路结构十分庞杂，也不规范，犹如一棵大树，到处都是不规整的枝权。而且指令系统功能越全，微操作命令就越多，线路也越复杂，调试就更困难。为了克服这些缺点，可采用微程序设计方案。但是，随着RISC的出现，组合逻辑设计仍然是设计计算机的一种重要方法。</p><h3 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h3><h4 id="微程序设计思想的产生"><a href="#微程序设计思想的产生" class="headerlink" title="微程序设计思想的产生"></a>微程序设计思想的产生</h4><p>微程序设计省去了组合逻辑设计过程中对逻辑表达式的化简步骤，无须考虑逻辑门级数和门的扇人系数，使设计更简便，而且由于控制信号是以二进制代码的形式出现的，因此只要修改微指令的代码，就可改变操作内容，便于调试、修改，甚至增删机器指令，有利于计算机仿真。</p><h4 id="微程序控制单元框图及工作原理"><a href="#微程序控制单元框图及工作原理" class="headerlink" title="微程序控制单元框图及工作原理"></a>微程序控制单元框图及工作原理</h4><h5 id="机器指令对应的微程序"><a href="#机器指令对应的微程序" class="headerlink" title="机器指令对应的微程序"></a>机器指令对应的微程序</h5><p>采用微程序设计方法设计控制单元的过程就是编写每一条机器指令的微程序，它是按执行每条机器指令所需的微操作命令的先后顺序而编写的，因此，一条机器指令对应一个微程序，。图中每一条机器指令都与一个以操作性质命名的微程序对应。</p><p>由于任何一条机器指令的取指令操作是相同的，因此将取指令操作的命令统一编成一个微程序，这个微程序只负贵将指令从主存单元中取出送至指令寄存器中，如图的取指周期微程序。此外，如果指令是间接寻址，其操作也是可以预测的，也可先编出对应间址周期的微程序。当出现中断时，中断隐指令所需完成的操作可由一个对应中断周期的微程序控制完成。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间接寻址和中断周期的3个微程序。</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024210804816.png" class="" title="image-20231024210804816"><h5 id="微程序控制单元的基本框图"><a href="#微程序控制单元的基本框图" class="headerlink" title="微程序控制单元的基本框图"></a>微程序控制单元的基本框图</h5><p>图中点画线框内为微程序控制单元，与图上图相比，它们都有相同的输人，如指令寄存器、各种标志和时钟，输出也是输至CPU内部或系统总线的控制信号点画线框内的控制存储器（简称控存）是微程字控制单元的核心部件，用来存放全部微程序；CMAR是控存地址寄存器，用来存放欲读出的微指令地址CMDR是控存数据寄存器，用来存放从控存读出的微指令；顺序逻辑是用来控制微指令序列的，具体就是控制形成下一条微指令（即后续微指令）的地址，其输人与微地址形成部件（与指令寄存器相连)、微指令的下地址字段以及外来的标志有关。有关微指令序列地址的形成将在</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024211225386.png" class="" title="image-20231024211225386"><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024211253366.png" class="" title="image-20231024211253366"><h4 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h4><p>微指令的编码方式又称微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号，主要有以下几种。</p><h5 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024211430004.png" class="" title="image-20231024211430004"><p>在微指令的操作控制字段中，每一位代表一个微操作命令，这种编码方式即为直接编码方式。上面所述的用控制字段中的某位为“1”表示控制信号有效（如打开某个控制门），以及某位为“0”表示控制信号无效（如不打开某个控制门）就是直接控制方式，如图所示。这种方式含义清晰，而且只要微指令从控存读出，即刻可由控制字段发出命令，速度快。但由于机器中微操作命令甚多，可能使微指令操作控制字段达几百位，造成控存容量极大。</p><h5 id="宇段直接编码方式"><a href="#宇段直接编码方式" class="headerlink" title="宇段直接编码方式"></a>宇段直接编码方式</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024211600568.png" class="" title="image-20231024211600568"><p>这种方式就是将微指令的操作控制字段分成若干段，将一组互斥的微操作命令放在一个字段内，通过对这个字段译码，便可对应每一个微命令，如图所示。这种方式因靠字段直接译码发出微命令，故又有显式编码之称。</p><p>采用字段直接编码方法可用较少的二进制信息表示较多的微操作命令信号。例如，3位二进制代码译码后可表示7个互斥的微命令，留出一种状态表示不发微命令，与直接编码用7位表示7个微命令相比，减少了4位，缩短了微指令的长度。但由于增加了译码电路，使微程序的执行速度稍微减慢。至于操作控制字段应分几段，与需要并行发出的微命令个数有关，若需并行发出8个微命令，就可分8段。每毁的长度可以不等，与具体要求互斥的微命令个数有关，若某类操作要求互<br>斥的微命令仅有6个，则字段只需安排3位即可。</p><h5 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024211729748.png" class="" title="image-20231024211729748"><p>这种方式一个字段的某些微命令还需由另一个字段中的某些微命令来解释，如图所示。图中字段1译码的某些输出受字段2译码输出的控制，由于不是靠字段直接译码发出微命令，故称为字段间接编码，又称隐式编码。这种方法虽然可以进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常用做字段直接编码法的一种辅助手段。</p><h5 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h5><p>直接编码和字段编码（直接和间接）混合使用</p><h4 id="微指令序列地址的形成"><a href="#微指令序列地址的形成" class="headerlink" title="微指令序列地址的形成"></a>微指令序列地址的形成</h4><ul><li>直接由微指令的下地址字段指出</li><li>根据机器指令的操作码形成</li><li>增量计数器</li><li>分支转移</li><li>通过测试网络</li><li>由硬件产生微程序入口地址</li><li>后续微指令地址形成方式原理图</li></ul><h4 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h4><h5 id="水平型微指令"><a href="#水平型微指令" class="headerlink" title="水平型微指令"></a>水平型微指令</h5><p>水平型微指令的特点是一次能定义并执行多个并行操作的微命令。从编码方式看，直接编码、字段直接编码、字段间接编码以及直接和字毁混合编码都属于水平型微指令。其中，直接编码速度最快，字段编码要经过译码，故速度受影响。</p><h5 id="垂直型微指令"><a href="#垂直型微指令" class="headerlink" title="垂直型微指令"></a>垂直型微指令</h5><p>垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令字中，设置微操作码字段，由微操作码规定微指令的功能。通常一条微指令有1-2个微命令，控制1-2种操作。这种微指令不强调其并行控制功能。</p><h5 id="两种微指令格式的比较"><a href="#两种微指令格式的比较" class="headerlink" title="两种微指令格式的比较"></a>两种微指令格式的比较</h5><ul><li>水平型微指令比垂直型微指令 并行操作能力强 ， 灵活性强</li><li>水平型微指令执行一条机器指令所要的 微指令 数目少，速度快</li><li>水平型微指令 用较短的微程序结构换取较长的 微指令结构</li><li>水平型微指令与机器指令 差别大</li></ul><h4 id="静态微程序设计和动态微程序设计"><a href="#静态微程序设计和动态微程序设计" class="headerlink" title="静态微程序设计和动态微程序设计"></a>静态微程序设计和动态微程序设计</h4><p>通常指令系统是固定的，对应每一条机器指令的微程序是计算机设计者事先编好的，因此一般微程序无须改变，这种微程序设计技术即称为静态微程序设计，其控制存储器采用ROM。前面讲述的内容基本上属于这一类。</p><p>如果采用EPROM作为控制存储器，人们可以通过改变微指令和微程序来改变机器的指令系统，这种微程序设计技术称为动态微程序设计。动态微程序设计由于可以根据需要改变微指令和微程序，因此可以在一台机器上实现不同类型的指令系统，有利于仿真。但是这种设计对用户的要求很高，目前难以推广。</p><h4 id="毫微程序设计"><a href="#毫微程序设计" class="headerlink" title="毫微程序设计"></a>毫微程序设计</h4><h5 id="毫微程序设计的基本概念"><a href="#毫微程序设计的基本概念" class="headerlink" title="毫微程序设计的基本概念"></a>毫微程序设计的基本概念</h5><p>微程序可看做是解释机器指令的，毫微程序可看做是解释微程序的，而组成毫微程序的毫微指令则是用来解释微指令的。采用毫微程序设计计算机的优点是用少量的控制存储器空间来达到高度的并行。</p><h5 id="毫微程序控制存储器的基本组成"><a href="#毫微程序控制存储器的基本组成" class="headerlink" title="毫微程序控制存储器的基本组成"></a>毫微程序控制存储器的基本组成</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024212452031.png" class="" title="image-20231024212452031"><h4 id="串行微程序控制和并行微程序控制"><a href="#串行微程序控制和并行微程序控制" class="headerlink" title="串行微程序控制和并行微程序控制"></a>串行微程序控制和并行微程序控制</h4><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%9D/image-20231024212523154.png" class="" title="image-20231024212523154">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制单元的功能(八)</title>
    <link href="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/"/>
    <url>/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<p>本章结合指令周期的4个阶段，着重分析控制单元为完成不同指令所发出的各种操作命令一这些命令（又称控制信号）控制计算机的所有部件有次序地完成相应的操作，以达到执行程序的目的一旨在使读者进一步理解指令周期、机器周期、时钟周期（节拍）和控制信号的关系，进一步体会控制单元在机器运行中所起到的核心作用，为下一章设计控制单元打好基础。</p><span id="more"></span><h3 id="微操作命令的分析"><a href="#微操作命令的分析" class="headerlink" title="微操作命令的分析"></a>微操作命令的分析</h3><p>控制单元具有发出各种微操作命令（即控制信号)序列的功能。概括地说，计算机的功能就是执行程序。在执行程序的过程中，控制单元要发出各种微操作命令，而且不同的指令对应不同的命令。进一步分析发现，完成不同指令的过程中，有些操作是相同或相似的，如取指令、取操作数地址（当间接寻址时）以及进入中断周期由中断隐指令完成的一系列操作。为更清晰起见，下面按指令周期的4个阶段进一步分析其对应的微操作命令。</p><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>为了便于讨论，假设CPU内有4个寄存器。MAR与地址总线相连，存放欲访问的存储单元地址；MDR与数据总线相连，存放欲写入存储器的信息或最近从存储器中读出的信息；PC存放现行指令的地址，有计数功能；IR存放现行指令。取指令的过程可归纳为以下几个操作。</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024173214170.png" class="" title="image-20231024173214170"><ol><li>现行指令地址送至存储器地址寄存器，记作PC→MAR。</li><li>向主存发送读命令，启动主存作读操作，记作1→R。</li><li>将MAR(通过地址总线)所指的主存单元中的内容（指令）经数据总线读至MDR内，记作M(MAR)→MDR。</li><li>将MDR的内容送至IR,记作MDR→IR。</li><li>指令的操作码送至CU译码，记作OP(PC)→CU。</li><li>形成下一条指令的地址，记作(PC)+1→PC。</li></ol><h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>间址周期完成取操作数有效地址的任务，具体操作如下。</p><ol><li>将指令的地址码部分（形式地址）送至存储器地址寄存器，记作Ad(IR)→MAR。</li><li>向主存发送读命令，启动主存作读操作，记作1→R。</li><li>将MAR(通过地址总线)所指的主存单元中的内容（有效地址）经数据总线读至MDR内，记作M(MAR)→MDR。</li><li>将有效地址送至指令寄存器的地址字段，记作MDR→Ad(IR)。此操作在有些机器中可省略。</li></ol><h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><p>不同指令执行周期的微操作是不同的，下面分别讨论非访存指令、访存指令和转移类指令的微操作。</p><h5 id="1-非访存指令"><a href="#1-非访存指令" class="headerlink" title="1.非访存指令"></a>1.非访存指令</h5><p>这类指令在执行周期不访问存储器。</p><ul><li>清除累加器指令CLA</li></ul><p>该指令在执行阶段只完成清除累加器操作，记作0→ACC。</p><ul><li>累加器取反指令COM</li></ul><p>该指令在执行阶段只完成累加器内容取反，结果送累加器的操作。</p><ul><li>算术右移一位指令SHR</li></ul><p>该指令在执行阶段只完成累加器内容算术右移一位的操作，记作L(ACC)→R(ACC),ACC<del>0</del>→ACC<del>0</del>(ACC的符号位不变)。</p><ul><li>循环左移一位指令CSL</li></ul><p>该指令在执行阶段只完成累加器内容循环左移一位的操作，记作R(ACC)→L(ACC),ACC<del>0</del>→ACC<del>0</del>（或p^-1^(ACC))。</p><ul><li>停机指令STP</li></ul><p>计算机中有一个运行标志触发器C,当G&#x3D;1时，表示机器运行；当G&#x3D;0时，表示停机。STP令在执行阶段只需将运行标志触发器置“0”，记作0→G。</p><h5 id="2-访存指令"><a href="#2-访存指令" class="headerlink" title="2.访存指令"></a>2.访存指令</h5><p>这类指令在执行阶段都需要访问存储器。为简单起见，这里只考虑直接寻址的情况，不考虑其他寻址方式。</p><ul><li>加法指令ADDX</li></ul><p>该指令在执行阶段需要完成累加器内容与对应于主存X地址单元的内容相加，结果送累加器的操作，具体如下：</p><ol><li>将指令的地址码部分送至存储器地址寄存器，记作Ad(IR)+MAR。</li><li>向主存发读命令，启动主存作读操作，记作1→R。</li><li>将MAR(通过地址总线)所指的主存单元中的内容（操作数）经数据总线读至MDR内，记作M(MAR)→MDR。</li><li>给ALU发送加命令，将ACC的内容和MDR的内容相加，结果存于ACC,记作（ACC)+(MDR)→ACC。</li></ol><p>当然，也有的加法指令指定两个寄存器的内容相加，如“ADD AX,BX”,该指令在执行阶段无须访存，只需完成（AX)+（BX)→AX的操作。</p><ul><li>存数指令STA X</li></ul><p>该指令在执行阶段需将累加器ACC的内容存于主存的X地址单元中，具体操作如下。</p><ol><li>将指令的地址码部分送至存储器地址寄存器，记作Ad(IR)→MAR。</li><li>向主存发写命令，启动主存作写操作，记作1→W。</li><li>将累加器内容送至MDR,记作ACC→MDR。</li><li>将MDR的内容（通过数据总线）写入到MAR(通过地址总线)所指的主存单元中，记作MDR→M(MAR)。</li></ol><ul><li>取数指令LDA X</li></ul><p>该指令在执行阶段需将主存X地址单元的内容取至累加器ACC中，具体操作如下。</p><ol><li>将指令的地址码部分送至存储器地址寄存器，记作Ad(R)→MAR。</li><li>向主存发读命令，启动主存作读操作，记作1→R。</li><li>将MAR(通过地址总线)所指的主存单元中的内容（操作数）经数据总线读至MDR内，记作M(MAR)→MDR。</li><li>将MDR的内容送至ACC,记作MDR→ACC。</li></ol><h5 id="转移类指令"><a href="#转移类指令" class="headerlink" title="转移类指令"></a>转移类指令</h5><p>这类指令在执行阶段也不访问存储器。</p><h6 id="1-无条件转移指令JMP-X"><a href="#1-无条件转移指令JMP-X" class="headerlink" title="1.无条件转移指令JMP X"></a>1.无条件转移指令JMP X</h6><p>该指令在执行阶段完成将指令的地址码部分X送至PC的操作，记作Ad(IR)→PC。</p><h6 id="2-条件转移（负则转）指令BAN-X"><a href="#2-条件转移（负则转）指令BAN-X" class="headerlink" title="2.条件转移（负则转）指令BAN X"></a>2.条件转移（负则转）指令BAN X</h6><p>该指令根据上一条指令运行的结果决定下一条指令的地址，若结果为负（累加器最高位为1,即A<del>0</del>&#x3D;1),则指令的地址码送至PC，否则程序按原顺序执行。由于在取指阶段已完成了(PC)+1→PC,所以当累加器结果不为负（即A<del>0</del>&#x3D;0)时，就按取指阶段形成的PC执行。</p><h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>在执行周期结束时刻，CPU要查询是否有请求中断的事件发生，如果有则进入中断周期。在中断周期，由中断隐指令自动完成保护断点、寻找中断服务程序入口地址以及硬件关中断的操作。假设程序断点存至主存的0地址单元，且采用硬件向量法寻找入口地址，则在中断周期需完成如下操作。</p><ol><li>将特定地址“0”送至存储器地址寄存器，记作0→MAR。</li><li>向主存发写命令，启动存储器作写操作，记作1→W。</li><li>将PC的内容（程序断点）送至MDR,记作PC-→MDR。</li><li>将MDR的内容（程序断点）通过数据总线写入到MAR(通过地址总线)所指示的主存单元(0地址单元)中，记作MDR→M(MAR)。</li><li>将向量地址形成部件的输出送至PC，记作向量地址→PC,为下一条指令的取指周期作准备。</li><li>关中断，将允许中断触发器清零，记作0→EINT。</li></ol><p>如果程序断点存人堆栈，而且进栈操作是先修改栈指针，后存人数据），只需将上述①改为(SP)-1→SP,且SP→MAR。<br>上述所有操作都是在控制单元发出的控制信号（即微操作命令）控制下完成的。</p><h3 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h3><h4 id="控制单元的外特性"><a href="#控制单元的外特性" class="headerlink" title="控制单元的外特性"></a>控制单元的外特性</h4><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024175046452.png" class="" title="image-20231024175046452"><h5 id="输入信号"><a href="#输入信号" class="headerlink" title="输入信号"></a>输入信号</h5><h6 id="1-时钟"><a href="#1-时钟" class="headerlink" title="(1)时钟"></a>(1)时钟</h6><p>上述各种操作有以下两点应特别注意。</p><ol><li>完成每个操作都需占用一定的时间。</li><li>各个操作是有先后顺序的。例如，存储器读操作要用到MAR中的地址，故PC→MAR应先于M(MAR)→MDR。</li></ol><p>为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即每一个时钟脉神使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令。</p><h6 id="2-指令寄存器"><a href="#2-指令寄存器" class="headerlink" title="(2)指令寄存器"></a>(2)指令寄存器</h6><p>现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，故指令的操作码字段是控制单元的输入信号，它与时钟配合可产生不同的控制信号。</p><h6 id="3-标志"><a href="#3-标志" class="headerlink" title="(3)标志"></a>(3)标志</h6><p>控制单元有时需依赖CPU当前所处的状态（如ALU操作的结果）产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负而产生不同的控制信号。因此“标志”也是控制单元的输入信号。</p><h6 id="4-来自系统总线（控制总线）的控制信号"><a href="#4-来自系统总线（控制总线）的控制信号" class="headerlink" title="(4)来自系统总线（控制总线）的控制信号"></a>(4)来自系统总线（控制总线）的控制信号</h6><p>例如，中断请求、DMA请求。</p><h5 id="2-输出信号"><a href="#2-输出信号" class="headerlink" title="2.输出信号"></a>2.输出信号</h5><h6 id="1-CPU内的控制信号"><a href="#1-CPU内的控制信号" class="headerlink" title="(1)CPU内的控制信号"></a>(1)CPU内的控制信号</h6><p>主要用于CPU内的寄存器之间的传送和控制AU实现不同的操作。</p><h6 id="2-送至系统总线（控制总线）的信号"><a href="#2-送至系统总线（控制总线）的信号" class="headerlink" title="(2)送至系统总线（控制总线）的信号"></a>(2)送至系统总线（控制总线）的信号</h6><p>例如，命令主存或&#x2F;0读&#x2F;写、中断响应等。</p><h4 id="控制信号举例"><a href="#控制信号举例" class="headerlink" title="控制信号举例"></a>控制信号举例</h4><p>控制单元的主要功能就是能发出各种不同的控制信号。下面以间接寻址的加法指令“ADD@X”为例，进一步理解控制信号在完成一条指令的过程中所起的作用。</p><h5 id="不采用CPU内部总线的方式"><a href="#不采用CPU内部总线的方式" class="headerlink" title="不采用CPU内部总线的方式"></a>不采用CPU内部总线的方式</h5><h6 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a>取指周期</h6><ol><li>控制信号C0有效，打开PC送往MAR的控制门。</li><li>控制信号C1有效，打开MAR送往地址总线的输出门。</li><li>通过控制总线向主存发读命令。</li><li>C2有效，打开数据总线送至MDR的输人门。</li><li>C3有效，打开MDR和R之间的控制门，至此指令送至IR。</li><li>C4有效，打开指令操作码送至CU的输出门。CU在操作码和时钟的控制下，可产生各种控制信号。</li><li>使PC内容加1（图中未标出）。</li></ol><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024175446088.png" class="" title="image-20231024175446088"><h6 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a>间址周期</h6><ol><li>C5有效，打开MDR和MAR之间的控制门，将指令的形式地址送至MAR。</li><li>C1有效，打开MAR送往地址总线的输出门。</li><li>通过控制总线向主存发读命令。</li><li>C2有效，打开数据总线送至MDR的输人门，至此，有效地址存人MDR。</li><li>C3有效，打开MDR和IR之间的控制门，将有效地址送至IR的地址码字段。</li></ol><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024175739468.png" class="" title="image-20231024175739468"><h6 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a>执行周期</h6><ol><li>C5有效，打开MDR和MAR之间的控制门，将有效地址送至MAR。</li><li>C1有效，打开MAR送往地址总线的输出门。</li><li>通过控制总线向主存发读命令。</li><li>C2有效，打开数据总线送至MDR的输人门，至此，操作数存人MDR。</li><li>C6、C7同时有效，打开AC和MDR通往ALU的控制门。</li><li>通过CPU内部控制总线对ALU发“ADD”加控制信号，完成AC的内容和MDR的内容相加。</li><li>C8有效，打开ALU通往AC的控制门，至此将求和结果存人AC。</li></ol><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024180000898.png" class="" title="image-20231024180000898"><h5 id="采用-CPU-内部总线方式"><a href="#采用-CPU-内部总线方式" class="headerlink" title="采用 CPU 内部总线方式"></a>采用 CPU 内部总线方式</h5><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024180138627.png" class="" title="image-20231024180138627"><p>下面仍以完成间接寻址的加法指令“ADD@X”为例，分析控制单元发出的控制信号。</p><h6 id="取指周期-2"><a href="#取指周期-2" class="headerlink" title="取指周期"></a>取指周期</h6><ol><li>PC<del>0</del>和MAR<del>i</del>有效，完成PC经内部总线送至MAR的操作，即PC→MAR。</li><li>通过控制总线（图中未画出）向主存发读命令，即1→R。</li><li>存储器通过数据总线将MAR所指单元的内容（指令）送至MDR。</li><li>MDR<del>0</del>和IR<del>i</del>有效，将MDR的内容送至IR,即MDR→IR,至此，指令送至IR,其操作码字段开始控制CU。</li><li>使PC内容加1（图中未标出）。</li></ol><h6 id="间址周期-2"><a href="#间址周期-2" class="headerlink" title="间址周期"></a>间址周期</h6><ol><li>MDR<del>0</del>和MAR<del>i</del>有效，将指令的形式地址经内部总线送至MAR,即MDR→MAR。</li><li>通过控制总线向主存发读命令，即1→R。</li><li>存储器通过数据总线将MAR所指单元的内容（有效地址）送至MDR。</li><li>MDR<del>0</del>和IR<del>i</del>有效，将MDR中的有效地址送至R的地址码字段，即MDR→Ad(IR)。</li></ol><h6 id="执行周期-2"><a href="#执行周期-2" class="headerlink" title="执行周期"></a>执行周期</h6><ol><li>MDR<del>0</del>和MAR<del>i</del>有效，将有效地址经内部总线送至MAR,即MDR→MAR。</li><li>通过控制总线向主存发读命令，即1+R。</li><li>存储器通过数据总线将MAR所指单元的内容（操作数）送至MDR。</li><li>MDR<del>0</del>和Y<del>i</del>有效，将操作数送至Y,即MDR→Y。</li><li>AC<del>0</del>和ALU<del>i</del>有效，同时CU向ALU发“ADD”加控制信号，使AC的内容和Y的内容相加(Y的内容送至ALU不必通过总线)，结果送寄存器Z,即（AC)+(Y)→Z。</li><li>乙<del>0</del>和AC,有效，将运算结果存入AC,即Z→AC。</li></ol><h4 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h4><h5 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h5><h6 id="机器周期的概念"><a href="#机器周期的概念" class="headerlink" title="机器周期的概念"></a>机器周期的概念</h6><p>机器周期可看做是所有指令执行过程中的一个基准时间，机器周期取决于指令的功能及器件的速度。确定机器周期时，通常要分析机器指令的执行步骤及每一步骤所需的时间。</p><h6 id="确定机器周期需考虑的因素"><a href="#确定机器周期需考虑的因素" class="headerlink" title="确定机器周期需考虑的因素"></a>确定机器周期需考虑的因素</h6><p>每条指令的执行步骤每一步骤所需的时间</p><h6 id="基准时间的确定"><a href="#基准时间的确定" class="headerlink" title="基准时间的确定"></a>基准时间的确定</h6><ul><li>以完成最复杂指令功能的时间为准 </li><li>以访问一次存储器的时间为基准</li></ul><h5 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h5><p>一个机器周期内可完成若干个微操作每个微操作需一定的时间时钟周期是控制计算机操作的最小单位时间将一个机器周期分成若干个时间相等的时间段（节拍、状态、时钟周期）</p><p>时钟周期是控制计算机操作的最小单位时间用时钟周期控制产生一个或几个微操作命令</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024204215351.png" class="" title="image-20231024204215351"><h5 id="多级时序系统-1"><a href="#多级时序系统-1" class="headerlink" title="多级时序系统"></a>多级时序系统</h5><p>机器周期、节拍（状态组成多级时序系统一个指令周期包含若干个机器周期一个机器周期包含若干个时钟周期</p><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>控制单元控制一条指令执行的过程实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及其复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。通常将如何形成控制不同微操作序列所采用的时序控制方式称为CU的控制方式。常见的控制方式有同步控制、异步控制、联合控制和人工控制四种。</p><h5 id="同步控制方式"><a href="#同步控制方式" class="headerlink" title="同步控制方式"></a>同步控制方式</h5><p>同步控制方式是指，任何一条指令或指令中任何一个微操作的执行都是事先确定的，并且都是受统一基准时标的时序信号所控制的方式。</p><p>如果机器内的存储器存取周期不统一，那么只有把最长的存取周期作为机器周期，才能采用同步控制，否则取指令和取数时间不同，无法用统一的基准。又如有些不访存的指令，执行周期的微操作较少，无须4个节拍。因此，为了提高CPU的效率，在同步控制中又有三种方案。</p><h6 id="采用定长的机器周期"><a href="#采用定长的机器周期" class="headerlink" title="采用定长的机器周期"></a>采用定长的机器周期</h6><p>这种方案的特点是：不论指令所对应的微操作序列有多长，也不管微操作的简繁，一律以最长的微操作序列和最繁的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行各种不同的指令，显然，这种方案对于微操作序列较短的指令来说，会造成时间上的浪费。</p><h6 id="采用不定长的机器周期"><a href="#采用不定长的机器周期" class="headerlink" title="采用不定长的机器周期"></a>采用不定长的机器周期</h6><p>采用这种方案时，每个机器周期内的节拍数可以不等，如图9.9(b)所示。这种控制方式可解决微操作执行时间不统一的问题。通常把大多数微操作安排在一个较短的机器周期内完成，而对某些复杂的微操作，采用延长机器周期或增加节拍的办法来解决</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024204712457.png" class="" title="image-20231024204712457"><h6 id="采用中央控制和局部控制相结合的方法"><a href="#采用中央控制和局部控制相结合的方法" class="headerlink" title="采用中央控制和局部控制相结合的方法"></a>采用中央控制和局部控制相结合的方法</h6><p>这种方案将机器的大部分指令安排在统一的、较短的机器周期内完成，称为中央控制，而将少数操作复杂的指令中的某些操作（如乘除法和浮点运算等）采用局部控制方式来完成。在设计局部控制线路时需要注意两点：其一，使局部控制的每一个节拍T*的宽度与中央挖制的节拍宽度相同；其二，将局部控制节拍作为中央控制中机器节拍的延续，插人到中央控制的执行周期内，使机器以同样的节奏工作，保证了局部控制和中央控制的同步。T·的多少可根据情况而定，对于乘法，当操作数位数固定后，T的个数也就确定了。而对于浮点运算的对阶操作，由于移位次数不是一个固定值，因此T的个数不能事先确定。</p><img src="/2023/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AB/image-20231024204833167.png" class="" title="image-20231024204833167"><h5 id="异步控制方式"><a href="#异步控制方式" class="headerlink" title="异步控制方式"></a>异步控制方式</h5><p>异步控制方式不存在基准时标信号，没有固定的周期节拍和严格的时钟同步，执行每条指令和每个操作需要多少时间就占用多少时间。这种方式微操作的时序由专门的应答线路控制，即当CPU发出执行某一微操作的控制信号后，等待执行部件完成了该操作后发回“回答”（或“结束”)信号，再开始新的微操作，使CPU没有空闲状态，但因需要采用各种应答电路，故其结构比同步控制方式复杂。</p><h5 id="联合控制方式"><a href="#联合控制方式" class="headerlink" title="联合控制方式"></a>联合控制方式</h5><p>同步控制和异步控制相结合就是联合控制方式。这种方式对各种不同指令的微操作实行大部分统一、小部分区别对待的办法。例如，对每条指令都有的取指令操作，采用同步方式控制；对那些时间难以确定的微操作，如I&#x2F;O操作，则采用异步控制，以执行部件送回的“回答”信号作为本次微操作的结束。</p><h6 id="人工控制方式"><a href="#人工控制方式" class="headerlink" title="人工控制方式"></a>人工控制方式</h6><p>人工控制是为了调机和软件开发的需要，在机器面板或内部设置一些开关或按键，来达到人工控制的目的。</p><ul><li>Reset(复位)键</li></ul><p>按下Rst键，使计算机处于初始状态。当机器出现死锁状态或无法继续运行时，可按此键。若在机器运行时按此键，将会破坏机器内某些状态而引起错误，因此要慎用。有些微型计算机未设此键，当机器死锁时，可采用停电后再加电的办法重新启动计算机。</p><ul><li>连续或单条执行转换开关</li></ul><p>由于调机的需要，有时需要观察执行完一条指令后的机器状态，有时又需要观察连续运行程序后的结果，设置连续或单条执行转换开关，能为用户提供这两种选择。</p><ul><li>符合停机开关</li></ul><p>有些计算机还配有符合停机开关，这组开关指示存储器的位置，当程序运行到与开关指示的地址相符时，机器便停止运行，称为符合停机。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU的结构与性能(七)</title>
    <link href="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/"/>
    <url>/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<p>本章从分析CPU的功能和内部结构入手，详细讨论机器完成一条指令的全过程，以及为了进一步提高数据的处理能力、开发系统的并行性所采取的流水技术。此外，本章还进一步概括了中断技术在提高整机系统效能方面的作用。通过本章的学习，希望读者对CPU在计算机中的地位和作用以及对中断概念的理解比前面章节更加深入。</p><span id="more"></span><h3 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h3><h4 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h4><p>由第1章可知，CPU实质包括运算器和控制器两大部分，前面讨论了计算机内各种运算及相应的硬件配置，这里重点介绍控制器的功能。对于冯·诺依曼结构的计算机而言，一旦程序进人存储器后，就可由计算机自动完成取指令和执行指令的任务，控制器就是专用于完成此项工作的，它负责协调并控制计算机各部件执行程序的指令序列，其基本功能是取指令、分析指令和执行指令。</p><ul><li>取指令</li></ul><p>控制器必须具备能自动地从存储器中取出指令的功能。为此，要求控制器能自动形成指令的地址，并能发出取指令的命令，将对应此地址的指令取到控制器中。第一条指令的地址可以人为指定，也可由系统设定。</p><ul><li>分析指令</li></ul><p>分析指令包括两部分内容：其一，分析此指令要完成什么操作，即控制器需发出什么操作命令；其二，分析参与这次操作的操作数地址，即操作数的有效地址。</p><ul><li>执行指令</li></ul><p>执行指令就是根据分析指令产生的“操作命令”和“操作数地址”的要求，形成操作控制信号序列（不同的指令有不同的操作控制信号序列），通过对运算器、存储器以及I&#x2F;O设备的操作，执行每条指令。</p><p>此外，控制器还必须能控制程序的输入和运算结果的输出（即控制主机与I&#x2F;O设备交换信息)以及对总线的管理，甚至能处理机器运行过程中出现的异常情况（如掉电）和特殊请求（如打印机请求打印一行字符)，即处理中断的能力。总之，CPU必须具有控制程序的顺序执行（称指令控制）、产生完成每条指令所需的控制命令（称操作控制）、对各种操作加以时间上的控制（称时间控制）、对数据进行算术运算和逻辑运算（数据加工）以及处理中断等功能。</p><h4 id="CPU结构框图"><a href="#CPU结构框图" class="headerlink" title="CPU结构框图"></a>CPU结构框图</h4><h5 id="CPU-与系统总线"><a href="#CPU-与系统总线" class="headerlink" title="CPU 与系统总线"></a>CPU 与系统总线</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018155110735.png" class="" title="image-20231018155110735"><p>根据CPU的功能不难设想，要取指令，必须有一个寄存器专用于存放当前指令的地址：要分析指令，必须有存放当前指令的寄存器和对指令操作码进行译码的部件；要执行指令，必须有一个能发出各种操作命令序列的控制部件CU;要完成算术运算和逻辑运算，必须有存放操作数的寄存器和实现算逻运算的部件ALU;为了处理异常情况和特殊请求，还必须有中断系统。可见，CPU可由四大部分组成图中ALU部件实际上只对CPU内部寄存器的数据进行操作，有关ALU的内容已在前面介绍过</p><h5 id="CPU-的内部结构"><a href="#CPU-的内部结构" class="headerlink" title="CPU 的内部结构"></a>CPU 的内部结构</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018155252911.png" class="" title="image-20231018155252911"><h4 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h4><p>存储器章节示出了存储器速度、容量和位价的关系，最上层的寄存器速度最快，容量最小，位价最贵，它们通常设在CPU内部。CPU中的寄存器大致可分两类：一类属于用户可见寄存器，用户可对这类寄存器编程，以及通过优化使CPU因使用这类寄存器而减少对主存的访问次数；另一类属于控制和状态寄存器，用户不可对这类寄存器编程，它们被控制部件使用，以控制CPU的操作，也可被带有特权的操作系统程序使用，从而控制程序的执行。</p><h5 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h5><ul><li>通用寄存器</li></ul><p>通用寄存器可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。例如，基址寻址所需的基址寄存器、变址寻址所需的变址寄存器和堆栈寻址所需的栈指针，都可用通用寄存器代替。寄存器间接寻址时还可用通用寄存器存放有效地址的地址。</p><ul><li>数据寄存器</li></ul><p>数据寄存器用于存放操作数，其位数应满足多数数据类型的数值范围，有些机器允许使用两个连读的寄存器存放双倍字长的值。还有些机器的数据寄存器只能用于保存数据，不能用于操作数地址的计算。</p><ul><li>地址寄存器</li></ul><p>地址寄存器用于存放地址，其本身可以具有通用性，也可用于特殊的寻址方式，如用于基址寻址的段指针（存放基地址）、用于变址寻址的变址寄存器和用于堆栈寻址的栈指针。地址寄存器的位数必须足够长，以满足最大的地址范围。</p><ul><li>条件码寄存器</li></ul><p>这类寄存器中存放条件码，它们对用户来说是部分透明的。.条件码是CPU根据运算结果由硬件设置的位，例如，算术运算会产生正、负、零或溢出等结果。条件码可被测试，作为分支运算的依据。此外，有些条件码也可被设置，例如，对于最高位进位标志C,可用指令对它置位和复位。将条件码放到一个或多个寄存器中，就构成了条件码寄存器。在调用子程序前，必须将所有的用户可见寄存器的内容保存起来，这种保存可由CPU自动完成，也可由程序员编程保存，视不同机器进行不同处理。</p><h5 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h5><p>CPU中还有一类寄存器用于控制CPU的操作或运算。在一些机器里，大部分这类寄存器对用户是透明的。如以下四种寄存器在指令执行过程中起重要作用。</p><ul><li>MAR:存储器地址寄存器，用于存放将被访问的存储单元的地址。</li><li>MDR:存储器数据寄存器，用于存放欲存入存储器中的数据或最近从存储器中读出的数据。</li><li>PC：程序计数器，存放现行指令的地址，通常具有计数功能。当遇到转移类指令时，PC的值可被修改。</li><li>IR:指令寄存器，存放当前欲执行的指令。</li></ul><p>通过这4个寄存器，CPU和主存可交换信息。例如，将现行指令地址从PC送至MAR,启动存储器作读操作，存储器就可将指定地址单元内的指令读至MDR,再由MDR送至IR:在CPU内部必须给ALU提供数据，因此ALU必须可直接访问MDR和用户可见寄存器，ALU的外围还可以有另一些寄存器，这些寄存器用于ALU的输人&#x2F;输出以及用于和MDR及用户可见寄存器交换数据。在CPU的控制和状态寄存器中，还有用来存放程序状态字PSW的寄存器，该寄存器用来存放条件码和其他状态信息。在具有中断系统的机器中还有中断标记寄存器。</p><h5 id="控制单元和中断系统"><a href="#控制单元和中断系统" class="headerlink" title="控制单元和中断系统"></a>控制单元和中断系统</h5><p>控制单元(CU)是提供完成计算机全部指令操作的微操作命令序列部件。现代计算机中微操作命令序列的形成方法有两种：一种是组合逻辑设计方法，为硬连线逻辑；另一种是微程序设计方法，为存储逻辑。具体内容详见后面章节。中断系统主要用于处理计算机的各种中断，详细内容在后面节介绍。</p><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><h4 id="指令周期的基本概念"><a href="#指令周期的基本概念" class="headerlink" title="指令周期的基本概念"></a>指令周期的基本概念</h4><p>CPU每取出并执行一条指令所需的全部时间称为指令周期，也即CPU完成一条指令的时间。图中的取指阶段完成取指令和分析指令的操作，又称取指周期；执行阶段完成执行指令的操作，又称执行周期。在大多数情况下，CPU就是按“取指一执行一再取指一再执行…”的顺序自动工作的。</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018160259552.png" class="" title="image-20231018160259552"><h5 id="每条指令的指令周期不同"><a href="#每条指令的指令周期不同" class="headerlink" title="每条指令的指令周期不同"></a>每条指令的指令周期不同</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018160410801.png" class="" title="image-20231018160410801"><p>由于各种指令操作功能不同，因此各种指令的指令周期是不相同的。例如，无条件转移指令“JMPX”,在执行阶段不需要访问主存，而且操作简单，完全可以在取指阶段的后期将转移地址X送至PC,以达到转移的目的。这样，“JMPX”指令的指令周期就是取指周期。又如一地址格式的加法指令“ADD.X”,在执行阶段首先要从X所指示的存储单元中取出操作数，然后和ACC的内容相加，结果存于ACC,故这种指令的指令周期在取指和执行阶段各访问一次存储器，其指<br>令周期就包括两个存取周期。再如乘法指令，其执行阶段所要完成的操作比加法指令多得多，故它的执行周期超过了加法指令</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018160716293.png" class="" title="image-20231018160716293"><p>此外，当遇到间接寻址的指令时，由于指令字中只给出操作数有效地址的地址，因此，为了取出操作数，需先访问一次存储器，取出有效地址，然后再访问存储器，取出操作数。这样，间接寻址的指令周期就包括取指周期、间址周期和执行周期3个阶段，其中间址周期用于取操作数的有效地址，因此间址周期介于取指周期和执行周期之间.</p><p>当CPU采用中断方式实现主机与I&#x2F;O设备交换信息时，CPU在每条指令执行阶段结束前，都要发中断查询信号，以检测是否有某个I&#x2F;O设备提出中断请求。如果有请求，CPU则要进入中断响应阶段，又称中断周期。在此阶段，CPU必须将程序断点保存到存储器中。这样，一个完整的指令周期应包括取指、间址、执行和中断4个子周期</p><h5 id="指令周期流程"><a href="#指令周期流程" class="headerlink" title="指令周期流程"></a>指令周期流程</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018160745486.png" class="" title="image-20231018160745486"><h5 id="CPU-工作周期的标志"><a href="#CPU-工作周期的标志" class="headerlink" title="CPU 工作周期的标志"></a>CPU 工作周期的标志</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018161427508.png" class="" title="image-20231018161427508"><h4 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h4><p>为了便于分析指令周期中的数据流，假设CPU中有存储器地址寄存器MAR、存储器数据寄存器MDR、程序计数器PC和指令寄存器IR。</p><h5 id="取指周期数据流"><a href="#取指周期数据流" class="headerlink" title="取指周期数据流"></a>取指周期数据流</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018161622798.png" class="" title="image-20231018161622798"><p>图所示的是取指周期的数据流。PC中存放现行指令的地址，该地址送到MAR并送至地址总线，然后由控制部件CPU向存储器发读命令，使对应MAR所指单元的内容（指令）经数据总线送至MDR,再送至IR,并且CU控制PC内容加1，形成下一条指令的地址。</p><h5 id="间址周期的数据流"><a href="#间址周期的数据流" class="headerlink" title="间址周期的数据流"></a>间址周期的数据流</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018161806683.png" class="" title="image-20231018161806683"><p>间址周期的数据流如图所示。一旦取指周期结束，CU便检查IR中的内容，以确定其是否有间址操作，如果需要间址操作，则MDR中指示形式地址的右N位（记作Ad(MDR))将被送到MAR,又送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。</p><h5 id="执行周期的数据流"><a href="#执行周期的数据流" class="headerlink" title="执行周期的数据流"></a>执行周期的数据流</h5><p>不同指令的执行周期数据流不同</p><h5 id="中断周期数据流"><a href="#中断周期数据流" class="headerlink" title="中断周期数据流"></a>中断周期数据流</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018163036008.png" class="" title="image-20231018163036008"><p>CPU进入中断周期要完成一系列操作，其中PC当前的内容必须保存起来，以待执行完中断服务程序后可以准确返回到该程序的间断处，这一操作的数据流如图。</p><p>图中由CU把用于保存程序断点的存储器特殊地址（如栈指针的内容）送往MAR,并送到地址总线上，然后由CU向存储器发写命令，并将PC的内容（程序断点）送到MDR,最终使程序断点经数据总线存入存储器。此外，CU还需将中断服务程序的入口地址送至PC,为下一个指令周期的取指周期做好准备。</p><h3 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h3><h4 id="如何提高机器速度"><a href="#如何提高机器速度" class="headerlink" title="如何提高机器速度"></a>如何提高机器速度</h4><ul><li>提高访存速度</li></ul><p>高速芯片 Cache 多体并行</p><ul><li>提高 I&#x2F;O 和主机之间的传送速度</li></ul><p>中断DMA通道I&#x2F;O处理机多总线</p><ul><li>提高运算器速度</li></ul><p>高速芯片 改进算法 快速进位链</p><ul><li>提高整机处理能力</li></ul><p>高速器件 改进系统结构 ，开发系统的并行性</p><h4 id="系统的并行性"><a href="#系统的并行性" class="headerlink" title="系统的并行性"></a>系统的并行性</h4><h5 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h5><p>所谓并行，包含同时性和并发性两个方面。前者是指两个或多个事件在同一时刻发生，后者是指两个或多个事件在同一时间段发生。也就是说，在同一时刻或同一时间段内完成两种或两种以上性质相同或不同的功能，只要在时间上互相重叠，就存在并行性。</p><h5 id="并行性的等级"><a href="#并行性的等级" class="headerlink" title="并行性的等级"></a>并行性的等级</h5><p>并行性体现在不同等级上。通常分为4个级别：作业级或程序级、任务级或进程级、指令之间级和指令内部级。前两级为粗粒度，又称为过程级；后两级为细粒度，又称为指令级。粗粒度并行性(Eoarse-grained Parallelism)一般用算法（软件）实现，细粒度并行性(Fine-grained Parallel–is)一般用硬件实现。从计算机体系上看，粗粒度并行性是在多个处理机上分别运行多个进程，由多台处理机合作完成一个程序；细粒度并行性是指在处理机的操作级和指令级的并行性，其中指令的流水作业就是一项重要技术。这里只讨论有关指令流水的一些主要问题，其他有关粗粒度并行和粗粒度并行技术将在“计算机体系结构”课程中讲述。</p><h4 id="指令流水原理"><a href="#指令流水原理" class="headerlink" title="指令流水原理"></a>指令流水原理</h4><h5 id="指令的串行执行"><a href="#指令的串行执行" class="headerlink" title="指令的串行执行"></a>指令的串行执行</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018163730614.png" class="" title="image-20231018163730614"><p>图中取指令的操作可由指令部件完成，执行指令的操作可由执行部件完成。进一步分析发现，这种顺序执行虽然控制简单，但执行中各部件的利用率不高，如指令部件工作时，执行部件基本空闲，而执行部件工作时，指令部件基本空闲。如果指令执行阶段不访问主存，则完全可以利用这段时间取下一条指令，这样就使取下一条指令的操作和执行当前指令的操作同时进行，</p><h5 id="指令的二级流水"><a href="#指令的二级流水" class="headerlink" title="指令的二级流水"></a>指令的二级流水</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018163902171.png" class="" title="image-20231018163902171"><p>由指令部件取出一条指令，并将它暂存起来，如果执行部件空闲，就将暂存的指令传给执行部件执行。与此同时，指令部件又可取出下一条指令并暂存起来，这称为指令预取。显然，这种工作方式能加速指令的执行。如果取指和执行阶段在时间上完全重叠，相当于将指令周期诚半。然而进一步分析流水线，就会发现存在两个原因使得执行效率如倍是不可能的。</p><h5 id="影响指令流水效率加倍的因素"><a href="#影响指令流水效率加倍的因素" class="headerlink" title="影响指令流水效率加倍的因素"></a>影响指令流水效率加倍的因素</h5><ul><li><p>执行时间 &gt; 取指时间</p></li><li><p>条件转移指令 对指令流水的影响</p></li></ul><p>尽管这些因素降低了两级流水线的潜在效率，但还是可以获得一定程度的加速。为了进一步提高处理速度，可将指令的处理过程分解为更细的几个阶段。</p><ul><li>取指(FI):从存储器取出一条指令并暂时存入指令部件的缓神区。</li><li>指令译码(DI):确定操作性质和操作数地址的形成方式。</li><li>计算操作数地址(CO):计算操作数的有效地址，涉及寄存器间接寻址、间接寻址、变址、基址、相对寻址等各种地址计算方式。</li><li>取操作数(FO):从存储器中取操作数（若操作数在寄存器中，则无须此阶段）。</li><li>执行指令(EI):执行指令所需的操作，并将结果存于目的位置（寄存器中）。</li><li>写操作数(W0):将结果存入存储器。</li></ul><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018165930561.png" class="" title="image-20231018165930561"><h4 id="影响指令流水线性能的因素"><a href="#影响指令流水线性能的因素" class="headerlink" title="影响指令流水线性能的因素"></a>影响指令流水线性能的因素</h4><p>要使流水线具有良好的性能，必须设法使流水线能畅通流动，即必须做到充分流水，不发生断流。但通常由于在流水过程中会出现三种相关，使流水线不断流实现起来很困难，这三种相关是结构相关、数据相关和控制相关。</p><h5 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h5><p>结构相关是当指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的，故又有资源相关之称。通常，大多数机器都是将指令和数据保存在同一存储器中，且只有一个访问口，如果在某个时钟周期内，流水线既要完成某条指令对操作数的存储器访问操作，又要完成另一条指令的取指操作，这就会发生访存冲突。</p><p>解决冲突的方法可以让流水线在完成前一条指令对数据的存储器访问时，暂停（一个时钟周期）取后一条指令的操作</p><p>解决访存冲突的另一种方法是设置两个独立的存储器分别存放操作数和指令，以免取指令和取操作数同时进行时互相冲突，使取某条指令和取另一条指令的操作数实现时间上的重叠。</p><h5 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h5><p>不同指令因重叠操作，可能改变操作数的 读&#x2F;写 访问顺序</p><ul><li>写后读相关（RAW）</li></ul><p>SUB R1，R2，R3  ；（R2）-（R3）→ R1 ；</p><p>ADD R4，R5，R1 ；（R5）+（R1）→R4 </p><ul><li>读后写相关（WAR）</li></ul><p> STA M，R2 ；（R2）→ M 存储单元 ；</p><p>ADD R2，R4，R5 ；（R4）+（R5）→ R2 </p><ul><li>写后写相关（WAW）</li></ul><p> MUL R3，R2，R1 ；（R2）× （R1）→ R3 ；</p><p>SUB R3，R4，R5 ；（R4） （R5）→ R3；</p><p>解决方法</p><ul><li>后推法</li><li>采用旁路技术</li></ul><h5 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h5><p>控制相关主要是由转移指令引起的。统计表明，转移指令约占总指令的1&#x2F;4左右，比起数据相关来，它会使流水线丧失更多的性能。当转移发生时，将使流水线的连续流动受到破坏。当执行转移指令时，根据是否发生转移，它可能将程序计数器PC内容改变成转移目标地址，也可能只是使PC加上一个增量，指向下一条指令的地址。</p><p>为了解决控制相关，可以采用尽早判别转移是否发生，尽早生成转移目标地址；预取转移成功或不成功两个控制流方向上的目标指令；加快和提前形成条件码；提高转移方向的猜准率等方法。</p><h4 id="流水线性能"><a href="#流水线性能" class="headerlink" title="流水线性能"></a>流水线性能</h4><p>流水线性能通常用吞吐率、加速比和效率3项指标来衡量。</p><h5 id="吞吐率-Throughput-Rate"><a href="#吞吐率-Throughput-Rate" class="headerlink" title="吞吐率(Throughput Rate)"></a>吞吐率(Throughput Rate)</h5><p>在指令级流水线中，吞吐率是指单位时间内流水线所完成指令或输出结果的数量。吞吐率又有最大吞叶率和实际吞叶率之分。</p><p>中各段都处于工作状态)后所获得的吞吐率。对于m段的指令流水线而言，若各段的时间均为△t，则最大吞吐率为</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018215600825.png" class="" title="image-20231018215600825"><p>实际吞吐率为</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018215643108.png" class="" title="image-20231018215643108"><h5 id="加速比-Speedup-Ratio"><a href="#加速比-Speedup-Ratio" class="headerlink" title="加速比(Speedup Ratio)"></a>加速比(Speedup Ratio)</h5><p>流水线的加速比是指m段流水线的速度与等功能的非流水线的速度之比。如果流水线各段时间均为△t,则完成n条指令在m段流水线上共需T&#x3D;m·△t+（n-1)△时间。而在等效的非流水线上所需时间为T’&#x3D;nm△g。故加速比S。为</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018215816746.png" class="" title="image-20231018215816746"><h5 id="效率-Efficiency"><a href="#效率-Efficiency" class="headerlink" title="效率(Efficiency)"></a>效率(Efficiency)</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018215841836.png" class="" title="image-20231018215841836"><h4 id="流水线中的多发技术"><a href="#流水线中的多发技术" class="headerlink" title="流水线中的多发技术"></a>流水线中的多发技术</h4><h5 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h5><p>每个时钟周期内可 并发多条独立指令 </p><p> 不能调整 指令的 执行顺序 配置多个功能部</p><h5 id="超流水线技术"><a href="#超流水线技术" class="headerlink" title="超流水线技术"></a>超流水线技术</h5><p>在 一个时钟周期 内 再分段 （ 3 段） 在一个时钟周期内 一个功能部件使用多次（ 3 次</p><p> 不能调整 指令的 执行顺序 靠编译程序解决优化问题</p><h5 id="超长指令字技术"><a href="#超长指令字技术" class="headerlink" title="超长指令字技术"></a>超长指令字技术</h5><p>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位）</p><p>采用多个处理部件</p><h4 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h4><h5 id="指令流水线结构"><a href="#指令流水线结构" class="headerlink" title="指令流水线结构"></a>指令流水线结构</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018220148559.png" class="" title="image-20231018220148559"><h5 id="运算流水线"><a href="#运算流水线" class="headerlink" title="运算流水线"></a>运算流水线</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018220228834.png" class="" title="image-20231018220228834"><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h5 id="引起中断的各种因素"><a href="#引起中断的各种因素" class="headerlink" title="引起中断的各种因素"></a>引起中断的各种因素</h5><ul><li>人为设置的中断如转管指令</li><li>程序性事故溢出、操作码不能识别、除法非法</li><li>硬件故障</li><li>I&#x2F;O设备</li><li>外部事件用键盘中断现行程序</li></ul><h5 id="中断系统需解决的问题"><a href="#中断系统需解决的问题" class="headerlink" title="中断系统需解决的问题"></a>中断系统需解决的问题</h5><ol><li>各中断源如何向CPU提出请求？</li><li>各中断源同时提出清求怎公办？</li><li>CPU什么条件、什么时间、以什么方式响应中断？</li><li>如何保护现场？</li><li>如何寻找入口地址？</li><li>如何恢复现场，如何返回？</li><li>处理中断的过程中又出现新的中断怎么办？</li></ol><h4 id="中断请求标记和中断判优逻辑"><a href="#中断请求标记和中断判优逻辑" class="headerlink" title="中断请求标记和中断判优逻辑"></a>中断请求标记和中断判优逻辑</h4><h5 id="中断请求标记"><a href="#中断请求标记" class="headerlink" title="中断请求标记"></a>中断请求标记</h5><p>为了判断是哪个中断源提出请求，在中断系统中必须设置中断请求标记触发器，简称中断请求触发器，记作INTR。当其状态为“1”时，表示中断源有请求。这种触发器可集中设在CPU内，如图，或者分散 在各个中断源的 接口电路中</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018220659746.png" class="" title="image-20231018220659746"><h5 id="中断判优逻辑"><a href="#中断判优逻辑" class="headerlink" title="中断判优逻辑"></a>中断判优逻辑</h5><h6 id="硬件实现（排队器）"><a href="#硬件实现（排队器）" class="headerlink" title="硬件实现（排队器）"></a>硬件实现（排队器）</h6><ul><li>分散 在各个中断源的 接口电路中 链式排队器</li><li>集中 在 CPU 内</li></ul><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018220927198.png" class="" title="image-20231018220927198"><p>这样，当最高优先级的中断源有请求时TR,&#x3D;1,就可封住比它级别低的中断源的请求。</p><h6 id="软件实现（程序查询）"><a href="#软件实现（程序查询）" class="headerlink" title="软件实现（程序查询）"></a>软件实现（程序查询）</h6><p>软件排队是通过编写查询程序实现的，其程序框图如图8.26所示。程序按中断源的优先等级，从高至低逐级：查询各中断源是否有中断请求，这样就可以保证CPU首先响应级别高的中断源的请求。</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018221026694.png" class="" title="image-20231018221026694"><h4 id="中断服务程序入口地址的寻找"><a href="#中断服务程序入口地址的寻找" class="headerlink" title="中断服务程序入口地址的寻找"></a>中断服务程序入口地址的寻找</h4><p>由于不同的中断源对应不同的中断服务程序，故准确找到服务程序的人口地址是中断处理的核心问题。通常有两种方法寻找入口地址：硬件向量法和软件查询法。</p><h5 id="硬件向量法"><a href="#硬件向量法" class="headerlink" title="硬件向量法"></a>硬件向量法</h5><p>硬件向量法就是利用硬件产生向量地址，再由向量地址找到中断服务程序的人口地址。向量地址由中断向重地址形成部件产生，这个电路可分散设置在各个接口电路中（如图5.41中的设备编码器)，也可设置在CPU内，如图8.27所示。由向量地址寻找中断服务程序的入口地址通常采用两种办法。在向量地址内存放一条无条件转移指令，CPU响应中断时，只要将向量地址（如12H)送至PC，执行这条指令，便可无条件转向打印机服务程序的人口地址200。另一种是设置向量地址表。该表设在存储器内，存储单元的地址为向量地址，存储单元的内容为入口地址，例如，图的12H、13H、14H为向量地址，200、300、400为入口地址，只要访问向量地址所指示的存储单元，便可获得入口地址。硬件向量法寻找人口地址速度快，在现代计算机中被普遍采用。</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018221402614.png" class="" title="image-20231018221402614"><h5 id="软件查询法"><a href="#软件查询法" class="headerlink" title="软件查询法"></a>软件查询法</h5><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018221522828.png" class="" title="image-20231018221522828"><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><h5 id="响应中断的条件"><a href="#响应中断的条件" class="headerlink" title="响应中断的条件"></a>响应中断的条件</h5><p>允许中断触发器 EINT &#x3D; 1</p><h5 id="响应中断的时间"><a href="#响应中断的时间" class="headerlink" title="响应中断的时间"></a>响应中断的时间</h5><p>指令执行周期结束时刻由CPU 发查询信号</p><h5 id="中断隐指令"><a href="#中断隐指令" class="headerlink" title="中断隐指令"></a>中断隐指令</h5><p>CPU响应中断后，即进人中断周期。在中断周期内，CPU要自动完成一系列操作，具体如下：</p><ul><li>保护程序断点</li></ul><p>断点存于特定地址（0号地址)内断点进栈</p><ul><li>寻找服务程序入口地址</li></ul><p>向量地址PC(硬件向量法〉</p><p>中断识别程序入口地址M→PC(软件查询法)</p><ul><li>硬件 关中断</li></ul><p>CPU进人中断周期，意味着CPU响应了某个中断源的请求，为了确保CPU响应后所需做的一系列操作不至于又受到新的中断请求的干扰，在中断周期内必须自动关中断，以禁止CPU再次响应新的中断请求。</p><h4 id="保护现场和恢复现场"><a href="#保护现场和恢复现场" class="headerlink" title="保护现场和恢复现场"></a>保护现场和恢复现场</h4><p>保护现场应该包括保护程序断点和保护CPU内部各寄存器内容的现场两个方面。程序断点的现场由中断隐指令完成，各寄存器内的现场可在中断服务程序中由用户（或系统）用机器指令编程实现。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作也由中断服务程序完成.</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018222039678.png" class="" title="image-20231018222039678"><h4 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h4><h5 id="多重中断的概念"><a href="#多重中断的概念" class="headerlink" title="多重中断的概念"></a>多重中断的概念</h5><p>当CPU正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而CPU又响应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序，这称为多重中断，又称中断嵌套，</p><h5 id="实现多重中断的条件"><a href="#实现多重中断的条件" class="headerlink" title="实现多重中断的条件"></a>实现多重中断的条件</h5><ul><li>提前 设置 开中断 指令</li><li>优先级别高 的中断源 有权中断优先级别低 的中断源</li></ul><h5 id="屏蔽技术"><a href="#屏蔽技术" class="headerlink" title="屏蔽技术"></a>屏蔽技术</h5><h6 id="屏蔽触发器的作用"><a href="#屏蔽触发器的作用" class="headerlink" title="屏蔽触发器的作用"></a>屏蔽触发器的作用</h6><p>MASK &#x3D; 0（未屏蔽） INTR 能被置 “1”</p><p>MASKi &#x3D; 1 （屏蔽） INTPi &#x3D; 0 （不能被排队选中）</p><h6 id="屏蔽字"><a href="#屏蔽字" class="headerlink" title="屏蔽字"></a>屏蔽字</h6><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018222445133.png" class="" title="image-20231018222445133"><p>在中断服务程序中设置适当的屏蔽字，能起到对优先级别不同的中断源的屏薇作用。例如，1级中断源的请求已被CPU响应，若在其中断服务程序中（通常在开中断指令前）设置一个全“1”的屏蔽字，便可保证在执行1级中断服务程序过程中，CPU不再响应任何一个中断源（包括本级在内)的中断请求，即此刻不能实现多重中断。如果在4级中断源的服务程序中设置一个屏蔽字0001111111111111，由于第1-3位为0，意味着第1~3级的中断源未被屏蔽，因此在开中断指令后，比第4级中断源级别更高的1、2、3级中断源可以中断4级中断源的中断服务程序，实现多重中断。</p><h5 id="屏蔽技术可改变处理优先等级"><a href="#屏蔽技术可改变处理优先等级" class="headerlink" title="屏蔽技术可改变处理优先等级"></a>屏蔽技术可改变处理优先等级</h5><p>严格地说，优先级包含响应优先级和处理优先级。响应优先级是指CPU响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指CPU实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。采用了屏蔽技术后，可以改变CPU处理各中断源的优先等级，从而改变CPU执行程序的轨迹。</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018222650169.png" class="" title="image-20231018222650169"><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018222748600.png" class="" title="image-20231018222748600"><h5 id="屏蔽技术的其他作用"><a href="#屏蔽技术的其他作用" class="headerlink" title="屏蔽技术的其他作用"></a>屏蔽技术的其他作用</h5><p>可以人为地屏蔽某个中断源的请求便于程序控制</p><h5 id="多重中断的断点保护"><a href="#多重中断的断点保护" class="headerlink" title="多重中断的断点保护"></a>多重中断的断点保护</h5><p>多重中断时，每次中断出现的断点都必须保存起米，如图8.3】中共出现了3次中断，有3个断点k+1、l+1、m+1需保存。中断系统对断点的保存都是在中断周期内由中断隐指令实现的，对用户是透明的。</p><p>断点可以保存在堆栈中，由于堆栈先进后出的特点，因此图8.31中的k+1先进栈，接着是L+1进栈，最后是m+1进栈。出栈时，按相反顺序便可准确返回到程序间断处。断点也可保存在特定的存储单元内，例如约定一律将程序断点存至主存的0号地址单元内。由于保存断点是由中断隐指令自动完成的，因此3次中断的断点都将存入0地址单元，这势必造成前两次存入的断点k+1和1+1被冲掉。为此，在中断服务程序中的开中断指令之前，必须先将0地址单元的内容转存至其他地址单元中，才能真正保存每一个断点。</p><img src="/2023/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%83/image-20231018223016682.png" class="" title="image-20231018223016682">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令系统(六)</title>
    <link href="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/"/>
    <url>/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍机器指令系统的分类、常见的寻址方式、指令格式以及设计指令系统时应考虑的各种因素。此外对RISC技术也进行简要的介绍，希望读者进一步体会指令系统与机器的主要功能以及与硬件结构之间存在的密切关系。</p><span id="more"></span><h3 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h3><h4 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h4><p>指令是由操作码和地址码两部分组成的</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016203233989.png" class="" title="image-20231016203233989"><h5 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h5><p>操作码用来指明该指令所要完成的操作，如加法、减法、传送、移位、转移等。通常，其位数反映了机器的操作种类，也即机器允许的指令条数，如操作码占7位，则该机器最多包含2^7^&#x3D;128条指令。</p><p>操作码的长度可以是固定的，也可以是变化的。前者将操作码集中放在指令字的一个字段内，这种格式便于硬件设计，指令译码时间短，广泛用于字长较长的、大中型计算机和超级小型计算机以及RISC(Reduced Instruction Set Computer)中。例如，IBM370和VAX-11系列机，操作码长度均为8位。</p><p>对于操作码长度不固定的指令，其操作码分散在指令字的不同字段中。这种格式可有效地压缩操作码的平均长度，在字长较短的微型计算机中被广泛采用。例如PDP-11、Intel8086&#x2F;80386等，操作码的长度是可变的。</p><p>操作码长度不固定会增加指令译码和分析的难度，使控制器的设计复杂。通常采用扩展操作码技术，使操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016204034869.png" class="" title="image-20231016204034869"><p>在设计操作码不固定的指令系统时，应尽量考虑安排指令使用频度（即指令在程序中出现的概率)高的指令占用短的操作码，对使用频度低的指令可占用较长的操作码，这样可以缩短经常使用的指令的译码时间。当然，考虑操作码长度时也应考虑地址码的要求。</p><h5 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h5><p>地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。这里的“地址”可以是主存的地址，也可以是寄存器的地址，甚至可以是I&#x2F;O设备的地址。</p><h6 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h6><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016210324898.png" class="" title="image-20231016210324898"><p>其中，OP为操作码；A1为第一操作数地址；A2为第二操作数地址；A3为结果地址；A4为下一条指令的地址。</p><p>如果地址字段均指示主存的地址，则完成一条四地址指令，共需访问4次存储器（取指令一次，取两个操作数两次，存放结果一次）。</p><h6 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h6><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016210430955.png" class="" title="image-20231016210430955"><p>它可完成(A1)OP(A2)→A3的操作，后续指令的地址隐含在程序计数器PC之中。如果指令字长不变，设OP仍为8位，则3个地址字段各占8位，故三地址指令操作数的直接寻址范围可达2^8^&#x3D;256。同理，若地址字段均为主存地址，则完成一条三地址指令也需访问4次存储器。</p><h6 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h6><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016210545703.png" class="" title="image-20231016210545703"><p>它可完成(A1)OP(A2)→A1的操作，即A1字段既代表源操作数的地址，又代表存放本次运算结果的地址。有的机器也可以表示(A1)OP(A2)→A2的操作，此时A2除了代表源操作数的地址外，还代表中间结果的存放地址。这两种情况完成一条指令仍需访问4次存储器。如果使其完成(A1)OP(A2)+ACC,此时，它完成一条指令只需3次访存，它的含义是中间结果暂存于累加器ACC中。在不改变指令字长和操作码的位数前提下，二地址指令操作数的直接寻址范围为2^12^&#x3D;4K。</p><h6 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h6><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016210745723.png" class="" title="image-20231016210745723"><p>它可完成(ACC)OP(A1)→ACC的操作，ACC既存放参与运算的操作数，又存放运算的中间结果，这样，完成一条一地址指令只需两次访存。在指令字长仍为32位、操作码位数仍固定为8位时，一地址指令操作数的直接寻址范围达2^24^即16M。</p><h6 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h6><p>零地址指令在指令字中无地址码，例如，空操作(NOP)、停机(HLT)这类指令只有操作码。而子程序返回(RET)、中断返回(IRET)这类指令没有地址码，其操作数的地址隐含在堆栈指针SP中。</p><h4 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h4><p>指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数。不同机器的指令字长是不相同的。</p><ul><li><p>指令字长 固定</p><p>指令字长 &#x3D; 存储字长</p></li><li><p>指令字长 可变</p><p>按字节的倍数变化</p></li></ul><h3 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h3><h4 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h4><p>机器中常见的操作数类型有地址、数字、字符、逻辑数据等。</p><ul><li>地址</li></ul><p>地址实际上也可看做是一种数据，在许多情况下要计算操作数的地址。这时，地址可被认为是一个无符号的整数，</p><ul><li>数字</li></ul><p>计算机中常见的数字有定点数、浮点数和十进制数。</p><ul><li>字符</li></ul><p>在应用计算机时，文本或者字符串也是一种常见的数据类型。由于计算机在处理信息过程中不能以简单的字符形式存储和传送，因此普遍采用ASCIⅡ码（见表5.2），它是很重要的一种字符编码。当然还有其他一些字符编码，如8位EBCDIC码(Extended Binary Coded Decimal Inter-change Code),又称扩展BCD交换码，在此不作详述。</p><ul><li>逻辑</li></ul><p>计算机除了作算术运算外，有时还需作逻辑运算，此时个0和1的组合不是被看做算术数字，而是被看做逻辑数。例如，在ASCIⅡ码中的0110101，它表示十进制数5，若要将它转换为NB-CD短十进制码，只需通过它与逻辑数0001111完成逻辑与运算，抽取低4位，即可获得0101。此外，有时希望存储一个布尔类型的数据，它们的每一位都代表着真(1)和假(0)，这时个0和1组合的数就都被看做逻辑数。</p><h4 id="数据在存储器中的存放方式"><a href="#数据在存储器中的存放方式" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h4><p>边界对准</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016212459935.png" class="" title="image-20231016212459935"><p>边界未对准</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016212551307.png" class="" title="image-20231016212551307"><h4 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h4><p>不同的机器，操作类型也是不同的，但几乎所有的机器都有以下几类通用的操作。</p><h5 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h5><p>数据传送包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送。如从源到目的之间的传送、对存储器读(LOAD)和写(STORE)、交换源和目的的内容、置1、清零、进栈、出栈等。</p><h5 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h5><p>这类操作可实现算术运算（加、减、乘、除、增1、减1、取负数即求补）和逻辑运算（与、或、非、异或)。对于低档机而言，一般算术运算只支持最基本的二进制加减、比较、求补等，高档机还能支持浮点运算和十进制运算。</p><p>有些机器还具有位操作功能，如位测试（测试指定位的值）、位清除（清除指定位）、位求反(对指定位求反)等。</p><h5 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h5><p>移位可分为算术移位、逻辑移位和循环移位三种。算术移位和逻辑移位分别可实现对有符号数和无符号数乘以2^n^（左移）或整除以2^n^（右移）的运算，并且移位操作所需时间远比乘除操作执行时间短，因此，移位操作经常被用来代替简单的乘法和除法运算。</p><h5 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h5><p>在多数情况下，计算机是按顺序执行程序的每条指令的，但有时需要改变这种顺序，此刻可采用转移类指令来完成。转移指令按其转移特征又可分为无条件转移、条件转移、跳转、过程调用与返回、陷阱(Trap)等几种。</p><h6 id="无条件转移"><a href="#无条件转移" class="headerlink" title="无条件转移"></a>无条件转移</h6><p>无条件转移不受任何条件约束，可直接把程序转移到下一条需执行指令的地址。例如“JMPX”,其功能是将指令地址无条件转至X。</p><h6 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h6><p>条件转移是根据当前指令的执行结果来决定是否需要转移。若条件满足，则转移；若条件不满足，则继续按顺序执行。一般机器都能提供一些条件码，这些条件码是某些操作的结果。</p><h6 id="调用与返回"><a href="#调用与返回" class="headerlink" title="调用与返回"></a>调用与返回</h6><p>在编写程序时，有些具有特定功能的程序段会被反复使用。为避免重复编写，可将这些程序段设定为独立子程序，当需要执行某子程序时，只需用子程序调用指令即可。此外，计算机系统还提供了通用子程序，如申请资源、读写文件、控制外设等。需要时均可由用户直接调用，不必重新编写。</p><p>通常调用指令包括过程调用、系统调用和子程序调用。它可实现从一个程序转移到另一个程序的操作。</p><p>调用指令(CALL)一般与返回指令（RETURN)配合使用。CALL用于从当前的程序位置转至子程序的人口；RETURN用于子程序执行完后重新返回到原程序的断点。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016213227733.png" class="" title="image-20231016213227733"><h6 id="陷阱-Trap-与陷阱指令"><a href="#陷阱-Trap-与陷阱指令" class="headerlink" title="陷阱(Trap)与陷阱指令"></a>陷阱(Trap)与陷阱指令</h6><p>陷阱其实是一种意外事故的中断。例如，机器在运行中，可能会出现电源电压不稳定、存储器校验出差错、输人输出设备出现了故障、用户使用未被定义的指令、除数出现为0、运算结果溢出以及特权指令等种种意外事件，致使计算机不能正常工作。此刻必须及时采取措施，否则将影响整个系统的正常运行。因此，一旦出现意外故障，计算机就发出陷阱信号，暂停当前程序的执行，转人故障处理程序进行相应的故障处理。</p><h6 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h6><p>对于I&#x2F;O单独编址的计算机而言，通常设有输入输出指令，它完成从外设中的寄存器读人一个数据到CPU的寄存器内，或将数据从CPU的寄存器输出至某外设的寄存器中。</p><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p>其他包括等待指令、停机指令、空操作指令、开中断指令、关中断指令、麗条件码指令等。为了适应计算机的信息管理、数据处理及办公自动化等领域的应用，有的计算机还设有非数值处理指令。如字符串传送、字符串比较、字符串查询及字符串转换等。</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><h4 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h4><p>指令寻址比较简单，它分为顺序寻址和跳跃寻址两种。</p><p>顺序寻址可通过程序计数器PC加1，自动形成下一条指令的地址；跳跃寻址测通过转移类指令实现。图7.6示意了指令寻址过程。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016213601624.png" class="" title="image-20231016213601624"><p>如果程序的首地址为0，只要先将0送至程序计数器PC中，启动机器运行后，程序便按0,1，2,3,7,8,9,…顺序执行。其中第1、2、3号指令地址均由PC自动形成。因第3号地址指令为“JMP7”,故执行完第3号指令后，便无条件将7送至PC，因此，此刻指令地址跳过4、5、6三条，直接执行第7条指令，接着又顺序执行第8条、第9条等指令。</p><h4 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h4><p>数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的真实地址称为有效地址，记作EA,它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016213758232.png" class="" title="image-20231016213758232"><ul><li>形式地址 指令字中的地址 </li><li>有效地址 操作数的真实地址 </li><li>约定 指令字长 &#x3D; 存储字长 &#x3D; 机器字长</li></ul><h5 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h5><p>立即寻址的特点是操作数本身设在指令字内，即形式地址A不是操作数的地址，而是操作数本身，又称之为立即数。数据是采用补码形式存放的，如图7.8所示，图中“#”表示立即寻址特征标记。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016213942730.png" class="" title="image-20231016213942730"><p>可见，它的优点在于只要取出指令，便可立即获得操作数，这种指令在执行阶段不必再访问存储器。显然A的位数限制了这类指令所能表述的立即数的范围。</p><h5 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h5><p>直接寻址的特点是，指令字中的形式地址A就是操作数的真实地址EA,即EA&#x3D;A</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016214106842.png" class="" title="image-20231016214106842"><p>它的优点是寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段对主存只访问一次。它的缺点在于A的位数限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数的地址。</p><h5 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h5><p>隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。例如，一地址格式的加法指令只给出一个操作数的地址，另一个操作数隐含在累加器ACC中，这样累加器ACC成了另一个数的地址。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016214253241.png" class="" title="image-20231016214253241"><h5 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h5><p>倘若指令字中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址，也就是说，有效地址是由形式地址间接提供的，即为间接寻址，即EA&#x3D;（A)</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016214514592.png" class="" title="image-20231016214514592"><p>图(a)为一次间接寻址，即A地址单元的内容EA是操作数的有效地址；图(b)为两次间接寻址，即A地址单元的内容A,还不是有效地址，而由A,所指单元的内容EA才是有效地址。</p><p>这种寻址方式与直接寻址相比，它扩大了操作数的寻址范围，因为A的位数通常小于指令字长，而存储字长可与指令字长相等。若设指令字长和存储字长均为16位，A为8位，显然直接寻址范围为2^8^，一次间接寻址的寻址范围可达2^16^。当多次间接寻址时，可用存储字的首位来标志间接寻址是否结束。如图(b)中，当存储字首位为“1”时，标明还需继续访存寻址；当存储字首位为“0”时，标明该存储字即为EA。由此可见，存储字首位不能作为EA的组成部分，因此，它的寻址范围为2^15^。</p><p>间接寻址的第二个优点在于它便于编制程序。例如，用间接寻址可以很方便地完成子程序返回，图示意了用于子程序返回的间址过程。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016214758134.png" class="" title="image-20231016214758134"><h5 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h5><p>在寄存器寻址的指令字中，地址码字段直接指出了寄存器的编号，即EA&#x3D;Ri。其操作数在由Ri所指的寄存器内。由于操作数不在主存中，故寄存器寻址在指令执行阶段无须访存，减少了执行时间。由于地址字段只需指明寄存器编号（计算机中寄存器数有限），故指令字较短，节省了存储空间，因此寄存器寻址在计算机中得到广泛应用。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016214927204.png" class="" title="image-20231016214927204"><h5 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h5><p>图中Ri中的内容不是操作数，而是操作数所在主存单元的地址号，即有效地址EA&#x3D;(Ri)。与寄存器寻址相比，指令的执行阶段还需访问主存。与图(a)相比，因有效地址不是存放在存储单元中，而是存放在寄存器中，故称其为寄存器间接寻址，它比间接寻址少访存一次。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016215043562.png" class="" title="image-20231016215043562"><h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>基址寻址需设有基址寄存器BR,其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容（称为基地址）相加，即EA&#x3D;A+(BR)</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016215138304.png" class="" title="image-20231016215138304"><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016215501289.png" class="" title="image-20231016215501289"><p>基址寄存器可采用隐式的和显式的两种。所谓隐武，是在计算机内专门丁设有一个基址奇存器BR,使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基址寻址即可。显式是在一组通用寄存器里，由用户明确指出哪个寄存器用做基址寄存器，存放基地址。例如，IBM370计算机中设有16个通用寄存器，用户可任意选中某个寄存器作为基址寄存器。图一为隐式基址寻址，图二为显式基址寻址。</p><h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>变址寻址与基址寻址极为相似。其有效地址EA等于指令字中的形式地址A与变址寄存器X的内容相加之和，即EA&#x3D;A+（IX)</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016215617703.png" class="" title="image-20231016215617703"><h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><p>相对寻址的有效地址是将程序计数器PC的内容（即当前指令的地址）与指令字中的形式地址A相加而成，即EA&#x3D;(PC)+A</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016220041650.png" class="" title="image-20231016220041650"><p>相对寻址常被用于转移类指令，转移后的目标地址与当前指令有一段距离，称为相对位移量，它由指令字的形式地址A给出，故A又称位移量。位移量A可正可负，通常用补码表示。徜若位移量为8位，则指令的寻址范围在(PC)+127~(PC)-128之间。</p><h5 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h5><p>堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组（称为硬堆栈）来实现，也可利用主存的一部分空间作堆栈（称为软堆栈）。堆栈的运行方式为先进后出或先进先出两种，先进后出型堆栈的操作数只能从一个口进行读或写。以软堆栈为例，可用堆栈指针SP(Stack Point)指出栈顶地址，也可用CPU中一个或两个寄存器作为SP。操作数只能从栈顶地址指示的存储单元存或取。可见堆栈寻址也可视为一种隐含寻址，其操作数的地址总被隐含在SP中。堆栈寻址就其本质也可视为寄存器间接寻址，因SP可视为寄存器，它存放着操作数的有效地址。示意了堆栈寻址过程。</p><h3 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h3><p>指令格式不仅体现了指令系统的各种功能，而且也突出地反映了机器的硬件结构特点。设计指令格式时必须从诸多方面综合考虑，并经一段模拟运行后，最后确定。</p><h4 id="设计指令格式应考虑的各种因素"><a href="#设计指令格式应考虑的各种因素" class="headerlink" title="设计指令格式应考虑的各种因素"></a>设计指令格式应考虑的各种因素</h4><p>指令系统集中反映了机器的性能，又是程序员编程的依据。用户在编程时既希望指令系统很丰富，便于用户选择，同时还要求机器执行程序时速度快、占用主存空间少，实现高效运行。此外，为了继承已有的软件，必须考虑新机器的指令系统与同一系列机器指令系统的兼容性，即高档机必须能兼容低档机的程序运行，称之为“向上兼容”。指令格式集中体现了指令系统的功能，为此，在确定指令格式时，必须从以下几个方面综合考虑。</p><ul><li>操作类型：包括指令数及操作的难易程度。</li><li>数据类型：确定哪些数据类型可以参与操作。</li><li>指令格式：包括指令字长、操作码位数、地址码位数、地址个数、寻址方式类型，以及指令字长和操作码位数是否可变等。</li><li>寻址方式：包括指令和操作数具体有哪些寻址方式。</li><li>寄存器个数：寄存器的多少直接影响指令的执行时间。</li></ul><h4 id="指令格式举例-1"><a href="#指令格式举例-1" class="headerlink" title="指令格式举例"></a>指令格式举例</h4><h5 id="PDP-8"><a href="#PDP-8" class="headerlink" title="PDP-8"></a>PDP-8</h5><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016221038405.png" class="" title="image-20231016221038405"><p>PDP-8的指令字长统一为12位，CPU内只设一个通用寄存器，即累加器ACC,其主存被划分为若干个容量相等的存储空间（每个相同的空间被称为一页）。该机的指令格式可分为三大类。</p><p>访存类指令属一地址指令。0-2位为操作码（只定义了000-101六种基本操作）；3、4两位为寻址特征位，其中3位表示是否间接寻址，4位表示是当前页面（即PC指示的页面）还是0页面；5-11位为地址码。</p><p>为了扩大操作种类，对应操作码“111”又配置了辅助操作码，构成了寄存器类指令，这类指令主要对访存ACC进行各种操作，如清A、对A取反、对A移位、对A加1、根据A的结果是否跳转等。辅助操作码的每IO一位都有一个明确的操作。</p><p>第三类指令是I&#x2F;O类，用0-2位为110作标志，寄存器其具体操作内容由9-11位反映，3-8位表示设备号，总共可选64种设备。</p><p>PDP-8指令格式支持间接寻址、变址寻址、相对寻址。加上操作码扩展技术，共有35条指令。</p><h5 id="PDP-11"><a href="#PDP-11" class="headerlink" title="PDP -11"></a>PDP -11</h5><p>PDP-11机器字长为16位，CPU内设8个16位通用寄存器，其中两个通用寄存器有特殊作用，一个用做堆栈指针SP,一个用做程序计数器PC。</p><p>PDP-11指令字长有16位、32位和48位三种，采用操作码扩展技术，使操作码位数不固定，指令字的地址格式有零地址、一地址、二地址等共有13类指令格式，列出了其中五种。</p><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016221215371.png" class="" title="image-20231016221215371"><h5 id="IBM-360"><a href="#IBM-360" class="headerlink" title="IBM -360"></a>IBM -360</h5><img src="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/image-20231016221428083.png" class="" title="image-20231016221428083"><h3 id="RISC-技-术"><a href="#RISC-技-术" class="headerlink" title="RISC 技 术"></a>RISC 技 术</h3><h4 id="RISC-的主要特征"><a href="#RISC-的主要特征" class="headerlink" title="RISC 的主要特征"></a>RISC 的主要特征</h4><ul><li>选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合</li><li>指令长度固定、指令格式种类少、寻址方式少</li><li>只有LOAD&#x2F;STORE指令访存</li><li>CPU中有多个通用寄存器</li><li>采用流水技术一个时钟周期内完成一条指令</li><li>采用组合逻辑实现控制器</li><li>采用优化的编译程序</li></ul><h4 id="CISC-的主要特征"><a href="#CISC-的主要特征" class="headerlink" title="CISC 的主要特征"></a>CISC 的主要特征</h4><ul><li>系统指令复杂庞大，各种指令使用频度相差大</li><li>指令长度不固定、指令格式种类多、寻址方式多</li><li>访存指令不受限制</li><li>CPU中设有专用寄存器</li><li>大多数指令需要多个时钟周期执行完毕</li><li>采用微程序控制器</li><li>难以用优化编译生成高效的目的代码</li></ul><h4 id="RISC和CISC-的比较"><a href="#RISC和CISC-的比较" class="headerlink" title="RISC和CISC 的比较"></a>RISC和CISC 的比较</h4><ul><li>RISC更能充分利用VLSI芯片的面积</li><li>RISC更能提高计算机运算速度指令数、指令格式、寻址方式少通用寄存器多，采用组合逻辑便于实现指令流水</li><li>RISC便于设计，可降低成本，提高可靠性</li><li>RISC有利于编译程序代码优化</li><li>RISC不易实现指令系统兼容</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层(六)</title>
    <link href="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/"/>
    <url>/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>在上一章，我们已学习了运输层为应用进程提供了端到端的通信服务。但不同的网络应用的应用进程之间，还需要有不同的通信规则。因此在运输层协议之上，还需要有应用层协议(application layer protocol)。这是因为，每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应用进程之间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。具体来说，应用层协议应当定义：</p><ul><li>应用进程交换的报文类型，如请求报文和响应报文。</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时、如何发送报文，以及对报文进行响应的规则。</li></ul><span id="more"></span><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/image-20231009194509746.png" class="" title="image-20231009194509746"><h4 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h4><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><ul><li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li></ul><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/image-20231009194618529.png" class="" title="image-20231009194618529"><ul><li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/image-20231009194629848.png" class="" title="image-20231009194629848"><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h4 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h4><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/image-20231009194657448.png" class="" title="image-20231009194657448"><h4 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h4><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/image-20231009194740228.png" class="" title="image-20231009194740228"><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/image-20231009194806390.png" class="" title="image-20231009194806390"><h5 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h5><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p><h5 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h5><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运输层(五)</title>
    <link href="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/"/>
    <url>/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>本章先概括介绍运输层协议的特点、进程之间的通信和端口等重要概念，然后讲述比较简单的UDP协议。其余的篇幅都是讨论较为复杂但非常重要的TCP协议①和可靠传输的工作原理，包括停止等待协议和ARQ协议。在详细讲述TCP报文段的首部格式之后，讨论TCP的三个重要问题：滑动窗口、流量控制和拥塞控制机制。最后，介绍TCP的连接管理。</p><p>运输层是整个网络体系结构中的关键层次之一。一定要弄清以下一些重要概念：</p><ul><li>运输层为相互通信的应用进程提供逻辑通信。</li><li>端口和套接字的意义。</li><li>无连接的UDP的特点。</li><li>面向连接的TCP的特点。</li><li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议。</li><li>TCP的滑动窗口、流量控制、拥塞控制和连接管理。</li></ul><span id="more"></span><h3 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h3><h4 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h4><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络边缘部分的两台主机使用网络核心部分的功能进行端到端的通信时，都要使用协议栈中的运输层，而网络核心部分中的路由器在转发分组时只用到下三层的功能。</p><p>从IP层来说，通信的两端是两台主机。IP数据报的首部明确地标志了这两台主机的IP地址。但“两台主机之间的通信”这种说法还不够明确。真正进行通信的实体是在主机中的哪个构件呢？是主机中的<strong>应用进程</strong>，是一台主机中的应用进程和另一台主机中的应用进程在交换数据（即通信）。因此严格地讲，两台主机进行通信就是<strong>两台主机中的应用进程互相通信</strong>。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。通信的两端应当是两个主机中的应用进程。也就是说，端到端的通信是应用进程之间的通信。在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。例如，某用户在使用浏览器查找某网站的信息时，其主机的应用层运行浏览器客户进程。如果在浏览网页的同时，还要用电子邮件给网站发送反馈意见，那么主机的应用层就还要运行电子邮件的客户进程。在图5-1中，主机A的应用进程AP1和主机B的应用进程AP3通信，而与此同时，应用进程AP2也和对方的应用进程AP4通信。这表明运输层有一个很重要的功能一<strong>复用</strong>(multiplexing)和分用(demultiplexing)。这里的“复用”是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部），而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。图5-1中两个运输层之间有一个深色双向粗箭头，写明“运输层提供应用进程间的逻辑通信”。“逻辑通信”的意思是：从应用层来看，只要把应用层报文交给下面的运输层，运输层就可以把这报文传送到对方的运输层（哪怕双方相距很远，例如几千公里），好像这种通信就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。数据的传送是沿着图中的虚线方向（经过多个层次）传送的。“逻辑通信”的意思是“好像是这样通信，但事实上并非真的这样通信”。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008221457898.png" class="" title="image-20231008221457898"><p>从这里可以看出网络层和运输层有明显的区别。网络层为<strong>主机之间的通信提供服务</strong>，<strong>而运输层则在网络层的基础上</strong>，<strong>为应用进程之间的通信提供服务</strong>。然而正如后面还要讨论的，运输层还具有网络层无法代替的许多其他重要功能。运输层还要对收到的报文进行差错检测。大家应当还记得，在网络层，IP数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。根据应用程序的不同需求，运输层需要有两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>,这两种协议就是本章要讨论的主要内容。</p><h4 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h4><p>TCP&#x2F;IP运输层的两个主要协议都是互联网的正式标准，即：</p><ul><li><strong>用户数据报协议UDP</strong>(User Datagram Protocol)[RFC768,STD6]</li><li><strong>传输控制协议TCP</strong>(Transmission Control Protocol)[RFC793,STD7]</li></ul><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008221818361.png" class="" title="image-20231008221818361"><p>按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫作运<strong>输协议数据单元TPDU</strong>(Transport Protocol Data Unit)。但在TCP&#x2F;IP体系中，则根据所使用的协议是TCP或UDP,分别称之为<strong>TCP报文段</strong>(segment)或<strong>UDP用户数据报</strong>。</p><p>UDP在传送数据之前<strong>不需要先建立连接</strong>。远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但由于UDP非常简单，在某些情况下UDP是一种最有效的工作方式。</p><p>TCP则<strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008222102532.png" class="" title="image-20231008222102532"><h4 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h4><p>运输层的端口号分为下面的两大类。</p><p>(1)服务器端使用的端口号</p><p>这里又分为两类，最重要的一类叫作熟知端口号(well-known port number)或全球通用端口号，数值为0~l023。这些熟知端口号最初公布在文档中</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008222333065.png" class="" title="image-20231008222333065"><p>另一类叫作登记端口号，数值为1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。要使用这类端口号必须在IANA按照规定的手续登记，以防止重复。</p><p>(2)客户端使用的端口号</p><p>数值为49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫作短暂端口号。这类端口号就是临时端口号，留给客户进程选择临时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就被系统收回，以便给其他客户进程使用。</p><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><h4 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h4><p>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。UDP的主要特点是：</p><p>(I)UDP是无连接的，即发送数据之前不需要建立连接（当然发送数据结束时也没有连接可释放)，因此减少了开销和发送数据之前的时延。</p><p>(2)UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。</p><p>(3)UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，在接收方的UDP,对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。</p><p>(4)UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求。</p><p>(5)UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>(6)UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008222653700.png" class="" title="image-20231008222653700"><h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><p>用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节如图5-5所示)，由4个字段组成，每个字段的长度都是2字节。各字段意义如下：</p><ul><li>源端口源端口号。在需要对方回信时选用。不需要时可用全0。</li><li>目的端口目的端口号。这在终点交付报文时必须使用。</li><li>长度UDP用户数据报的长度，其最小值是8（仅有首部）。</li><li>检验和检测UDP用户数据报在传输中是否有错。有错就丢弃。</li></ul><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008223012978.png" class="" title="image-20231008223012978"><p>UDP用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。图5-5的最上面给出了伪首部各字段的内容。</p><p>UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：P数据报的检验和只检验IP数据报的首部，但UDP的检验和是<strong>把首部和数据部分一起都检验</strong>。在发送方，首先是先把全零放入检验和字段。再把伪首部以及UDP用户数据报看成是由许多16位的字串接起来的。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码</p><h3 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h3><h4 id="TCP最主要的特点"><a href="#TCP最主要的特点" class="headerlink" title="TCP最主要的特点"></a>TCP最主要的特点</h4><ol><li>TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。也就是说，应用进程之间的通信好像在“打电话”：通话前要先拨号建立连接，通话结束后要挂机释放连接。</li><li>每一条TCP连接只能有两个端点(endpoint),每一条TCP连接只能是点对点的(对一)。这个问题后面还要进一步讨论。</li><li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li><li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</li><li>面向字节流。TCP中的“<strong>流</strong>”(stream)指的是<strong>流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序)。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</li></ol><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008223801313.png" class="" title="image-20231008223801313"><h4 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h4><p>TCP把连接作为最基本的抽象。TCP的许多特性都与TCP是面向连接的这个基本特性有关。因此我们对TCP连接需要有更清楚的了解。前面已经讲过，每一条TCP连接有两个端点。那么，TCP连接的端点是什么呢？不是主机，不是主机的P地址，不是应用进程，也不是运输层的协议端口。TCP连接的端点叫作套接字(socket)或插口。根据RFC793的定义：端口号拼接到(concatenated with)IP地址即构成了套接字。因此，套接字的表示方法是在点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。例如，若IP地址是192.3.4.5而端口号是80，那么得到的套接字就是(192.3.4.5:80)</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008223927259.png" class="" title="image-20231008223927259"><p>每一条TCP连接唯一地被通信两端的两个端点（即套接字对socket pair).所确定。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008223948546.png" class="" title="image-20231008223948546"><p>这里IP1和IP2分别是两个端点主机的IP地址，而pot和pot2分别是两个端点主机中的端口号。因此，TCP连接就是两个套接字socket1和socket2之间的连接。套接字socket是个很抽象的概念，总之，TCP连接就是由协议软件所提供的一种抽象。虽然有时为了方便，我们也可以说，在一个应用进程和另一个应用进程之间建立了一条TCP连接，但一定要记住：TCP连接的端点是个很抽象的套接字，即(IP地址：端口号)。也还应记住：同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。</p><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>全双工通信的双方既是发送方也是接收方。下面为了讨论问题的方便，我们仅考虑A发送数据而B接收数据并发送确认。因此A叫作发送方，而B叫作接收方。因为这里是讨论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪一个层次上传送的。“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><h5 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h5><p>停止等待协议可用(a)来说明。a)是最简单的无差错情况。A发送分组M1,发完就暂停发送，等待B的确认。B收到了M,就向A发送确认。A在收到了对M的确认后，就再发送下一个分组M2。同样，在收到B对M2的确认后，再发送M3。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008224258785.png" class="" title="image-20231008224258785"><h5 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h5><p>(b))是分组在传输过程中出现差错的情况。B接收M时检测出了差错，就丢弃M1,其他什么也不做（不通知A收到有差错的分组）。也可能是M1在传输过程中丢失了，这时B当然什么都不知道。在这两种情况下，B都不会发送任何信息。可靠传输协议是这样设计的：A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫作超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。其实在(b)中，A为每一个已发送的分组都设置了一个超时计时器。但A只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器。为简单起见，这些细节在(a)中都省略了。</p><p>这里应注意以下三点。</p><ul><li>第一，A在发送完一个分组后，必须暂时保留已发送的分组的副本（在发生超时重传时使用)。只有在收到相应的确认后才能清除暂时保留的分组副本。</li><li>第二，分组和确认分组都必须进行编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li>第三，超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。图5(b)中的一段虚线表示如果M,正确到达B同时A也正确收到确认的过程。可见重传时间应设定为比平均往返时间更长一些。显然，如果重传时间设定得很长，那么通信的效率就会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。然而，在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会经过哪些网络，以及这些网络将会产生多大的时延（这取决于这些网络当时的拥塞情况），这些都是不确定因素。中把往返时间当作固定的（这显然不符合网络的实际情况），只是为了讲述原理的方便。关于重传时间应如何选择，在后面的还要进一步讨论。</li></ul><h5 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h5><p>图(a)说明的是另一种情况。B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传M1。现在应注意B的动作。假定B又收到了重传的分组M1。这时应采取两个行动。</p><ul><li>第一，丢弃这个重复的分组M1,不向上层重复交付。</li><li>第二，向A发送确认。不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到对M1的确认。</li></ul><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008224736789.png" class="" title="image-20231008224736789"><p>图(b)也是一种可能出现的情况。传输过程中没有出现差错，但B对分组M1的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃，但什么也不做。B仍然会收到重复的M1,并且同样要丢弃重复的M1,并重传确认分组。通常A最终总是可以收到对所有发出的分组的确认。如果A不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。像上述的这种可靠传输协议常称为<strong>自动重传请求ARQ</strong>(Automatic Repeat reQuest)。意思是重传的请求是自动进行的，因此也可见到<strong>自动请求重传</strong>这样的译名。接收方不需要请求发送方重传某个出错的分组。</p><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>滑动窗口协议比较复杂，是TCP协议的精髓所在。这里先给出连续ARQ协议最基本的概念，但不涉及许多细节问题。详细的滑动窗口协议将在后面的中讨论。</p><p>(a)表示发送方维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。在讨论滑动窗口时，我们应当注意到，图中还有一个时间坐标（但以后往往省略这样的时间坐标)。按照习惯，“向前”是指“向着时间增大的方向”，而“向后”则是“向着时间减少的方向”。分组发送是按照分组序号从小到大发送的。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008225221149.png" class="" title="image-20231008225221149"><p>连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。（b)表示发送方收到了对第1个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，那么现在就可以发送窗口内的第6个分组了。接收方一般都是采用累积确认的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都己正确收到了。累积确认有优点也有缺点。优点是容易实现，即使确认丢失也不必重传：但缺点是不能向发送方及时反映接收方已经正确收到所有分组的信息。</p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的作用。因此，只有弄清TCP首部各字段的作用才能掌握TCP的工作原理。下面讨论TCP报文段的首部格式。</p><p>TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项(n是整数)。因此TCP首部的最小长度是20字节。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231008225511346.png" class="" title="image-20231008225511346"><p>首部固定部分各字段的意义如下：</p><p>(1)源端口和目的端口各占2个字节，分别写入源端口号和目的端口号。和的UDP的分用相似，TCP的分用功能也是通过端口实现的。</p><p>(2)序号占4字节。序号范围是[0,2^32^-1]，共22（即4294967296）个序号。序号增加到2^32^-1后，下一个序号就又回到0。也就是说，序号使用mod2^32^运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是301，而携带的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的名称也叫作“报文段序号”。</p><p>(3**)确认号占4字节，是期望收到对方下一个报文段的第一个数据字节的序号**。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节(序号501~700)，这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。请注意，现在的确认号不是501，也不是700，而是701。</p><p>若确认号&#x3D;N,则表明：到序号N-1为止的所有数据都已正确收到。</p><p>(4)数据偏移占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。但应注意，“数据偏移”的单位是32位字（即以4字节长的字为计算单位)。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度（即选项长度不能超过40字节）。</p><p>(5)保留占6位，保留为今后使用，但目前应置为0。下面有6个控制位，用来说明本报文段的性质，它们的意义见下面的(6)-(11)。</p><p>(6)紧急URG(URGent)当URG&#x3D;1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序传送。例如，己经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令(Control–C)。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了许多时间。当URG置1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(Urgent Pointer)字段配合使用。</p><p>(7)确认ACK(ACKnowledgment)仅当ACK&#x3D;1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置为1。<br>(8)推送PSH(PuSH)当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置I,并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p><p>(9)复位RST(ReSeT)当RST&#x3D;1时，表明TCP连接中出现严重差错（如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。将RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</p><p>(10)同步SYN(SYNchronization)在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。关于连接的建立和释放，在后面的5.9节还要进行详细讨论。<br>(11)终止FN(FINish,意思是“完了”“终止”)用来释放一个连接。当FN&#x3D;1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p><p>(12)窗口占2字节。窗口值是[0,26-1]之间的整数。窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据</p><p>(13)检验和占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与图5-5中UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6(TCP的协议号是6)，把第5字段中的UDP长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPν6，则相应的伪首部也要改变。</p><p>(14)紧急指针占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</p><p>(15)选项长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。最后的填充字段仅仅是为了使整个TCP首部长度是4字节的整数倍。</p><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><p>我们首先介绍以字节为单位的滑动窗口。为了讲述可靠传输原理的方便，我们假定数据传输只在一个方向进行，即A发送数据，B给出确认。这样的好处是使讨论限于两个窗口，即发送方A的发送窗口和接收方B的接收窗口。如果再考虑B也向A发送数据，那么还要增加A的接收窗口和B的发送窗口，这样总共有4个都不断在变化大小的窗口。这对讲述可靠传输的原理并没有多少帮助，反而会使问题变得更加烦琐。</p><h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><p>TCP的滑动窗口是以字节为单位的。为了便于说明滑动窗口的工作原理，我们故意把后面图5-14至图5-17中的字节编号都取得很小（实际的窗口大小多为数千字节)。现假定A收到了B发来的确认报文段，其中窗口是20字节，而确认号是31（这表明B期望收到的下一个字节序号是31（请注意，这里不是分组的序号)，而到序号30为止的数据已经收到了)。根据这两个数据，A就构造出自己的发送窗口，如图5-14所示。</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231009192859968.png" class="" title="image-20231009192859968"><h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><p>上面已经讲到，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。这种重传的概念是很简单的，但重传时间的选择却是TCP最复杂的问题之一。</p><p>TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs(这又称为平滑的往返时间，S表示Smoothed。因为进行的是加权平均，因此得出的结果更加平滑)。每当第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs:</p><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231009193026619.png" class="" title="image-20231009193026619"><p>根据以上所述，Kam提出了一个算法：在计算加权平均RTTs时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均RTTs和RTO就较准确。</p><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制(owcontrol)就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>TCP进行拥塞控制的算法有四种，即慢开始(slow-start)、拥塞避免congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)</p><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231009193922682.png" class="" title="image-20231009193922682"><img src="/2023/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/image-20231009193938466.png" class="" title="image-20231009193938466">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层(四)</title>
    <link href="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/"/>
    <url>/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>本章讨论网络互连问题。在介绍网络层提供的两种服务和两个层面后，就进入本章的核心内容一网际协议IP,这是本书的一个重点内容。只有深入地掌握了协议P的主要内容，才能理解互联网是怎样工作的。本章还要讨论网际控制报文协议ICMP、几种常用的路由选择协议、IPV6的主要特点、IP多播的概念等。在讨论虚拟专用网VPN和网络地址转换NAT后，最后简单介绍多协议标签交换MPLS和软件定义网络SDN的基本概念。本章最重要的内容是：</p><ul><li>虚拟互连网络和两种服务、两个层面的概念。</li><li>IP地址与MAC地址的关系。</li><li>传统分类的IP地址和无分类域间路由选择CIDR(后者是重点)。</li><li>路由选择协议的工作原理。</li></ul><span id="more"></span><h3 id="网络层的几个重要概念"><a href="#网络层的几个重要概念" class="headerlink" title="网络层的几个重要概念"></a>网络层的几个重要概念</h3><h4 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h4><h5 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h5><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007125122293.png" class="" title="image-20231007125122293"><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><p>网际协议IP(Internet Protocol)是TCP&#x2F;IP体系中两个最主要的协议之一，也是最重要的互联网标准协议之一。</p><p>与协议IP配套使用的还有三个协议：</p><ul><li>地址解析协议ARP(Address Resolution Protocol)</li><li>网际控制报文协议ICMP(Internet Control Message Protocol)</li><li>网际组管理协议IGMP(Internet Group Management Protocol)</li></ul><h4 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h4><p>我们知道，如果要在全世界范围内把数以百万计的网络都互连起来，并且能够互相通信，那么这样的任务一定非常复杂。其中会遇到许多需要解决的问题，如：</p><ul><li>不同的寻址方案：</li><li>不同的最大分组长度：</li><li>不同的网络接入机制：</li><li>不同的超时控制：</li><li>不同的差错恢复方法：</li><li>不同的状态报告方法：</li><li>不同的路由选择技术：</li><li>不同的用户接入控制：</li><li>不同的服务（面向连接服务和无连接服务）：</li><li>不同的管理与控制方式：等等</li></ul><p>能不能让大家都使用相同的网络，这样可使网络互连变得比较简单。答案是不行的。因为用户的需求是多种多样的，没有一种单一的网络能够适应所有用户的需求。另外，网络技术是不断发展的，网络的制造厂家也要经常推出新的网络，在竞争中求生存。因此客观讲在市场上总是有很多种不同性能、不同网络协议的网络，供不同的用户选用。从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ul><li>物理层使用的中间设备叫作转发器(repeater)。</li><li>数据链路层使用的中间设备叫作网桥或桥接器(bridge),以及交换机(switch)。</li><li>网络层使用的中间设备叫作路由器(router)°。</li><li>在网络层以上使用的中间设备叫作网关(gateway)。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ul><p>下图(a)表示有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的网际协议<strong>IP</strong>(nternet Protocol),因此可以把互连以后的计算机网络看成为（b)所示的一个<strong>虚拟互连网络</strong>(internet)。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007130200607.png" class="" title="image-20231007130200607"><p>在下图所示的互联网中的源主机H1要把一个P数据报发送给目的主机H2。根据第1章中讲过的分组交换的存储转发概念，主机H1先要查找自己的转发表，看目的主机H2是否就在本网络上。如是，则不需要经过任何路由器而是<strong>直接交付</strong>，任务就完成了。如不是，则必须把IP数据报发送给某个路由器（图中的R2)。R2在查找了自己的转发表后，知道应当把数据转发给R2进行<strong>间接交付</strong>。这样一直转发下去，最后由路由器R5知道自己是和H2连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报<strong>直接交付</strong>目的主机H2。总之，分组从源节点A发送到目的节点B,若中间必须经过一个或几个路由器（这表示A和B不在同一个网络上)，则是间接交付。但若不需要经过路由器（这表示A和B在同一个网络上)，则是直接交付。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007130541592.png" class="" title="image-20231007130541592"><p>在图中画出了源主机、目的主机以及各路由器的协议栈。我们注意到，主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向（用黑色粗线表示)。我们还可注意到，在R4和R;之间使用了卫星链路，而R所连接的是个无线局域网(R5和主机H2都在同一个局域网中)。在R1到R4之间的三个网络则可以是任意类型的网络。总之，这里强调的是：<strong>互联网可以由多种异构网络互连组成</strong>。有时可以把问题简化。我们可以想象P数据报就在网络层中传送，传输路径可省略路由器之间的网络以及连接在这些网络上的许多无关主机。下图表示了这样的传输路径。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007131002861.png" class="" title="image-20231007131002861"><p>在互联网的词汇中，分组在传送途中的每一次转发都称为一“跳(hop)”。也有人把hop译为跃点。路由器在转发分组时也常常使用“下一跳(next hop)”的说法。例如，R1的下一跳是R2,而R4的下一跳是R5。对于本例，H1向H2发送分组需要经过6跳。我们还注意到，每一跳两端的两个节点都必定直接连接在同一个网络上。例如，在图4-7中从R2到R3的一跳，其两端的两个节点R2和R3都是连接在同一个网络上的。在上面所举的例子中，前5跳都是间接交付，只有最后一跳是直接交付。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><h5 id="IP地址及其表示方法"><a href="#IP地址及其表示方法" class="headerlink" title="IP地址及其表示方法"></a>IP地址及其表示方法</h5><p>整个的互联网就是一个单一的、抽象的网络。<strong>IP</strong>地址就是给连接到互联网上的母一台主机（或路由器）的每一个接口，分配一个在全世界范围内是唯一的32位的标识符。IP地址的结构使我们可以在互联网上很方便地进行寻址。IP地址现在由<strong>互联网名字和数字分配机构ICANN</strong>(Internet Corporation for Assigned Names and Numbers)进行分配。</p><p>对主机或路由器来说，IP地址都是32位的二进制代码。为了提高可读性，我们常常把32位的IP地址中的每隔8位插入一个空格（<strong>但在机器中并没有这样的空格</strong>）。为了便于人们书写和记忆，常用其等效的十进制数字表示，并且在每段数字之间加上一个小数点。这就叫作<strong>点分十进制记法</strong>(dotted decimal notation)。显然，把P地址用4段十进制数字来表示是个很好的方法。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007131406462.png" class="" title="image-20231007131406462"><p>前面所讲的给每个主机（或路由器）的<strong>接口</strong>分配一个IP地址，其含义就是这个IP地址不但标志了这个主机（或路由器），而且还标志了此接口所连接的网络。因此，32位的<strong>IP</strong>地址采用两级结构，由两个字段组成。第一个字段是<strong>网络号</strong>，它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机（对路由器来说，就是标志该路由器）。一个主机号在所连接的网络（即前面的网络号所指明的网络)中必须是唯一的。由此可见，一个P地址在整个互联网范围内是唯一的。因此，IP地址可以记为：</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007131633929.png" class="" title="image-20231007131633929"><p>符号“：&#x3D;”表示“定义为”。IP地址中包含网络号就表明，不连网的主机就没有IP地址。一定要记住，IP地址指明了连接到某个网络上的一个主机（或路由器）。为简单起见，当不涉及路由器时，后面我们都以主机为例来介绍IP地址。</p><p>IP地址中的网络号和主机号的位置。具体的规定是：IP地址中的前n位是主机所连接的网络号，而IP地址中后面的(32-n)位是主机号。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007131944416.png" class="" title="image-20231007131944416"><h5 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h5><p>在互联网发展早期采用的是分类的IP地址，也就是在上图中的n是固定的几个数之一。分类的方法下图所示。分类的方法非常简单。这里A类(n&#x3D;8)、B类(n&#x3D;16)和C类(n&#x3D;24)地址都是单播地址(一对一通信)，是最常用的。D类是多播地址（一对多通信，我们将在节讨论IP多播），而E类是保留地址。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007132108209.png" class="" title="image-20231007132108209"><p>A类地址的网络号字段占1个字节，只有7位可供使用（该字段的第一位已固定为0）。但要注意，第一，网络号为全0的P地址有特殊的用途，它表示“本网络”：第二，网络号为127（即01111111）保留作为本地软件环回测试(loopback test)本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如127.0.0.1）的IP数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。因此A类地址可指派的网络号是126个（即2^7^-2）。</p><p>A类地址的主机号占3个字节。但全0和全1的主机号一般不指派。全0的主机号表示该P地址是“本主机”所连接到的单个网络地址（例如，若主机的IP地址为5.6.7.8，则该主机所在的网络的网络号是5，而该网络的网络地址就是5.0.0.0)。全1表示“所有的”，因此全1的主机号字段表示该网络上的所有主机。因此每一个A类网络中的最大主机数是2^24^-2,即16777214。</p><p>B类地址的网络号字段有2个字节。因此B类地址可指派的网络数为2^24^，即16384。B类地址的每一个网络上的最大主机数是2^26^-2，即65534。这里需要减2是因为要扣除全0和全1的主机号。</p><p>C类地址有3个字节的网络号字段。因此C类地址可指派的网络总数是2^21^，即2097152。每一个C类地址的最大主机数是2^8^-2，即254。</p><p>一般不指派的特殊IP地址</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007133049863.png" class="" title="image-20231007133049863"><h5 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h5><p>这种编址方法的全名是无分类域间路由选择CDR(Classless Inter-DomainRouting,CIDR的读音是“sider’”),其要点有以下三个。</p><h6 id="1-网络前缀"><a href="#1-网络前缀" class="headerlink" title="(1)网络前缀"></a>(1)网络前缀</h6><p>CIDR把网络号改称为“网络前缀”(network-prefix)(或简称为“前缀”)，用来指明网络，剩下的后面部分仍然是主机号，用来指明主机。在有些文献中也把主机号字段称为后缀(suffix)。CIDR的记法是：</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007133728724.png" class="" title="image-20231007133728724"><p>看起来，这和原先也没有什么不同，只是把“网络号”换成为“网络前缀”。其实不然。这里最大的区别就是网络前缀的位数n不是固定的数，而是可以在0~32之间选取任意的值。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007133842542.png" class="" title="image-20231007133842542"><p>CIDR使用“斜线记法”(slash notation),或称为CIDR记法，即在IP地址后面加上斜线“&#x2F;”，斜线后面是网络前缀所占的位数。例如，CIDR表示的一个IP地址128.14.35.7&#x2F;20，二进制P地址的前20位是网络前缀（相当于原来的网络号），剩下后面12位是主机号。</p><h6 id="2-地址块"><a href="#2-地址块" class="headerlink" title="(2)地址块"></a>(2)地址块</h6><p>CIDR把网络前缀都相同的所有连续的IP地址组成一个“CIDR地址块”。一个CIDR地址块包含的IP地址数目，取决于网络前缀的位数。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。例如，已知IP地址128.14.35.7&#x2F;20是某CIDR地址块中的一个地址，现在把它写成二进制表示形式，其中的前20位是网络前缀（用粗体线表示出），而前缀后面的12位是主机号：</p><p>128.14.35.7&#x2F;20&#x3D;<strong>10000000000011100010</strong>001100000111</p><p>可以很方便地得出这个地址所在的地址块中的最小地址和最大地址：</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007134222134.png" class="" title="image-20231007134222134"><p>这个地址块的IP地址共有22个，扣除主机号为全0和全1的地址（最小地址和最大地址)后，可指派的地址数是2^12^-2个。我们常使用地址块中的最小地址和网络前缀的位数指明一个地址块（不必每次都减2算出可指派的地址数，这样做太麻烦）。显然，上面导出的最小地址并不是该地址块128.14.32.0&#x2F;20的网络地址。</p><h6 id="3-地址掩码"><a href="#3-地址掩码" class="headerlink" title="(3)地址掩码"></a>(3)地址掩码</h6><p>CIDR使用斜线记法可以让我们知道网络前缀的数值。但是计算机看不见斜线记法，而是使用二进制来进行各种计算时就必须使用32位的地址掩码(address mask)能够从IP地址迅速算出网络地址。地址掩码（常简称为掩码）由一连串1和接着的一连串0组成，而1的个数就是网络前缀的长度。地址掩码又称为子网掩码。在CIDR记法中，斜线后面的数字就是地址掩码中1的个数。例如，&#x2F;20地址块的地址掩码是：11111111111111111111000000000000(20个连续的1和接着的12个连续的0)。这个掩码用CIDR记法表示就是255.255.240.0&#x2F;20。</p><p>对于早期使用的分类P地址，其地址掩码是固定的，常常不用专门指出。例如：</p><ul><li>A类网络，地址掩码为255.0.0.0或255.0.0.0&#x2F;8。</li><li>B类网络，地址掩码为255.255.0.0或255.255.0.0&#x2F;16</li><li>C类网络，地址掩码为255.255.255.0或255.255.255.0&#x2F;24。</li></ul><p>把二进制的IP地址和地址掩码进行按位AND运算，即可得出网络地址。下图说明了AND运算的过程。AND运算就是逻辑乘法运算，其规则是：1AND1&#x3D;1,1AND0&#x3D;0,0AND0&#x3D;0。点分十进制的IP地址是128.14.35.7&#x2F;20，前缀长度是20（见图中的灰色背景)。请注意，从点分十进制的P地址并不容易看出其网络地址。要使用二进制地址来运算。在本例中把二进制P地址的前20位保留不变，剩下的12位全写为0，即可得出网络地址。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007135124781.png" class="" title="image-20231007135124781"><p>从上面的运算结果可以知道，IP地址128.14.35.7&#x2F;20所在的网络地址是128.14.32.0&#x2F;20。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007135445898.png" class="" title="image-20231007135445898"><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007135505967.png" class="" title="image-20231007135505967"><p>CIDR地址中还有三个特殊地址块，即：</p><ul><li>前缀n&#x3D;32,即32位IP地址都是前缀，没有主机号。这其实就是一个IP地址。这个特殊地址用于主机路由</li><li>前缀n&#x3D;31,这个地址块中只有两个P地址，其主机号分别为0和1。这个地址块用于点对点链路。</li><li>前缀n&#x3D;0同时IP地址也是全0，即0.0.0.0&#x2F;0。这用于默认路由。</li></ul><p>每一个CIDR地址块中的地址数一定是2的整数次幂。除最后几行外，CIDR地址块都包含了多个C类地址（是一个C类地址的2”倍，n是整数），因此在文献中有时称CIDR编址为“<strong>构造超网”</strong>。</p><p>一个大的CIDR地址块中往往包含很多小地址块，所以在路由器的转发表中就利用较大的一个CIDR地址块来代替许多较小的地址块。这种方法称为路由聚合(route aggregation),它使得转发表中只用一个项目就可以表示原来传统分类地址的很多个（例如上千个）路由项目，因而大大压缩了转发表所占的空间，减少了查找转发表所需的时间。</p><h5 id="IP地址的特点"><a href="#IP地址的特点" class="headerlink" title="IP地址的特点"></a>IP地址的特点</h5><p>(1)每一个IP地址都由网络前缀和主机号两部分组成。从这个意义上说，IP地址是一种分等级的地址结构。分两个等级的好处是：第一，IP地址管理机构在分配IP地址时只分配网络前缀（第一级），而剩下的主机号（第二级）则由得到该网络前缀的单位自行分配。这样就方便了IP地址的管理：第二，路由器根据目的主机所连接的网络前缀（即地址块）来转发分组（而不考虑目的主机号），这样就可以使转发表中的项目数大幅度减少，从而减少转发表所占的存储空间，缩短查找转发表的时间。</p><p>(2)实际上IP地址是标志一台主机（或路由器）和-一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络前缀必须是不同的。这种主机称为多归属主机(multihomed host)。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的P地址</p><p>(3)按照互联网的观点，一个网络（或子网）是指具有相同网络前缀的主机的集合，因此，用转发器或交换机连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络前缀。具有不同网络前缀的局域网必须使用路由器进行互连。</p><p>(4)在IP地址中，所有分配到网络前缀的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</p><h4 id="IP地址与MAC地址"><a href="#IP地址与MAC地址" class="headerlink" title="IP地址与MAC地址"></a>IP地址与MAC地址</h4><p>在学习IP地址时，很重要的一点就是要弄懂主机的P地址与MAC地址的区别。在局域网中，由于MAC地址已固化在网卡上的ROM中，因此常常将MAC地址称为硬件地址或物理地址。在本书中，物理地址、硬件地址和MAC地址常常作为同义词出现。物理地址的反义词就是虚拟地址、软件地址或逻辑地址，IP地址就属于这类地址。下图说明了这两种地址的区别。从层次的角度看，<strong>MAC地址是数据链路层使用的地址</strong>，而I<strong>P地址是网络层和以上各层使用的地址</strong>，是一种逻辑地址（称P地址为逻辑地址是因为P地址是用软件实现的)。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007185006503.png" class="" title="image-20231007185006503"><p>在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给数据链路层，就被封装成MAC帧。MAC帧在传送时使用的源地址和目的地址都是MAC地址，这两个MAC地址都写在MAC帧的首部中。连接在通信链路上的设备（主机或路由器）在收到MAC帧时，根据MAC帧首部中的MAC地址决定收下或丢弃。只有在剥去MAC帧的首部和尾部后把MAC层的数据上交给网络层后，网络层才能在IP数据报的首部中找到源IP地址和目的IP地址。总之，IP地址放在IP数据报的首部，而MAC地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是MAC地址。当IP数据报插入到数据链路层的MAC帧以后，整个的IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的P地址。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007185611312.png" class="" title="image-20231007185611312"><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007185626748.png" class="" title="image-20231007185626748"><p>上图画的是三个局域网用两个路由器R1和R2互连起来。现在主机H1要和主机H2通信。这两台主机的IP地址分别是IP1和IP2,而它们的MAC地址分别为MAC1和MAC2。通信的路径是：H1→经过R1转发→再经过R2转发→H2。路由器R1因同时连接到两个局域网上，因此它有两个MAC地址，即MAC3和MAC4。同理，路由器R2也有两个MAC地址MAC5和MAC6</p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器(主机或路由器)的IP地址，需要找出其相应的MAC地址。地址解析协议ARP就是用来解决这样的问题的。下图说明了协议ARP的作用。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007185952067.png" class="" title="image-20231007185952067"><p>我们知道，网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终还是必须使用链路层的MAC地址。IP地址和下面链路层的MAC地址之间由于格式不同而不存在简单的映射关系（例如，IP地址有32位，而链路层的MAC地址是48位）。此外，在个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的MAC地址改变（请注意，主机的MAC地址实际上就是其网络适配器的MAC地址）。地址解析协议ARP解决这个问题的方法是在主机的ARP高速缓存中存放一个从IP地址到MAC地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。</p><p>每一台主机都设有一个ARP高速缓存(ARP cache),里面存有本局域网上的各主机和路由器的IP地址到MAC地址的映射表，这些都是该主机目前知道的一些MAC地址。那么主机怎样知道这些MAC地址呢？我们可以通过下面的例子来说明。当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的P地址。如有，就在ARP高速缓存中查出其对应的MAC地址，再把这个MAC地址写入MAC帧，然后通过局域网把该MAC帧发往此MAC地址。也有可能查不到主机B的IP地址。这可能是主机B才入网，也可能是主机A刚刚加电，其高速缓存还是空的。在这种情况下，主机A就自动运行ARP,然后按以下步骤找出主机B的MAC地址。</p><p>(I)ARP进程在本局域网上广播发送一个ARP请求分组，下图是主机A广播发送ARP请求分组的示意图。ARP请求分组的主要内容是：“我的IP地址是209.0.0.5，MAC地址是00-00-C0-15-AD-18。我想知道IP地址为209.0.0.6的主机的MAC地址。”</p><p>(2)在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</p><p>(3)主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址。由于其余所有主机的IP地址都与ARP请求分组中要查询的P地址不一致，因此都不理睬这个ARP请求分组，下图（b)所示。ARP响应分组的主要内容是：“我的IP地址是209.0.0.6，我的MAC地址是08-O0-2B-O0-EE-0A。”请注意：虽然ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址。</p><p>(4)主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007190514367.png" class="" title="image-20231007190514367"><h4 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h4><p>IP数据报的格式说明协议IP都具有什么功能。在协议IP的标准中，描述首部格式的宽度是32位（即4字节）。下图是IP数据报的完整格式</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007191757934.png" class="" title="image-20231007191757934"><p>从图可看出，一个IP数据报由首部和数据两部分组成。首部的前一部分长度是固定的，共20字节，是所有IP数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。下面介绍首部各字段的意义。</p><h6 id="IP数据报首部的固定部分中的各字段"><a href="#IP数据报首部的固定部分中的各字段" class="headerlink" title="IP数据报首部的固定部分中的各字段"></a>IP数据报首部的固定部分中的各字段</h6><p>(1)版本占4位，指协议IP的版本。通信双方使用的协议IP的版本必须一致。这里讨论的协议IP版本号为4（即IPv4)。关于IPv6(即版本6的协议IP)。</p><p>(2)首部长度占4位，可表示的最大十进制数值是15。请注意，首部长度字段所表示数的单位是32位字长(1个32位字长是4字节)。因为IP首部的固定部分是20字节，因此首部长度字段的最小值是5（即二进制表示的首部长度是0101）。而当首部长度字段为最大值1111时（即十进制的15），就表明首部长度达到最大值一15个32位字长，即60字节。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现协议IP时较为方便。首部长度限制为60字节的缺点是有时可能不够用，但这样做是希望用户尽量减少开销。最常用的首部长度是20字节，不使用任何可选字段。</p><p>(3)区分服务占8位，用来获得更好的服务。这个字段在旧标准中叫作服务类型，但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务DS(DifferentiatedServices)。只有在使用区分服务时，这个字段才起作用）。在一般的情况下都不使用这个字段。</p><p>(4)总长度总长度指首部和数据之和的长度，单位为字节。总长度字段为16位，因此数据报的最大长度为2^26^-1&#x3D;65535字节。然而实际上传送这样长的数据报在现实中是极少遇到的。</p><p>我们知道，在P层下面的每一种数据链路层协议都规定了一个数据帧中的<strong>数据字段的最大长度</strong>，这称为最<strong>大传送单元</strong>MTU(Maximum Transfer Unit)。当一个IP数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的MTU值。例如，最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行分片处理。</p><p>(5)标识(identification)占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p><p>(6)标志(flag)占3位，但目前只有两位有意义。</p><ul><li>标志字段中的最低位记为MF(More Fragment)。MF&#x3D;1即表示后面“还有分片”的数据报。MF&#x3D;0表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为DF(Don’t Fragment),意思是“不能分片”。只有当DF&#x3D;0时才允许分片。</li></ul><p>(7)片偏移占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，除最后一个数据报片外，其他每个分片的长度一定是8字节(64位)的整数倍。</p><p>(8)生存时间占8位，生存时间字段常用的英文缩写是TTL(Time To Live),表明这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器R1转发到R2,再转发到R3,然后又转发到R1),因而白白消耗网络资源。最初的设计以秒作为TTL值的单位。每经过一个路由器时，就把TTL减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒，就把TTL值减1。当TTL值减为零时，就丢弃这个数据报。然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”（但名称不变）。路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，现在TTL的单位不再是秒，而是跳数。TTL的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是255。若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前TTL值就减小到零，所以会被这个路由器丢弃。</p><p>(9)协议占8位，协议字段指出此数据报携带的数据使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理。</p><p>常用的一些协议和相应的协议字段值如下</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007194430318.png" class="" title="image-20231007194430318"><p>(10)首部检验和占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化)。不检验数据部分可减少计算的工作量。为了进一步减少计算检验和的工作量，IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，把首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报：否则即认为出差错，并将此数据报丢弃。</p><p>(11)源地址占32位。发送P数据报的主机的P地址。</p><p>(12)目的地址占32位。接收P数据报的主机的IP地址。</p><h6 id="IP数据报首部的可变部分"><a href="#IP数据报首部的可变部分" class="headerlink" title="IP数据报首部的可变部分"></a>IP数据报首部的可变部分</h6><p>IP数据报首部的可变部分就是一·个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从1字节到40字节不等，取决于所选择的项目。某些选项项目只需要1字节，它只包括1字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全0的填充字段补齐为4字节的整数倍。增加首部的可变部分是为了增加P数据报的功能，但这同时也使得P数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑P首部的选项字段，因此新的IP版本IPν6就把IP数据报的首部长度做成固定的了。</p><h3 id="IP层转发分组的过程"><a href="#IP层转发分组的过程" class="headerlink" title="IP层转发分组的过程"></a>IP层转发分组的过程</h3><h4 id="基于终点的转发"><a href="#基于终点的转发" class="headerlink" title="基于终点的转发"></a>基于终点的转发</h4><p>我们在前面已经描述了分组在互联网中逐跳转发的概念。分组在互联网上传送和转发是基于分组首部中的目的地址的，因此这种转发方式称为基于终点的转发。因此，分组每到达一个路由器，路由器就根据分组中的终点（目的地址）查找转发表，然后就得知下一跳应当到哪一个路由器。</p><p>但是，路由器中的转发表却不是按目的P地址来直接查出下一跳路由器的。这是因为互联网中的主机数目实在太大了。如果用目的地址直接查找转发表，那么这种结构的转发表就会非常庞大，使得查找过程非常之慢。这样的转发表也就没有实用价值了。因此必须想办法压缩转发表的大小。我们知道，32位的IP地址是由两级组成的。前一部分是前缀，表示网络，后一部分表示主机。所以可以把查找目的主机的方法变通一下，即不是直接查找目的主机，而是先查找目的网络（网络前缀），在找到了目的网络之后，就把分组在这个网络上直接交付目的主机。由于互联网上的网络数远远小于主机数，这样就可以大大压缩转发表的大小，加速分组在路由器中的转发。这就是基于终点的转发过程。读者可能还会想到一个问题，就是分组首部中没有地方可以用来指明“下一跳路由器的IP地址”，那么待转发的分组又怎样能够找到下一跳路由器呢？</p><p>当路由器收到一个待转发的分组，在从转发表得出下一跳路由器的IP地址后，不是把这个地址填入分组首部，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的IP地址转换成MAC地址（必须使用ARP),并将此MAC地址放在链路层的MAC帧的首部，然后利用这个MAC地址传送到下一跳路由器的链路层，再取出MAC帧的数据部分，交给网络层。由此可见，当发送一连串的分组时，上述的这种查找转发表、调用ARP解析出MAC地址、把MAC地址写入MAC帧的首部等过程，都是必须做的（当然都是由机器自动完成的)。</p><p>那么，能不能在转发表中不使用IP地址而直接使用MAC地址呢？不行。我们一定要弄清楚，使用抽象的P地址，本来就是为了隐蔽各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出些代价，例如在选择路由时多了一些开销。但反过来，如果在转发表中直接使用MAC地址，那就会带来更多的麻烦，甚至无法找到对方的机器。</p><h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><p>在采用CIDR编址时，如果一个分组在转发表中可以找到多个匹配的前缀，那么就应当选择前缀最长的一个作为匹配的前缀。这个原则称为<strong>最长前缀匹配</strong>(longest prefixmatch)。网络前缀越长，其地址块就越小，因而路由就越具体(more specific)。为了更加迅速地查找转发表，可以按照前缀的长短，把前缀最长的排在第1行，然后按前缀长短的顺序往下排列。用这种方法从第1行前缀最长的开始查找，只要检查到匹配的，就不必再继续往下查找，可以立即结束查找。</p><p>实际的转发表有时还可能增加两种特殊的路由，就是主机路由和默认路由。主机路由(host route)又叫作特定主机路由，这是对特定目的主机的IP地址专门指明的一个路由。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或转发表进行排错时，指明到某一台主机的特殊路由就十分有用。假定这个特定主机的点分十进制IP地址是a.b.c.d,那么在转发表中对应于主机路由的网络前缀就是a.b.c.d&#x2F;32。我们知道，&#x2F;32表示的子网掩码是32个1。实际的网络不可能使用32位的前缀，因为没有主机号的P地址是没有实际意义的。但这个特殊的前缀却可以用在转发表中。不难看出，32个1的子网掩码和P地址a.b.c.d按位进行AND运算后，得出的结果必定是a.b.c.d,也就是说，找到了匹配。这时就把收到的分组转发到转发表所指出的下一跳。主机路由在转发表中都放在最前面。</p><p>还有一种特殊路由是默认路由(default route)。这就是不管分组的最终目的网络在哪里，都由指定的路由器R来处理。这在网络只有很少的对外连接时非常有用。在实际的转发表中，用一个特殊前缀0.0.0.0&#x2F;0来表示默认路由。这个前缀的掩码是全0(&#x2F;0表示网络前缀是0位，因此掩码是32个0)。用全0的掩码和任何目的地址进行按位AND运算，结果一定是全0，即必然是和转发表中的0.0.0.0&#x2F;0相匹配的。这时就按照转发表的指示，把分组送交下一跳路由器R来处理（即间接交付）。</p><p>综上所述，可归纳出分组转发算法如下（假定转发表按照前缀的长短排列，把前缀长的放在前面)：</p><ol><li>从收到的分组的首部提取目的主机的P地址D(即目的地址)。</li><li>若查找到有特定主机路由（目的地址为D),就按照这条路由的下一跳转发分组：否则从转发表中下一行（也就是前缀最长的一行）开始检查，执行(3)。</li><li>把这一行的子网掩码与目的地址D按位进行AND运算。若运算结果与本行的前缀匹配，则查找结束，按照“下一跳”所指出的进行处理（或直接交付本网络上的目的主机，或通过指定接口发送到下一跳路由器)。否则，若转发表还有下一行，则对下一行进行检查，重新执行(3)。否则，执行(4)。</li><li>若转发表中有一个默认路由，则按照指明的接口，把分组传送到指明的默认路由器：否则，报告转发分组出错。</li></ol><h4 id="使用二叉线索查找转发表"><a href="#使用二叉线索查找转发表" class="headerlink" title="使用二叉线索查找转发表"></a>使用二叉线索查找转发表</h4><p>为了进行更加有效的查找，通常是把无分类编址的转发表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索(binary trie)°，它是一种特殊结构的树。P地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表转发表中存放的各个地址。</p><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p>为了更有效地转发P数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是互联网的标准协议。但ICMP不是高层协议（看起来好像是高层协议，因为ICMP报文装在IP数据报中，作为其中的数据部分），而是IP层的协议。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。ICMP报文格式</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007203756380.png" class="" title="image-20231007203756380"><p>ICMP报文有两种，即ICMP差错报告报文和ICMP询问报文。ICMP报文的前4字节是统一的格式，共有三个字段：类型、代码和检验和。接着的4字节的内容与ICMP的类型有关。最后面是数据字段，其长度取决于ICMP的类型。下图给出了几种常用的ICMP报文类型。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007203928010.png" class="" title="image-20231007203928010"><p>表4给出的ICMP差错报告报文共有四种，即：</p><ol><li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li>时间超过：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（也就是说，找到了更好的路由）。</li></ol><p>所有的ICMP差错报告报文中的数据字段都具有同样的格式（如图4-29所示）。把收到的需要进行差错报告的P数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。提取收到的数据报的数据字段前8个字节是为了得到运输层的端口号（对于TCP和UDP)以及运输层报文的发送序号（对于TCP)。这些信息对源点通知高层协议是有用的。整个ICMP报文作为P数据报的数据字段发送给源点。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007204616603.png" class="" title="image-20231007204616603"><p>下面是不应发送ICMP差错报告报文的几种情况：</p><ul><li>对ICMP差错报告报文，不再发送ICMP差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送ICMP差错报告报文。</li><li>对具有多播地址的数据报，都不发送ICMP差错报告报文。</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报，不发送ICMP差错报告报文。</li></ul><p>常用的ICMP询问报文有两种，即：</p><p>(1)回送请求或回送回答</p><p>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送CMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</p><p>(2)时间戳请求或时间戳回答</p><p>在ICMP时间戳请求报文发出后，就能够收到对方响应的ICMP时间戳回答报文。利用在报文中记录的时间戳（如报文的发送时间和接收时间），发送方很容易计算出当前网络的往返时延。</p><h3 id="互联网的选择协议"><a href="#互联网的选择协议" class="headerlink" title="互联网的选择协议"></a>互联网的选择协议</h3><h4 id="有关路由选择协议的几个基本概念"><a href="#有关路由选择协议的几个基本概念" class="headerlink" title="有关路由选择协议的几个基本概念"></a>有关路由选择协议的几个基本概念</h4><h5 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h5><ol><li>算法必须是正确的和完整的。这里，“正确”的含义是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li>算法在计算上应简单。路由选择的计算不应使网络通信量增加太多的额外开销。</li><li>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些节点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“稳健性”(robustness)。</li><li>算法应具有稳定性。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li><li>算法应是公平的。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。</li><li>算法应是最佳的。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到“最佳”的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ol><p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即静态路由选择策略与动态路由选择策略。静态路由选择也叫作非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫作自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。</p><h5 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h5><p>互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选译协议。由于以下两个原因，互联网采用分层次的路由选择协议：</p><ol><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议(这属于本部门内部的事情)，但同时还希望连接到互联网上。</li></ol><p>为此，可以把整个互联网划分为许多较小的自治系统(autonomous system),一般都记为AS。自治系统AS是在单一技术管理下的许多网络、IP地址以及路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。每一个AS对其他AS表现出的是一个<strong>单一的和一致的路由选择策略</strong>。这样，互联网就把路由选择协议划分为两大类，即：</p><p>(I)内部网关协议IGP(Interior Gateway Protocol)<br>即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多的是RIP和OSPF协议(IS-IS协议也很流行，但不介绍了)。</p><p>(2)外部网关协议EGP(External Gateway Protocol)<br>若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），那么在不同自治系统AS之间的路由选择，就需要使用外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4</p><p>自治系统之间的路由选择也叫作域间路由选择(interdomain routing),而在自治系统内部的路由选择叫作域内路由选择(intradomain routing)。</p><p>总之，使用分层次的路由选择方法，可将互联网的路由选择协议划分为：</p><ul><li>内部网关协议IGP:具体的协议有多种，如RIP和OSPF等。</li><li>外部网关协议EGP:目前使用的协议是BGP-4。</li></ul><h4 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h4><h5 id="协议RIP的工作原理"><a href="#协议RIP的工作原理" class="headerlink" title="协议RIP的工作原理"></a>协议RIP的工作原理</h5><p>RIP(Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议,它的中文译名是路由信息协议。RIP是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单</p><p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是一组距离，即“距离向量”）。协议RIP将“距离”定义如下：</p><p>从一路由器到直接连接的网络的距离定义为1。从一主机到非直接连接的网络的距离定义为所经过的路由器数加1。“加1”是因为到达目的网络后就进行直接交付（不需要再经过路由器)，而到直接连接的网络的距离已经定义为1。</p><p>协议RIP的“距离”也称为“跳数”(hop count),并且每经过一个网络，跳数就加1。RIP认为好的路由就是它通过的网络数目少，即“距离短”。RP允许一条路径最多只能包含15个网络。因此“距离”等于16时即相当于不可达。可见RP只适用于小型互联网。</p><p>RIP不能在两个网络之间同时使用多条路由。RP选择一条具有最少网络数的路由（即最短路由)，哪怕还存在另一条高速（低时延）但网络数较多的路由。</p><h6 id="协议RIP的特点是"><a href="#协议RIP的特点是" class="headerlink" title="协议RIP的特点是"></a>协议RIP的特点是</h6><p>(1)仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。协议RIP规定，不相邻的路由器不交换信息。</p><p>(2)路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。也就是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器”。</p><p>(3)按固定的时间间隔交换路由信息，例如，每隔30秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。网络中的主机虽然也运行协议IP,但只被动地接收路由器发来的路由信息。</p><p>这里要强调一点：路由器在刚刚开始工作时，它的路由表是空的。然后路由器就得出到直接相连的几个网络的距离（这些距离定义为1）。接着，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</p><p>路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的最短距离。这种更新算法又称为距离向量算法。下面就是协议RP使用的距离向量算法。</p><h5 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h5><p>对每一个相邻路由器发送过来的RIP报文，执行以下步骤：</p><p>(1)对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为X,并把所有的“距离”字段的值加1（见后面的解释1）。每一个项目都有三个关键数据，即：到目的网络Net,距离是d,下一跳路由器是X。</p><p>(2)对修改后的RIP报文中的每一个项目，进行以下步骤：若原来的路由表中没有目的网络Nt,则把该项目添加到路由表中（见解释2）。否则（即在路由表中有目的网络Nt,这时就再查看下一跳路由器地址）。若下一跳路由器地址是X,则把收到的项目替换原路由表中的项目（见解释3）。否则（即这个项目是：到目的网络Nt,但下一跳路由器不是X)。若收到的项目中的距离d小于路由表中的距离，则进行更新（见解释4），否则什么也不做（见解释5）。</p><p>(3)若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为16（距离为16表示不可达）。</p><p>(4)返回:上面给出的距离向量算法的基础就是Bellman-Ford算法（或Ford-Fulkerson算法）。这种算法的要点是这样的：设X是节点A到B的最短路径上的一个节点。若把路径A→B拆成两段路径A→X和X→B,则每一段路径A→X和X→B也都分别是节点A到X和节点X到B的最短路径。</p><p>解释1：这样做是为了便于进行本路由表的更新。假设从位于地址X的相邻路由器发来的RIP报文的某一个项目是：“Net2,3,Y”,意思是“我经过路由器Y到网络Net2的距离是3”,那么本路由器就可推断出：“我经过X到网络Nt2的距离应为3+1&#x3D;4”。于是，本路由器就把收到的RIP报文的这一个项目修改为“Nt2,4,X”,作为下一步和路由表中原有项目进行比较时使用（只有比较后才能知道是否需要更新）。读者可注意到，收到的项目中的Y对本路由器是没有用的，因为Y不是本路由器的下一跳路由器地址。</p><p>解释2：表明这是新的目的网络，应当加入到路由表中。例如，本路由表中没有到目的网络Net2的路由，那么在路由表中就要加入新的项目“Net2,4.X”。</p><p>解释3：为什么要替换呢？因为这是最新的消息，要以最新的消息为准。到目的网络的距离有可能增大或减小，但也可能没有改变。例如，不管原来路由表中的项目是“Nt2,3,X”还是“Net2,5,X”,都要更新为现在的“Net2,4,X”。</p><p>解释4：例如，若路由表中已有项目“Net2,5,P”,就要更新为“Net2,4,X”。因为到网络Net2的距离原来是5，现在减到4，更短了。</p><p>解释5：若距离更大了，显然不应更新。若距离不变，更新后得不到好处，因此也不更新。</p><p>协议RIP让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少)。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><p>RIP报文作为运输层用户数据报UDP的数据部分进行传送(使用UDP的端口520）</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007212202904.png" class="" title="image-20231007212202904"><p>RIP报文由首部和路由部分组成。在路由部分要填入自治系统号ASN(AutonomousSystem Number)，这是考虑使RIP有可能收到本自治系统以外的路由选择信息。还要指出目的网络地址（包括网络的子网掩码）、下一跳路由器地址以及到此网络的距离。一个RIP报文最多可包括25个路由。如超过，必须再用一个RIP报文来传送。</p><h5 id="坏消息传播得慢"><a href="#坏消息传播得慢" class="headerlink" title="坏消息传播得慢"></a>坏消息传播得慢</h5><p>RIP存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</p><p>总之，协议RIP最大的优点就是实现简单，开销较小。但协议RIP的缺点也较多。首先，RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用下一节所述的OSP协议。然而目前在规模较小的网络中，使用协议RIP的仍占多数。</p><h4 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h4><h5 id="协议OSPF的基本特点"><a href="#协议OSPF的基本特点" class="headerlink" title="协议OSPF的基本特点"></a>协议OSPF的基本特点</h5><p>这个协议的名字是开放最短路径优先OSPF(Open Shortest Path First)。它是为克服RIP的缺点在1989年开发出来的。OSPF的原理很简单，但实现起来却较复杂。“开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的。“最短<br>路径优先”是因为使用了Dijkstra提出的最短路径算法SPF。现在使用的协议OSPF是第二个版OSPFv2[RFC2328,STD54]。关于OSPF可参阅专著[MOY98],[HUIT95]。请注意：OSPF只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。实际上，所有的在自治系统内部使用的路由选择协议（包括协议RIP)都是要寻找条最短的路径。<br>OSPF最主要的特征就是使用链路状态协议(link state protocol),而不是像RIP那样的距离向量协议。协议OSPF的特点是：</p><ol><li>向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法(flooding),这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。更具体的做法后面还要讨论。我们应注意，协议RIP是仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。OSPF将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。我们应注意，对于协议RIP,发送的信息是：“到所有网络的距离和下一跳路由器”。</li><li>当链路状态发生变化或每隔一段时间（如30分钟），路由器向所有路由器用洪泛法发送链路状态信息。</li></ol><p>从上述的前两点可以看出，OSPF和RIP的工作原理相差较大。由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库(Iink-state database),这个数据库实际上就是全网的拓扑结构图。这个拓扑结构图在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表（例如，使用Dijkstra的最短路径路由算法)。我们注意到，协议RIP的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却<strong>不知道全网的拓扑结构</strong>（只有到了下一跳路由器，才能知道再下一跳应当怎样走）。</p><p>OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF的<strong>更新过程收敛得快</strong>是其重要优点。</p><p>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫作区域(area)。就表示一个自治系统划分为四个区域。每一个区域都有一个32位的区域标识符（用点分十进制形式表示）。当然，一个区域也不能太大，在一个区域内的路由器最好不超过200个。</p><p>划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF使用层次结构的区域划分。在上层的区域叫作<strong>主干区域</strong>(backbonearea)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由<strong>区域边界路由器</strong>(area border router)进行概括。在图中，路由器R3,R4和R?都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫作主干路由器(backbone router),如R3,R4,R,R6和R7。一个主干路由器可以同时是区域边界路由器，如R3,R4和R,。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫作<strong>自治系统边界路由器</strong></p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007213522312.png" class="" title="image-20231007213522312"><p>除了以上的几个基本特点外，OSPF还具有下列的一些特点：</p><p>(I)OSPF允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF对于不同类型的业务可计算出不同的路由。链路的代价可以是1至65535中的任何一个无量纲的数，因此十分灵活。商用的网络在使用OSP℉时，通常根据链路带宽来计算链路的代价。这种灵活性是RIP所没有的。</p><p>(2)如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作多路径间的负载均衡(load balancing)。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RP只能找出到某个网络的一条路径。</p><p>(3)所有在OSPF路由器之间交换的分组（例如，链路状态更新分组）都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</p><p>(4)OSPF支持可变长度的子网划分和无分类的编址CIDR。</p><p>(5)由于网络中的链路状态可能经常发生变化，因此OSPF让每一个链路状态都带上一个32位的序号，序号越大状态就越新。OSPF规定，链路状态序号增长的速率不得超过每5秒钟1次。这样，全部序号空间在600年内不会产生重复号。</p><h5 id="OSPF的五种分组类型"><a href="#OSPF的五种分组类型" class="headerlink" title="OSPF的五种分组类型"></a>OSPF的五种分组类型</h5><p>(1)类型1，问候Hllo)分组，用来发现和维持邻站的可达性。</p><p>(2)类型2，数据库描述(Database Description)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</p><p>(3)类型3，链路状态请求(Link State Request)分组，向对方请求发送某些链路状态项目的详细信息。</p><p>(4)类型4，链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态],这里从略。</p><p>(5)类型5，链路状态确认(Link State Acknowledgment)分组，对链路更新分组的确认。OSPF分组是作为IP数据报的数据部分来传送的（如图4-43所示）。OSPF不用UDP而是直接用IP数据报传送（其P数据报首部的协议字段值为89）。OSPF构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><p>OSPF分组是作为IP数据报的数据部分来传送的。OSPF不用UDP而是直接用IP数据报传送（其IP数据报首部的协议字段值为89）。OSPF构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><img src="/2023/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/image-20231007214223107.png" class="" title="image-20231007214223107"><h4 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><h5 id="协议BGP的主要特点"><a href="#协议BGP的主要特点" class="headerlink" title="协议BGP的主要特点"></a>协议BGP的主要特点</h5><p>我们知道，内部网关协议（如RIP或OSPF)主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为以下的两个原因：</p><p>第一，互联网的规模太大，使得自治系统AS之间路由选择非常困难</p><p>第二，自治系统AS之间的路由选择必须考虑有关策略。</p><p>由于上述情况，边界网关协议BGP只能是力求选择出一条能够到达目的网络前缀且比较好的路由（不能兜圈子），而并非要计算出一条最佳路由。这里所说的BGP路由，是指经过哪些自治系统AS可以到达目的网络前缀。当然，这选择出的比较好的路由，也有时不严格地称为最佳路由。BGP采用了路径向量(path vector)路由选择协议，它与距离向量协议(如RIP)和链路状态协议（如OSPF)都有很大的区别。</p><h5 id="BGP路由"><a href="#BGP路由" class="headerlink" title="BGP路由"></a>BGP路由</h5><p>在一个自治系统AS中有两种不同功能的路由器，即边界路由器（或边界网关）和内部路由器。一个AS至少要有一个边界路由器和相邻AS的边界路由器直接相连。在讨论协议BGP时，应特别注意边界路由器的作用。正是由于有了边界路由器，AS之间才能利用协议BGP交换可达性路由信息。</p><h5 id="BGP的四种报文"><a href="#BGP的四种报文" class="headerlink" title="BGP的四种报文"></a>BGP的四种报文</h5><p>在协议BGP刚运行时，BGP连接的对等端要相互交换整个的BGP路由表。但以后只<br>需要在BGP路由发生变化时，才更新有变化的部分。这样做对节省网络带宽和减少路由器<br>的处理开销方面都有好处。在RFC4271中规定了BGP.4的四种报文：</p><ul><li>OPEN(打开)报文，用来与BGP连接对等端建立关系。</li><li>UPDATE(更新)报文，用来通告某一路由的信息，以及列出要撤销的路由。</li><li>KEEPALIVE(保活)报文，用来周期性地证实与对等端的连通性。</li><li>NOTIFICATION(通知)报文，用来发送检测到的差错。</li></ul><p>OPEN报文是两个路由器之间建立了TCP连接后接着就必须发送的报文。OPEN报文的作用是相互识别对方，协商一些协议参数（如计时器的时间）。收到OPEN报文的路由器，就发回KEEPALIVE报文表示接受建立BGP连接。UPDATE报文是BGP协议的核心，用来撤销它以前曾经通知过的路由，或宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。虽然BGP连接的两端建立了TCP连接，传输报文是可靠的，但TCP上层的BGP是否始终正常工作还无法确知。在对等端之间定期传送BGP路由表是不可取的，因为BGP路由表往往过于庞大，这样做会使网络的通信量过大。因此协议BGP采用的方法是让BGP连接的两个对等端之间，周期性地交换KEEPALIVE报文，以表示协议工作正常。KEEPALIVE报文只包含BGP报文的通用首部(19字节长)，因此不会在网络上产生多少开销。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2023/09/26/HTML/"/>
    <url>/2023/09/26/HTML/</url>
    
    <content type="html"><![CDATA[<p>HTML值的是超文本标记语言，是用于编写网页的主要语言</p><span id="more"></span><h4 id="HTML的主要功能"><a href="#HTML的主要功能" class="headerlink" title="HTML的主要功能"></a>HTML的主要功能</h4><ul><li><strong>定义（或设置）文本</strong>：定义文本的标题、段落等。此外，还可以设置文字的字体、字号、颜色等样式。但是现在一般不用HTML设置样式，而是用CSS.</li><li><strong>插入图像：</strong>在网页中插入图像，使网页图文并茂。</li><li><strong>建立超链接：</strong> 通过超链接实现不同网站的跳转</li><li><strong>创建列表：</strong> 将信息用一种易读的反感方式表现出来</li><li><strong>创建表单：</strong> 通过表单实现人机交互、使网站的功能更加完善</li><li>**建立表格： ** 以表格的形式显示页面信息，为浏览者查找信息提供便利</li><li><strong>插入多媒体：</strong> 通过网页共享音频、视频、动画等。并设置播放时间和次数</li></ul><h4 id="HTML的标签的基本语法"><a href="#HTML的标签的基本语法" class="headerlink" title="HTML的标签的基本语法"></a>HTML的标签的基本语法</h4><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul><li>HTML 标签是由<em>尖括号</em>包围的关键词，比如 <code>&lt;html&gt;</code></li><li>HTML 标签通常是<em>成对出现</em>的，比如<code> &lt;b&gt; </code>和 <code>&lt;/b&gt;</code></li><li>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em></li><li>开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></li></ul><h4 id="HTML基本结构"><a href="#HTML基本结构" class="headerlink" title="HTML基本结构"></a>HTML基本结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>文档头部<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>文档主体<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="HTML的标签分类"><a href="#HTML的标签分类" class="headerlink" title="HTML的标签分类"></a>HTML的标签分类</h4><p>根据是否独占一行可以将HTML标签分为块标签和行标签</p><ul><li>块标签：独占一行，可以设置宽度和高度属性，而且元素在页面中遵循从上到下的顺序列表，如段落标签<code>&lt;p&gt;&lt;/p&gt;</code></li><li>行标签：也称内联标签、行内标签等不能独自占据一行，设置宽度和高度无效，而且元素在页面中遵循从左到右的顺序排列，如超链接标签<code>&lt;a&gt;&lt;/a&gt;</code></li></ul><h4 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h4><p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在<code> &lt;head&gt;</code>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。</p><p>可以添加在头部区域的元素标签为: <code>&lt;title&gt;</code>,<code> &lt;style&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code>,<code> &lt;script&gt;</code>, <code>&lt;noscript&gt; </code>和 <code>&lt;base&gt;</code>。</p><h5 id="标签"><a href="#标签" class="headerlink" title="&lt;title&gt;标签"></a><code>&lt;title&gt;</code>标签</h5><p><code>&lt;title&gt; </code>元素:</p><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文档标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>文档内容......<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;meta&gt;标签"></a><code>&lt;meta&gt;</code>标签</h5><p>meta标签描述了一些基本的元数据。</p><p><code>&lt;meta&gt;</code> 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p><p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p><h4 id="HTML无语义标签"><a href="#HTML无语义标签" class="headerlink" title="HTML无语义标签"></a>HTML无语义标签</h4><h5 id="标签-2"><a href="#标签-2" class="headerlink" title="&lt;span&gt;标签"></a><code>&lt;span&gt;</code>标签</h5><p><code>&lt;span&gt;</code> 用于对文档中的行内元素进行组合。</p><p><code>&lt;span&gt; </code>标签没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。如果不对 <code>&lt;span&gt;</code> 应用样式，那么<code>&lt;span&gt;</code>元素中的文本与其他文本不会任何视觉上的差异。</p><p><code>&lt;span&gt;</code> 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。</p><h5 id="标签-3"><a href="#标签-3" class="headerlink" title="&lt;div&gt;标签"></a><code>&lt;div&gt;</code>标签</h5><p><code>&lt;div&gt;</code> 标签定义 HTML 文档中的一个分隔区块或者一个区域部分。</p><p><code>&lt;div&gt;</code>标签常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化。</p><h4 id="HTML文字相关标签"><a href="#HTML文字相关标签" class="headerlink" title="HTML文字相关标签"></a>HTML文字相关标签</h4><h5 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签&lt;h1&gt;~&#96;&#96;"></a>标题标签<code>&lt;h1&gt;</code>~&#96;<h6>&#96;</h5><p><code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签被用来定义 HTML 标题。</p><p><code>&lt;h1&gt; </code>定义重要等级最高的标题。<code>&lt;h6&gt; </code>定义重要等级最低的标题。</p><h5 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签&lt;p&gt;"></a>段落标签<code>&lt;p&gt;</code></h5><p><code>&lt;p&gt;</code> 标签定义段落。</p><p><code>&lt;p&gt;</code>元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。</p><h5 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签&lt;br/&gt;"></a>换行标签<code>&lt;br/&gt;</code></h5><p><code>&lt;br&gt;</code> 标签插入一个简单的换行符。</p><p><code>&lt;br&gt;</code> 标签是一个空标签，意味着它没有结束标签。</p><h5 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签&lt;hr/&gt;"></a>水平线标签<code>&lt;hr/&gt;</code></h5><p><code>&lt;hr&gt; </code>标签定义 HTML 页面中的主题变化（比如话题的转移），并显示为一条水平线。</p><p><code>&lt;hr&gt;</code> 元素被用来分隔 HTML 页面中的内容（或者定义一个变化）。</p><h5 id="文本样式标签"><a href="#文本样式标签" class="headerlink" title="文本样式标签&lt;font&gt;"></a>文本样式标签<code>&lt;font&gt;</code></h5><p><code>&lt;font&gt; </code>标签规定文本的字体、字体尺寸、字体颜色。</p><h5 id="倾斜字体标签和"><a href="#倾斜字体标签和" class="headerlink" title="倾斜字体标签&lt;i&gt;和&lt;em&gt;"></a>倾斜字体标签<code>&lt;i&gt;</code>和<code>&lt;em&gt;</code></h5><p><code>&lt;i&gt; </code>定义与文本中其余部分不同的部分，并把这部分文本呈现为斜体文本。</p><p><code>&lt;i&gt; </code>标签被用来表示科技术语、其他语种的成语俗语、想法、宇宙飞船的名字等等。</p><p><code>&lt;em&gt;</code> 标签是一个短语标签，用来呈现为被强调的文本。</p><h5 id="加粗文字标签和"><a href="#加粗文字标签和" class="headerlink" title="加粗文字标签&lt;b&gt;和&lt;strong&gt;"></a>加粗文字标签<code>&lt;b&gt;</code>和<code>&lt;strong&gt;</code></h5><p><code>&lt;b&gt; </code>标签定义粗体的文本。</p><p><code>&lt;strong&gt; </code>标签是一个短语标签，用来定义计算机程序的样本重要的文本。</p><h5 id="文字下划线标签"><a href="#文字下划线标签" class="headerlink" title="文字下划线标签&lt;u&gt;"></a>文字下划线标签<code>&lt;u&gt;</code></h5><p><code>&lt;u&gt; </code>标签定义与常规文本风格不同的文本，像拼写错误的单词或者汉语中的专有名词。</p><h4 id="HTML图像标签"><a href="#HTML图像标签" class="headerlink" title="HTML图像标签"></a>HTML图像标签</h4><h5 id="标签-4"><a href="#标签-4" class="headerlink" title="&lt;img&gt;标签"></a><code>&lt;img&gt;</code>标签</h5><p><code>&lt;img&gt; </code>标签定义 HTML 页面中的图像。</p><p><code>&lt;img&gt; </code>标签有两个必需的属性：src 和 alt。</p><h4 id="HTML超链接标签"><a href="#HTML超链接标签" class="headerlink" title="HTML超链接标签"></a>HTML超链接标签</h4><h5 id="标签-5"><a href="#标签-5" class="headerlink" title="&lt;a&gt;标签"></a><code>&lt;a&gt;</code>标签</h5><p><code>&lt;a&gt;</code> 标签定义超链接，用于从一个页面链接到另一个页面。</p><p><code>&lt;a&gt; </code>元素最重要的属性是 href 属性，它指定链接的目标。</p><h4 id="HTML列表标签"><a href="#HTML列表标签" class="headerlink" title="HTML列表标签"></a>HTML列表标签</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表&lt;ul&gt;"></a>无序列表<code>&lt;ul&gt;</code></h5><p><code>&lt;ul&gt;</code> 标签定义无序列表。</p><p>将 <code>&lt;ul&gt; </code>标签与 <code>&lt;li&gt;</code>标签一起使用，创建无序列表。</p><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表&lt;ol&gt;"></a>有序列表<code>&lt;ol&gt;</code></h5><p><code>&lt;ol&gt; </code>标签定义了一个有序列表. 列表排序以数字来显示。</p><p>使用<code>&lt;li&gt;</code> 标签来定义列表选项。</p><h6 id="标签定义列表项目。"><a href="#标签定义列表项目。" class="headerlink" title="&lt;li&gt; 标签定义列表项目。"></a><code>&lt;li&gt;</code> 标签定义列表项目。</h6><h4 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表&lt;dl&gt;"></a>定义列表<code>&lt;dl&gt;</code></h4><p><code>&lt;dl&gt;</code> 标签定义一个描述列表。</p><p><code>&lt;dl&gt; </code>标签与<code>&lt;dt&gt;</code>（定义项目&#x2F;名字）和<code>&lt;dd&gt;</code>（描述每一个项目&#x2F;名字）一起使用。</p><h4 id="HTML表单标签"><a href="#HTML表单标签" class="headerlink" title="HTML表单标签"></a>HTML表单标签</h4><h5 id="标签-6"><a href="#标签-6" class="headerlink" title="标签&lt;from&gt;"></a>标签<code>&lt;from&gt;</code></h5><p><code>&lt;form&gt;</code> 标签用于创建供用户输入的 HTML 表单。</p><p><code>&lt;form&gt;</code> 元素包含一个或多个如下的表单元素：</p><ul><li><code>&lt;input&gt;</code></li><li><code>&lt;textarea&gt;</code></li><li><code>&lt;butten&gt;</code></li><li><code>&lt;select&gt;</code></li><li><code>&lt;option&gt;</code></li><li><code>&lt;optgroup&gt;</code></li><li><code>&lt;fieldset&gt;</code></li><li><code>&lt;label&gt;</code></li></ul><h5 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件&lt;input&gt;"></a>表单控件<code>&lt;input&gt;</code></h5><p><code>&lt;input&gt; </code>标签规定了用户可以在其中输入数据的输入字段。</p><p><code>&lt;input&gt;</code> 元素在 <code>&lt;form&gt; </code>元素中使用，用来声明允许用户输入数据的 input 控件。</p><p>输入字段可通过多种方式改变，取决于 type 属性。</p><h5 id="多行文本域"><a href="#多行文本域" class="headerlink" title="多行文本域&lt;textarea&gt;"></a>多行文本域<code>&lt;textarea&gt;</code></h5><p><code>&lt;textarea&gt; </code>标签定义一个多行的文本输入控件。</p><p>文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。</p><p>可以通过 cols 和 rows 属性来规定 textarea 的尺寸大小，不过更好的办法是使用 CSS 的 height 和 width 属性。</p><h5 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表&lt;select&gt;"></a>下拉列表<code>&lt;select&gt;</code></h5><p><code>&lt;select&gt;</code> 元素用来创建下拉列表。</p><p><code>&lt;select&gt;</code> 元素中的 <code>&lt;option&gt;</code>标签定义了列表中的可用选项。</p><h5 id=""><a href="#" class="headerlink" title="&lt;option&gt;"></a><code>&lt;option&gt;</code></h5><p>The <code>&lt;option&gt;</code> 标签定义下拉列表中的一个选项（一个条目）。</p><h4 id="HTML表格标签"><a href="#HTML表格标签" class="headerlink" title="HTML表格标签"></a>HTML表格标签</h4><h5 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签&lt;table&gt;"></a>表格标签<code>&lt;table&gt;</code></h5><table> 标签定义 HTML 表格<p>一个 HTML 表格包括<code>&lt;table&gt;</code>元素，一个或多个<code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code>以及<code>&lt;td&gt;</code> 元素。</p><p><code>&lt;tr&gt;</code> 元素定义表格行，<code>&lt;th&gt;</code> 元素定义表头，<code>&lt;td&gt; </code>元素定义表格单元。</p><p>更复杂的 HTML 表格也可能包括<code> &lt;caption&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tfoot&gt;</code> 以及 <code>&lt;tbody&gt; </code>元素。</p><h4 id="HTML多媒体标签"><a href="#HTML多媒体标签" class="headerlink" title="HTML多媒体标签"></a>HTML多媒体标签</h4><h5 id="多媒体标签插入视频"><a href="#多媒体标签插入视频" class="headerlink" title="多媒体标签&lt;embed&gt;插入视频"></a>多媒体标签<code>&lt;embed&gt;</code>插入视频</h5><p><code>&lt;embed&gt;</code> 标签定义了一个容器，用来嵌入外部应用或者互动程序（插件）。</p><p><strong>注意</strong>：现在已经不建议使用 <code>&lt;embed&gt;</code> 标签了，可以使用 <code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>等标签代替。</p><h5 id="多媒体标签插入音频"><a href="#多媒体标签插入音频" class="headerlink" title="多媒体标签&lt;object&gt;插入音频"></a>多媒体标签<code>&lt;object&gt;</code>插入音频</h5><p>定义一个嵌入的对象。请使用此元素向您的 XHTML 页面添加多媒体。此元素允许您规定插入 HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。</p><p><code>&lt;object&gt; </code>标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。</p><p>object 的初衷是取代 img 和 applet 元素。不过由于漏洞以及缺乏浏览器支持，这一点并未实现。</p><p>浏览器的对象支持有赖于对象类型。不幸的是，主流浏览器都使用不同的代码来加载相同的对象类型。</p><p>而幸运的是，object 对象提供了解决方案。如果未显示 object 元素，就会执行位于 <code>&lt;object&gt;</code> 和 <code>&lt;/object&gt; </code>之间的代码。通过这种方式，我们能够嵌套多个 object 元素（每个对应一个浏览器）。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机的运算方法(五)</title>
    <link href="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/"/>
    <url>/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍参与运算的各类数据（包括无符号数和有符号数、定点数和浮点数等)，以及它们在计算机中的算术运算方法。</p><span id="more"></span><h3 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h3><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>计算机中的数均放在寄存器中，通常称寄存器的位数为机器字长。所谓无符号数，即没有符号的数，在寄存器中的每一位均可用来存放数值。当存放有符号数时，则需留出位置存放符号。因此，在机器字长相同时，无符号数与有符号数所对应的数值范围是不同的。以机器字长为16位为例，无符号数的表示范围为0-65535，而有符号数的表示范围为-32768~+32767</p><h4 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h4><h6 id="1-机器数与真值"><a href="#1-机器数与真值" class="headerlink" title="1.机器数与真值"></a>1.机器数与真值</h6><p>对有符号数而言，符号的“正”、“负”机器是无法识别的，但由于“正”、“负”恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。</p><h6 id="2-原码表示法"><a href="#2-原码表示法" class="headerlink" title="2.原码表示法"></a>2.原码表示法</h6><p>原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为带符号的绝对值表示。</p><p>原码表示简单明了，并易于和真值转换。但用原码进行加减运算时，却带来了许多麻烦。例如，当两个操作数符号不同且要作加法运算时，先要判断两数绝对值大小，然后将绝对值大的数减去绝对值小的数，结果的符号以绝对值大的数为准。运算步骤既复杂又费时，而且本来是加法运算却要用减法器实现。那么能否在计算机中只设加法器，只作加法操作呢？如果能找到一个与负数等价的正数来代替该负数，就可把减法操作用加法代替。而机器数采用补码时，就能满足此要求。</p><h6 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="3.反码表示法"></a>3.反码表示法</h6><p>正数的反码与原码一致，负数的反码是对原码按位取反，只是最高位（符号位）不变</p><p>4.补码表示</p><p>补码：正数的补码与原码一致，负数的补码是该数的反码加1</p><table><thead><tr><th>真值</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>+0.1011（小数）</td><td>0.1011</td><td>0.1011</td><td>0.1011</td></tr><tr><td>-0.1011（小数）</td><td>1.1011</td><td>1.0100</td><td>1.0101</td></tr><tr><td>+1100（整数）</td><td>0，1100</td><td>0，1100</td><td>0，1100</td></tr><tr><td>-1100（整数）</td><td>1，1100</td><td>1，0011</td><td>1，0100</td></tr></tbody></table><p>综上所述，三种机器数的特点可归纳如下：</p><ul><li>三种机器数的最高位均为符号位。符号位和数值部分之间可用“.”（对于小数）或“，”(对于整数)隔开。</li><li>当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同。</li><li>当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加1”，反码是原码的“每位求反”。</li></ul><p>列出了8位寄存器中所有二进制代码组合与无符号数、原码、补码和反码所代表的真值的对应关系</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906130657434.png" class="" title="image-20230906130657434"><p>由此可得出一个结论：由于“苓”在补码中只有一种表示形式，故补码比原码和反码可以多表示一个负数。</p><h6 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906131249269.png" class="" title="image-20230906131249269"><p>进一步观察发现，同一个真值的移码和补码仅差一个符号位，若将补码的符号位由“0”改为“1”,或从“1”改为“0”，即可得该真值的移码。表列出了真值、补码和移码的对应关系。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906131448857.png" class="" title="image-20230906131448857"><h3 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h3><h4 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h4><p>小数点固定在某一位置的数为定点数，有以下两种格式。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906131903561.png" class="" title="image-20230906131903561"><p>当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数决定了定点机中数的表示范围。</p><p>在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。</p><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><p>浮点数的表示<br>$$<br>N&#x3D;S×r^j<br>$$<br>式中，S为尾数（可正可负），j为阶码（可正可负），r是基数（或基值）。在计算机中，基数可取2，<br>4、8或16等。</p><p>浮点数在机器中的形式如下所示。采用这种数据格式的机器称为浮点机。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906133321911.png" class="" title="image-20230906133321911"><p>浮点数由阶码j和尾数S两部分组成。阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围及小数点的实际位置；尾数是小数，其位数反映了浮点数的精度；尾数的符号Sf代表浮点数的正负</p><h6 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h6><p>以通式N&#x3D;S×r^j为例，设浮点数阶码的数值位取m位，尾数的数值位取n位，当浮点数为非规格化时</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906133656953.png" class="" title="image-20230906133656953"><p>一且浮点数的位数确定后，合理分配阶码和尾数的位数，直接影响浮点数的表示范围和精度。通常对于短实数（总位数为32位），阶码取8位（含阶符1位），尾数取24位（含数符1位）；对于长实数（总位数为64位），阶码取11位（含阶符1位），尾数取53位（含数符1位）；对于临时实数（总位数为80位），阶码取15位（含阶符1位），尾数取65位（含数符1位）。</p><h6 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h6><p>为了提高浮点数的精度，其尾数必须为规格化数。如果不是规格化数，就要通过修改阶码并同时左右移尾数的办法，使其变成规格化数。将非规格化数转换成规格化数的过程称为规格化。对于基数不同的浮点数，因其规格化数的形式不同，规格化过程也不同。</p><p>r &#x3D; 2 尾数最高位为 1 </p><p>r &#x3D; 4 尾数最高2位不全为 0 </p><p>r &#x3D; 8 尾数最高3位不全为 0</p><ul><li>当基数为2时，尾数最高位为1的数为规格化数。规格化时，尾数左移一位，阶码减1（这种规格化称为向左规格化，简称左规)；尾数右移一位，阶码加1（这种规格化称为向右规格化，简称右规)</li><li>当基数为4时，尾数的最高两位不全为零的数为规格化数。规格化时，尾数左移两位，阶码减1：尾数右移两位，阶码加1。</li><li>当基数为8时，尾数的最高三位不全为零的数为规格化数。规格化时，尾数左移三位，阶码减1；尾数右移三位，阶码加1。</li></ul><p>基数 r 越大，可表示的浮点数的范围越大 基数不同，浮点数的规格化形式不同 基数 r 越大，浮点数的精度降低</p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p>定点运算包括移位、加、减、乘、除几种。</p><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><h6 id="移位的意义"><a href="#移位的意义" class="headerlink" title="移位的意义"></a>移位的意义</h6><p>移位运算在日常生活中常见。例如，15m可写成1500cm,单就数字而言，1500相当于数15相对于小数点左移了两位，并在小数点前面添了两个0；同样15也相当于1500相对于小数点右移了两位，并删去了小数点后面的两个0。可见，当某个十进制数相对于小数点左移位时，相当于该数乘以10；右移n位时，相当于该数除以10”。</p><p>移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。</p><h6 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h6><p>对于正数，由于[x]原&#x3D;[x]补&#x3D;[x]反&#x3D;真值，故移位后出现的空位均以0添之。对于负数，由于原码、补码和反码的表示形式不同，故当机器数移位时，对其空位的添补规则也不同。表列出了三种不同码制的机器数（整数或小数均可），分别对应正数或负数移位后的添补规则。必须注意的是：不论是正数还是负数，移位后其符号位均不变，这是算术移位的重要特点。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906141531767.png" class="" title="image-20230906141531767"><ul><li>机器数为正时，不论是左移还是右移，添补代码均为0。</li><li>由于负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添0即可。</li><li>由于负数的反码各位除符号位外与负数的原码正好相反，故移位后所添的代码应与原码相反，即全部添1。</li><li>分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。</li></ul><h6 id="算数移位的硬件实现"><a href="#算数移位的硬件实现" class="headerlink" title="算数移位的硬件实现"></a>算数移位的硬件实现</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906142456879.png" class="" title="image-20230906142456879"><p>算数移位和逻辑移位的区别</p><p>有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。逻辑移位的规则是：逻辑左移时，高位移丢，低位添0：逻辑右移时，低位移丢，高位添0。</p><h4 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h4><p>加减法运算是计算机中最基本的运算，因减法运算可看做被减数加上一个减数的负值，即A一B&#x3D;A+（一B),故在此将机器中的减法运算和加法运算合在.一起讨论。现代计算机中都采用补码作加减法运算。</p><h6 id="补码加减法的公式"><a href="#补码加减法的公式" class="headerlink" title="补码加减法的公式"></a>补码加减法的公式</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906142949477.png" class="" title="image-20230906142949477"><p>即补码表示的两个数在进行加法运算时，可以把符号位与数值位同等处理，只要结果不超出机器能表示的数值范围，运算后的结果按2^n+1取模（对于整数）或按2取模（对于小数），就能得到本次加法的运算结果。</p><p>若机器数采用补码，当求A-B时，只需先求[-B]补（称[-B]补为“求补”后的减数)，就可按补码加法规则进行运算。而[-B]补由[B]补连同符号位在内，每位取反，末位加1而得。</p><h6 id="溢出判定"><a href="#溢出判定" class="headerlink" title="溢出判定"></a>溢出判定</h6><ul><li>一位符号位判溢出</li></ul><p>参加操作的 两个数（减法时即为被减数和“求补” 以后的减数）符号相同，其结果的符号与原操作 数的符号不同，即为溢出</p><ul><li>两位符号位判溢出</li></ul><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906144809676.png" class="" title="image-20230906144809676"><h6 id="补码加减法的硬件配置"><a href="#补码加减法的硬件配置" class="headerlink" title="补码加减法的硬件配置"></a>补码加减法的硬件配置</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906144900824.png" class="" title="image-20230906144900824"><p>图中寄存器A、X、加法器的位数相等，其中A存效被加数（或被减数）的补码，X存放加数(或减数)的补码。当作减法时，由“求补控制逻辑”将X送至加法器，并使加法器的最末位外来进位为1，以达到对减数求补的目的。运算结果溢出时，通过溢出判断电路置“1”溢出标记V。G为加法标记，Gs为减法标记。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230906145455941.png" class="" title="image-20230906145455941"><h4 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h4><p>在计算机中，乘法运算是一种很重要的运算，有的机器由硬件乘法器直接完成乘法运算，有的机器内没有乘法器，但可以按机器作乘法运算的方法，用软件编程实现。因此，学习乘法运算方法不仅有助于乘法器的设计，也有助于乘法编程。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907132124668.png" class="" title="image-20230907132124668"><p>可见，这里包含着被乘数A的多次左移，以及4个位积的相加运算。<br>若计算机完全模仿笔算乘法步骤，将会有两大困难：其一，将4个位积一次相加，机器难以实现；其二，乘积位数增长了一倍，这将造成器材的浪费和运算时间的增加。为此，对笔算乘法进行改进。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907132311831.png" class="" title="image-20230907132311831"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907133118854.png" class="" title="image-20230907133118854"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907133319912.png" class="" title="image-20230907133319912"><p>上述运算过程可归纳如下：</p><ul><li>乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。</li><li>由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，由次低位作新的末位，空出最高位放部分积的最低位。</li><li>每次做加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置。计算机很容易实现这种运算规则。用一个寄存器存放被乘数，一个寄存器存放乘积的高位，另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。</li></ul><h6 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h6><p>由于原码表示与真值极为相似，只差一个符号，而乘积的符号又可通过两数符号的逻辑异或求得，因此，上述讨论的结果可以直接用于原码一位乘，只需加上符号位处理即可。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907134154514.png" class="" title="image-20230907134154514"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907134437551.png" class="" title="image-20230907134437551"><h6 id="原码一位乘所需的硬件配置"><a href="#原码一位乘所需的硬件配置" class="headerlink" title="原码一位乘所需的硬件配置"></a>原码一位乘所需的硬件配置</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907134722507.png" class="" title="image-20230907134722507"><p>图中A、X、Q均为+1位的寄存器，其中X存放被乘数的原码，Q存放乘数的原码。移位和加控制电路受末位乘数Q。的控制（当Q.&#x3D;1时，A和X内容相加后，A、Q右移一位；当Q&#x3D;0时，只作A、Q右移一位的操作)。计数器C用于控制逐位相乘的次数。S存放乘积的符号。G为乘法标记。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907134924199.png" class="" title="image-20230907134924199"><h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907175018650.png" class="" title="image-20230907175018650"> 其特点可归纳如下：<ul><li>每次上商都是由心算来比较余数（被除数)和除数的大小，确定商为“1”还是“0”。</li><li>每做一次减法，总是保持余数不动，低位补0，再减去右移后的除数。</li><li>上商的位置不固定。</li><li>商符单独处理。</li></ul><p>如果将上述规则完全照搬到计算机内，实现起来有一定困难，主要问题如下：</p><ul><li>机器不能“心算”上商，必须通过比较被除数（或余数）和除数绝对值的大小来确定商值，即|x|-|y|,若差为正（够减）上商1，差为负（不够减）上商0。</li><li>按照每次减法总是保持余数不动低位补0，再减去右移后的除数这一规则，则要求加法器的位数必须为除数的两倍。仔细分析发现，右移除数可以用左移余数的方法代替，其运算结果是一样的，但对线路结构更有利。不过此刻所得到的余数不是真正的余数，只有将它乘上2“才是真正的余数。</li><li>笔算求商时是从高位向低位逐位求的，而要求机器把每位商直接写到寄存器的不同位置也是不可取的。计算机可将每一位商直接写到寄存器的最低位，并把原来的部分商左移一位，这样更有利于硬件实现。综上所述便可得原码除法运算规则。</li></ul><h5 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h5><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907180627287.png" class="" title="image-20230907180627287"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907180807171.png" class="" title="image-20230907180807171"><h6 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h6><p>恢复余数法的特点是：当余数为负时，需加上除数，将其恢复成原来的余数。</p><p>由上所述，商值的确定是通过比较被除数和除数的绝对值大小，即**[x*]补—[y*]<strong>补实现的，而计算机内只设加法器，故需将</strong>[x*]补—[y*]补** 操作变为**[x*]补+[一y*]**补的操作。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907181417188.png" class="" title="image-20230907181417188"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907181435758.png" class="" title="image-20230907181435758"><h6 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907190034295.png" class="" title="image-20230907190034295"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907190114504.png" class="" title="image-20230907190114504"><ul><li>上商n+1次</li><li>第一次上商判溢出</li><li>移n次，加n+1次</li><li>用移位的次数判断除法是否结束</li></ul><h6 id="原码加减交替法所需的硬件配置"><a href="#原码加减交替法所需的硬件配置" class="headerlink" title="原码加减交替法所需的硬件配置"></a>原码加减交替法所需的硬件配置</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907190801544.png" class="" title="image-20230907190801544"><p>除法开始前，Q寄存器被清零，准备接收商，被除数的原码放在A中，除数的原码放在X中，计数器C中存放除数的位数。除法开始后，首先通过异或运算求出商符，并存于S。接着将被除数和除数变为绝对值，然后开始用第一次上商判断是否溢出。若溢出，则置溢出标记V为1，停止运算，进行中断处理，重新选择比例因子；若无溢出，则先上商，接着A、Q同时左移一位，然后再根据上一次商值的状态，决定是如还是减除数，这样重复次后，再上最后一次商（共上商n+1次)，即得运算结果。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907190927432.png" class="" title="image-20230907190927432"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907191002919.png" class="" title="image-20230907191002919"><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>机器中任何一个浮点数都可写成</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230908160307301.png" class="" title="image-20230908160307301"><p>的形式。其中，S,为浮点数的尾数，一般为绝对值小于1的规格化数（补码表示时允许为-1），机器中可用原码或补码表示：，为浮点数的阶码，一般为整数，机器中大多用补码或移码表示；”为浮点数的基数，常用2、4、8或16表示。以下以基数为2进行讨论。</p><h5 id="浮点加减法运算"><a href="#浮点加减法运算" class="headerlink" title="浮点加减法运算"></a>浮点加减法运算</h5><p>设两个浮点数</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230908160404208.png" class="" title="image-20230908160404208"><p>由于浮点数尾数的小数点均固定在第一数值位前，所以尾数的加减运算规则与定点数的完全相同。但由于其阶码的大小又直接反映尾数有效值小数点的实际位置，因此当两浮点数阶码不等时，因两尾数小数点的实际位置不一样，尾数部分无法直接进行加减运算。为此，浮点数加减运算必须按以下几步进行。</p><ul><li>对阶，使两数的小数点位置对齐。</li><li>尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。</li><li>规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。</li><li>舍入，为提高精度，要考虑尾数右移时丢失的数值位。</li><li>溢出判断，即判断结果是否溢出。</li></ul><h6 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h6><p>对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。为此；首先要求出阶差，再按小阶向大阶看齐的原则，使阶小的尾数向右移位，每右移一位，阶码加1，直到两数的阶码相等为止。右移的次数正好等于阶差。尾数右移时可能会发生数码丢失，影响精度。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907192128330.png" class="" title="image-20230907192128330"><h6 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h6><p>将对阶后的两个尾数按定点加（减）运算规则进行运算。</p><h6 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907192712579.png" class="" title="image-20230907192712579"><h6 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h6><p>在对阶和右规过程中，可能出现尾数末位丢失引起误差，需考虑舍入</p><ul><li>0舍1入法</li><li>横置“1”法</li></ul><h6 id="判断溢出"><a href="#判断溢出" class="headerlink" title="判断溢出"></a>判断溢出</h6><p>与定点加减法一样，浮点加减运算最后一步也需判断滋出。在浮点规格化中已指出，当尾数之和（差）出现01.××·×或10.××…×时，并不表示溢出，只有将此数右规后，再根据阶码来判断浮点运算结果是否溢出。若机器数为补码，尾数为规格化形式，并假设阶符取2位，阶码的数值部分取7位，数符取2位，尾数的数值部分取n位，则它们能表示的补码在数轴上的表示范围如图6.14所示。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907193049182.png" class="" title="image-20230907193049182"><h5 id="浮点乘除运算"><a href="#浮点乘除运算" class="headerlink" title="浮点乘除运算"></a>浮点乘除运算</h5><p>两个浮点数相乘，乘积的阶码应为相乘两数的阶码之和，乘积的尾数应为相乘两数的尾数之积。两个浮点数相除，商的阶码为被除数的阶码减去除数的阶码，尾数为被除数的尾数除以除数的尾数所得的商，可用下式描述。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907193337603.png" class="" title="image-20230907193337603"><h3 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h3><p>针对每一种算术运算，都必须有一个相对应的基本硬件配置，其核心部件是加法器和寄存器。当需要完成逻辑运箅时，势必需要配置相应的逻辑电路，而ALU电路是既能完成算术运算又能完成逻辑运算的部件。</p><h5 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h5><p>图ALU框图。图中Ai和Bi为输入变量；ki为控制信号，ki的不同取值可决定该电路作哪一种算术运算或哪一种逻辑运算；Fi是输出函数。<img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907193543006.png" class="" title="image-20230907193543006"></p><h5 id="快速进位链"><a href="#快速进位链" class="headerlink" title="快速进位链"></a>快速进位链</h5><p>随着操作数位数的增加，电路中进位的速度对运算时间的影响也越来越大，为了提高运算速度，本节将通过对进位过程的分析设计快速进位链。</p><h6 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h6><p>并行加法器由若千个全加器组成，如图所示。n+1个全加器级联就组成了一个n+1位的并行加法器。</p><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907194049974.png" class="" title="image-20230907194049974"><h6 id="串行进位链"><a href="#串行进位链" class="headerlink" title="串行进位链"></a>串行进位链</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907194223481.png" class="" title="image-20230907194223481"><h6 id="并行进位链"><a href="#并行进位链" class="headerlink" title="并行进位链"></a>并行进位链</h6><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907194421536.png" class="" title="image-20230907194421536"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907194504727.png" class="" title="image-20230907194504727"><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%94/image-20230907194525634.png" class="" title="image-20230907194525634">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入输出系统（四）</title>
    <link href="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/"/>
    <url>/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>除了CPU和存储器两大模块外，计算机硬件系统的第三个关键部分是输入输出模块，又称输入输出系统。随着计算机系统的不断发展，应用范围的不断扩大，I&#x2F;O设备的数量和种类也越来越多，它们与主机的联络方式及信息的交换方式也各不相同。</p><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h4><p>输入输出系统的发展大致可分为4个阶段。</p><p>1、早期</p><p>早期的I&#x2F;O设备种类较少，I&#x2F;O设备与主存交换信息都必须通过CPU</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165053240.png" class="" title="image-20230919165053240"><p>这种交换方式延续了相当长的时间。当时的&#x2F;O设备具有以下几个特点：</p><ul><li>每个I&#x2F;0设备都必须配有一套独立的逻辑电路与CPU相连，用来实现I&#x2F;0设备与主机之<br>间的信息交换，因此线路十分散乱、庞杂。</li><li>输入输出过程是穿插在CPU执行程序过程之中进行的，当I&#x2F;O设备与主机交换信息时，<br>CPU不得不停止各种运算，因此，&#x2F;O设备与CPU是按串行方式工作的，极浪费时间。</li><li>每个I&#x2F;O设备的逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，它们彼<br>此依赖，相互牵连，因此，欲增添、撤减或更换&#x2F;0设备是非常困难的。</li></ul><p>2、接口模块和DMA阶段</p><p>这个阶段&#x2F;O设备通过接口模块与主机连接，计算机系统采用了总线结构</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165303547.png" class="" title="image-20230919165303547"><p>通常，在接口中都设有数据通路和控制通路。数据经过接口既起到缓冲作用，又可完成串一并变换。控制通路用以传送CPU向I&#x2F;O设备发出的各种控制命令，或使CPU接受来自I&#x2F;O设备的反馈信号。许多接口还能满足中断请求处理的要求，使I&#x2F;O设备与CPU可按并行方式工作，大大地提高了CPU的工作效率。采用接口技术还可以使多台I&#x2F;O设备分时占用总线，使多台I&#x2F;0设备互相之间也可实现并行工作方式，有利于整机工作效率的提高。虽然这个阶段实现了CPU和I&#x2F;O设备并行工作，但是在主机与I&#x2F;O设备交换信息时，CPU要中断现行程序，即CPU与I&#x2F;0设备还不能做到绝对的并行工作。为了进一步提高CPU的工作效率，又出现了直接存储器存取(Direct Memory Access,DMA)技术，其特点是I&#x2F;O设备与主存之间有一条直接数据通路，I&#x2F;O设备可以与主存直接交换信息，使CPU在I&#x2F;O设备与主存交换信息时能继续完成自身的工作，故资源利用率得到了进一步提高。</p><p>3、具有通道结构的阶段</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165518859.png" class="" title="image-20230919165518859"><p>在小型和微型计算机中，采用DMA方式可实现高速I&#x2F;O设备与主机之间成组数据的交换，但在大中型计算机中，I&#x2F;O设备配置繁多，数据传送频繁，若仍采用DMA方式会出现一系列问题。</p><ul><li>如果每台1&#x2F;0设备都配置专用的DMA接口，不仅增加了硬件成本，而且为了解决众多DMA接口同时访问主存的冲突问题，会使控制变得十分复杂。</li><li>CPU需要对众多的DMA接口进行管理，同样会占用CPU的工作时间，而且因频繁地进入周期挪用阶段，也会直接影响CPU的整体工作效率</li></ul><p>因此在大中型计算机系统中，采用&#x2F;0通道的方式来进行数据交换。</p><p>通道是用来负责管理I&#x2F;O设备以及实现主存与I&#x2F;O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器。通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，但不是一个完全独立的处理器。它依据CPU的&#x2F;0指令进行启动、停业或改变工作状态，是从属于CPU的一个专用处理器。依赖通道管理的I&#x2F;O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。</p><p>4、具有I&#x2F;O处理机的阶段</p><p>输入输出系统发展到第四阶段，出现了I&#x2F;O处理机。L&#x2F;O处理机又称为外围处理机(Pr-ipheral Processor),它基本独立于主机工作，既可完成&#x2F;O通道要完成的&#x2F;0控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。具有&#x2F;0处理机的输入输出系统与CPU工作的并行性更高，这说明&#x2F;O系统对主机来说具有更大的独立性。</p><h4 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h4><h5 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I&#x2F;O软件"></a>I&#x2F;O软件</h5><p>I&#x2F;O指令是机器指令的一类I&#x2F;O指令的一般格式：</p><table><thead><tr><th>操作码</th><th>命令码</th><th>设备码</th></tr></thead></table><p>通道指令</p><p>通道指令是对具有通道的I&#x2F;O系统专门设置的指令，这类指令一般用以指明参与传送（写人或读取)的数据组在<strong>主存中的首地址</strong>；指明需要传送的字节数或所传送数据组的<strong>末地址</strong>；指明所选设备的设备码及完成某种操作的<strong>命令码</strong>。这类指令的位数一般较长，如BM370机的通道指令为64位。</p><h5 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I&#x2F;O硬件"></a>I&#x2F;O硬件</h5><p>设备I&#x2F;O接口</p><p>设备设备控制器通道</p><h4 id="I-O设备与主机的联系方式"><a href="#I-O设备与主机的联系方式" class="headerlink" title="I&#x2F;O设备与主机的联系方式"></a>I&#x2F;O设备与主机的联系方式</h4><h6 id="I-O设备编制方式"><a href="#I-O设备编制方式" class="headerlink" title="I&#x2F;O设备编制方式"></a>I&#x2F;O设备编制方式</h6><p>通常将I&#x2F;O设备码看做地址码，对I&#x2F;O地址码的编址可采用两种方式：</p><ul><li>统一编址</li></ul><p>统一编址就是将&#x2F;0地址看做是存储器地址的例如，在64K地址的存储空间中，划出8K地址作为I&#x2F;O设备的地址，凡是在这8K地址范围内的访问，就是对I&#x2F;O设备的访问，所用的指令与访存指令相似。</p><ul><li>不统一编址</li></ul><p>不统一编址就是指I&#x2F;O地址和存储器地址是分开的，所有对&#x2F;IO设备的访问必须有专用的I&#x2F;0指令。显然统一编址占用了存储空间，减少了主存容量，但无须专用的I&#x2F;O指令。不统一编址由于不占用主存空间，故不影响主存容量，但需设I&#x2F;O专用指令。因此，设计机器时，需根据实际情况权衡考虑选取何种编址方式。</p><h6 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h6><p>由于每台设备都赋予一个设备号，因此，当要启动某一设备时，可由I&#x2F;O指令的设备码字段直接指出该设备的设备号。通过接口电路中的设备选择电路，便可选中要交换信息的设备。</p><h6 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h6><ul><li>并行</li><li>串行</li></ul><h6 id="联络方式"><a href="#联络方式" class="headerlink" title="联络方式"></a>联络方式</h6><ul><li>立即响应</li></ul><p>对于一些工作速度十分缓馒的I&#x2F;O设备，如指示灯的亮与灭、开关的通与断、A&#x2F;D转换器缓变信号的输入等，当它们与CPU发生联系时，通常都已使其处于某种等待状态，因此，只要CPU的I&#x2F;0指令一到，它们便立即响应，故这种设备无须特殊联络信号，称为立即响应方式。</p><ul><li>异步工作采用应答信号联络</li></ul><p>当I&#x2F;O设备与主机工作速度不匹配时，通常采用异步工作方式。这种方式在交换信息前，I&#x2F;O设备与CPU各自完成自身的任务，一旦出现联络信号，彼此才准备交换信息。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920133546602.png" class="" title="image-20230920133546602"><ul><li>同步工作采用同步时标联络</li></ul><p>同步工作要求I&#x2F;O设备与CPU的工作速度完全同步。例如，在数据采集过程中，若外部数据以2400bPs的速率传送至接口，则CPU也必须以1&#x2F;2400s的速率接收每一位数。这种联络互相之间还得配有专用电路，用以产生同步时标来控制同步工作。</p><h6 id="I-O设备与主机的连接方式"><a href="#I-O设备与主机的连接方式" class="headerlink" title="I&#x2F;O设备与主机的连接方式"></a>I&#x2F;O设备与主机的连接方式</h6><ul><li>辐射式</li></ul><p>每台设备都配有一套控制线路和一组信号线,不便于增删设备</p><ul><li>总线式</li></ul><p>便于增删设备</p><h4 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I&#x2F;O设备与主机信息传送的控制方式"></a>I&#x2F;O设备与主机信息传送的控制方式</h4><p>I&#x2F;0设备与主机交换信息时，共有5种控制方式：程序查询方式、程序中断方式、直接存储器存取方式(DMA)、I&#x2F;0通道方式、I&#x2F;0处理机方式。</p><h6 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h6><p>程序查询方式是由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。采用这种方式实现主机和I&#x2F;O设备交换信息，要求I&#x2F;O接口内设置一个能反映I&#x2F;O设备是否准备就绪的状态标记，CPU通过对此标记的检测，可得知I&#x2F;O设备的准备情况。</p><p>当现行程序需启动某I&#x2F;O设备工作时，即将此程序流程插入到运行的程序中。由图中可知，CPU启动I&#x2F;O设备后便开始对I&#x2F;O设备的状态进行查询。若查得I&#x2F;O设备未准备就绪，就继续查询；若查得I&#x2F;O设备准备就绪，就将数据从I&#x2F;O接口送至CPU,再由CPU送至主存。这样一个字一个字地传送，直至这个数据块的数据全部传送结束，CPU又重新回到原现行程序。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134310369.png" class="" title="image-20230920134310369"><p>由这个查询过程可见，只要一启动I&#x2F;O设备，CPU便不断查询I&#x2F;O设备的准备情况，从而终止了原程序的执行。CPU在反复查询过程中，犹如就地“踏步”。另一方面，I&#x2F;O设备准备就绪后，CPU要一个字一个字地从I&#x2F;O设备取出，经CPU送至主存，此刻CPU也不能执行原程序，可见这种方式使CPU和I&#x2F;O设备处于串行工作状态，CPU的工作效率不高。</p><h6 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h6><p>徜若CPU在启动I&#x2F;O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I&#x2F;O设备推备就绪并向CPU发出中断请求后才予以响应，这将大大提高CPU的工作效率。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134745159.png" class="" title="image-20230920134745159"><p>由图中可见，CPU启动I&#x2F;O设备后仍继续执行原程序，在第K条指令执行结束后，CPU响应了I&#x2F;O设备的请求，中断了现行程序，转至中断服务程序，待处理完后又返回到原程序断点处，继续从第K+1条指令往下执行。由于这种方式使原程序中断了运行，故称为程序中断方式。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134903603.png" class="" title="image-20230920134903603"><h6 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h6><p>虽然程序中断方式消除了程序查询方式的“踏步”现象，提高了CPU资源的利用率，但是CPU在响应中断请求后，必须停止现行程序而转入中断服务程序，并且为了完成I&#x2F;O设备与主存交换信息，还不得不占用CPU内部的一些寄存器，这同样是对CPU资源的消耗。如果I&#x2F;O设备能直接与主存交换信息而不占用CPU,那么，CPU的资源利用率显然又可进一步提高，这就出现了直接存储器存取(DMA)的方式。</p><p>在DMA方式中，主存与&#x2F;O设备之间有一条数据通路，主存与I&#x2F;0设备交换信息时，无须调用中断服务程序。若出现DMA和CPU同时访问主存，CPU总是将总线占有权让给DMA,通常把DMA的这种占有称为窃取或挪用。窃取的时间一般为一个存取周期，故又把DMA占用的存取周期窃取周期或挪用周期。而且，在DMA窃取存取周期时，CPU尚能继续作内部操作（如乘法运算）。可见，与程序查询和程序中断方式相比，DMA方式进一步提高了CPU的资源利用率。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920135237074.png" class="" title="image-20230920135237074"><h6 id="三种方式的-CPU-工作效率比较"><a href="#三种方式的-CPU-工作效率比较" class="headerlink" title="三种方式的 CPU 工作效率比较"></a>三种方式的 CPU 工作效率比较</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920135309902.png" class="" title="image-20230920135309902"><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>中央处理器和主存构成了主机，除主机外的大部分硬件设备都可称为&#x2F;0设备或外部设备，或外围设备，简称外设,I&#x2F;O设备的组成通常可用图画线框内的结构来描述。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920185042630.png" class="" title="image-20230920185042630"><p>I&#x2F;O设备大致可分为三类:</p><ul><li>人机交互设备键盘、鼠标、打印机、显示器</li><li>计算机信息存储设备磁盘、光盘、磁带</li><li>机—-机通信设备调制解调器等</li></ul><h6 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h6><ul><li>键盘</li></ul><ol><li>按下一个键。</li><li>查出按下的是哪个键。</li><li>将此键翻译成ASCII码,由计算机接收。</li></ol><ul><li>鼠标</li><li>触摸屏</li></ul><h6 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h6><ul><li>显示器</li></ul><ol><li>字符显示——字符发生器</li><li>图形显示——主观图像</li><li>图像显示——客观图像</li></ol><ul><li>打印机</li></ul><ol><li>击打式点——阵式（逐字、逐行）</li><li>非击打式——激光（逐页）喷墨（逐字）</li></ol><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ul><li>A&#x2F;D、D&#x2F;A模拟&#x2F;数字（数字模拟）转换器</li><li>终端 由键盘和显示器组成完成显示控制与存储、键盘管理及通信控制</li><li>汉字处理汉字输入、汉字存储、汉字输出</li></ul><h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>接口可以看做是两个系统或两个部件之间的交接部分，它既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界I&#x2F;O接口通常是指主机与I&#x2F;O设备之间设置的一个硬件电路及其相应的软件控制。不同的I&#x2F;O设备都有其相应的设备控制器，而它们往往都是通过I&#x2F;O接口与主机取得联系的。主机与i?o设备之间设置接口的理由如下：</p><ul><li>一台机器通常配有多台I&#x2F;O设备，它们各自有其设备号（地址），通过接口可实现I&#x2F;O设备的选择。</li><li>I&#x2F;O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲，达到速度匹配。</li><li>有些I&#x2F;O设备可能串行传送数据，而CPU一般为并行传送，通过接口可实现数据串~并格式的转换。</li><li>I&#x2F;O设备的输人输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换。</li><li>CPU启动I&#x2F;O设备工作，要向I&#x2F;O设备发各种控制信号，通过接口可传送控制命令。</li><li>I&#x2F;O设备需将其工作状态（如“忙”、“就绪”、“错误”、“中断请求”等）及时向CPU报告</li></ul><p>通过接口可监视设备的工作状态，并可保存状态信息，供CPU查询。值得注意的是，接口(Interface)和端口(Port)是两个不同的概念。端口是指接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑才能组成接口。CPU通过输人指令，从端口读人信息，通过输出指令，可将信息写人到端口中。</p><h4 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h4><h5 id="按总线的连接方式的I-O接口方式"><a href="#按总线的连接方式的I-O接口方式" class="headerlink" title="按总线的连接方式的I&#x2F;O接口方式"></a>按总线的连接方式的I&#x2F;O接口方式</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921133011814.png" class="" title="image-20230921133011814"><ul><li>数据线</li></ul><p>数据线是I&#x2F;O设备与主机之间数据代码的传送线，其根数一般等于存储字长的位数或字符的位数，它通常是双向的，也可以是单向的。若采用单向数据总线，则必须用两组才能实现数据的输人和输出功能，而双向数据总线只需一组即可。</p><ul><li>设备选择线</li></ul><p>设备选择线是用来传送设备码的，它的根数取决于I&#x2F;O指令中设备码的位数。如果把设备码看做是地址号，那么设备选择线又可称为地址线。设备选择线可以有一组，也可以有两组，其中一组用于主机向I&#x2F;O设备发送设备码，另一组用于I&#x2F;O设备向主机回送设备码。当然设备选择线也可采用一组双向总线代替两组单向总线。</p><ul><li>命令线</li></ul><p>命令线主要用以传输CPU向设备发出的各种命令信号，如启动、清除、屏蔽、读、写等。它是一组单向总线，其根数与命令信号多少有关。</p><ul><li>状态线</li></ul><p>状态线是将I&#x2F;O设备的状态向主机报告的信号线，例如，设备是否准备就绪，是否向CPU.发出中断请求等。它也是一组单向总线。</p><h5 id="接口的的功能和组成"><a href="#接口的的功能和组成" class="headerlink" title="接口的的功能和组成"></a>接口的的功能和组成</h5><ul><li>选址功能</li></ul><p>由于I&#x2F;O总线与所有设备的接口电路相连，但CPU究竟选择哪台设备，还得通过设备选择线上的设备码来确定。该设备码将送至所有设备的接口，因此，要求每个接口都必须具有选址功能，即当设备选择线上的设备码与本设备码相符时，应发出设备选中信号SEL,这种功能可通过接口内的设备选择电路来实现。</p><ul><li>传送命令的功能</li></ul><p>当CPU向I&#x2F;0设备发出命令时，要求I&#x2F;O设备能做出响应，如果I&#x2F;O接口不具备传送命令信息的功能，那么设备将无法响应，故通常在I&#x2F;O接口中设有存放命令的命令寄存器以及命令译码器</p><ul><li>传送数据的功能</li></ul><p>既然接口处于主机与I&#x2F;O设备之间，因此数据必须通过接口才能实现主机与I&#x2F;O设备之间的传送。这就要求接口中具有数据通路，完成数据传送。这种数据通路还应具有缓冲能力，即能将数据暂存在接口内。接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR),它用来暂存I&#x2F;O设备与主机准备交换的信息，与I&#x2F;O总线中的数据线是相连的。</p><ul><li>反映设备状态的功能</li></ul><p>为了使CPU能及时了解各I&#x2F;O设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。例如，用完成触发器D和工作触发器B来标志设备所处的状态。</p><ol><li>当D&#x3D;0,B&#x3D;0时，表示I&#x2F;O设备处于暂停状态。</li><li>当D&#x3D;1,B&#x3D;0时，表示I&#x2F;O设备已经准备就绪。</li><li>当D&#x3D;0,B&#x3D;1时，表示I&#x2F;O设备正处于准备状态。</li></ol><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921134020211.png" class="" title="image-20230921134020211"><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><ol><li>按数据传送方式分类</li></ol><ul><li>并行接口Intel 8255</li><li>串行接口Intel 8251</li></ul><p>​2.按功能选择的灵活性分类</p><ul><li>可编程接口Intel8255、Intel 8251</li><li>不可编程接口Intel8212</li></ul><p>​3.按通用性分类</p><ul><li>通用接口Intel8255、Intel 8251</li><li>专用接口Intel8279、Intel 8275</li></ul><p>​4.按数据传送的控制方式分类</p><ul><li>中断接口Intel 8259</li><li>DMA接口Intel 8257</li></ul><h3 id="程序查询方式-1"><a href="#程序查询方式-1" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921135908938.png" class="" title="image-20230921135908938"><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921135932696.png" class="" title="image-20230921135932696"><p>当I&#x2F;O设备较多时，CPU需按各个I&#x2F;O设备在系统中的优先级别进行遂级查询，其流程图所示。图中设备的优先顺序按1至N降序排列。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921175143457.png" class="" title="image-20230921175143457"><ol><li>由于这种方式传送数据时要占用CPU中的寄存器，故首先需将寄存器原内容保护起来(若该寄存器中存有用信息)。</li><li>由于传送往往是一批数据，因此需先设置I&#x2F;O设备与主机交换数据的计数值。</li><li>设置欲传送数据在主存缓冲区的首地址。</li><li>CPU启动I&#x2F;O设备。</li><li>将I&#x2F;O接口中的设备状态标志取至CPU并测试I&#x2F;O设备是否准备就绪。如果未准备就绪，则等待，直到准备就绪为止。当准备就绪时，接着可实现传送。对输入而言，准备就绪意味着接口电路中的数据缓冲寄存器已装满欲传送的数据，称为输入缓冲满，CPU即可取走数据；对输出而言，准备就绪意味着接口电路中的数据已被设备取走，故称为输出缓冲空，这样CPU可再次将数据送到接口，设备可再次从接口接收数据。</li><li>CPU执行I&#x2F;O指令，或从I&#x2F;O接口的数据缓冲寄存器中读出一个数据，或把一个数据写入I&#x2F;O接口中的数据缓冲寄存器内，同时将接口中的状态标志复位。</li><li>修改主存地址。</li><li>修改计数值，若原设置计数值为原码，则依次减1；若原设置计数值为负数的补码，则依次加1（有关原码、补码的）。</li><li>判断计数值。若计数值不为0，表示一批数据尚未传送完，重新启动外设继续传送；若计数值为0，则表示一批数据已传送完毕。</li><li>结束I&#x2F;O传送，继续执行现行程序。</li></ol><h4 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h4><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921175621004.png" class="" title="image-20230921175621004"><p>图中设备选择电路用以识别本设备地址，当地址线上的设备号与本设备号相符时，SEL有效，可以接收命令；数据缓冲寄存器用于存放欲传送的数据；D是完成触发器，B是工作触发器。以输入设备为例，该接口的工作过程如下：</p><ol><li>当CPU通过1&#x2F;O指令启动输人设备时，指令的设备码字段通过地址线送至设备选择电路。</li><li>若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</li><li>I&#x2F;O指令的启动命令经过“与非”门将工作触发器B置“1”，将完成触发器D置“0”。</li><li>由B触发器启动设备工作。</li><li>输人设备将数据送至数据缓冲寄存器。</li><li>由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。</li><li>D触发器以“准备就绪”状态通知CPU,表示“数据缓冲满”。</li><li>CPU执行输人指令，将数据缓冲寄存器中的数据送至CPU的通用寄存器，再存人主存相关单元。</li></ol><h3 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p>计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断”。中断是现代计算机能有效合理地发挥效能和提高效率的一个十分重要的功能。通常又把实现这种功能所需的软硬件技术统称为中断技术。</p><h4 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I&#x2F;O中断的产生"></a>I&#x2F;O中断的产生</h4><p>在I&#x2F;O设备与主机交换信息时，由于设备本身机电特性的影响，其工作速度较低，与CPU无法匹配，因此，CPU启动设备后，往往需要等待一段时间才能实现主机与I&#x2F;O设备之间的信息交换。如果在设备准备的同时，CPU不作无谓的等待，而继续执行现行程序，只有当I&#x2F;O设备准备就绪向CPU提出请求后，再暂时中断CPU现行程序转人I&#x2F;O服务程序，这便产生了I&#x2F;O中断。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921185718159.png" class="" title="image-20230921185718159"><h4 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h4><h5 id="中断请求触发器和中断屏蔽触发器"><a href="#中断请求触发器和中断屏蔽触发器" class="headerlink" title="中断请求触发器和中断屏蔽触发器"></a>中断请求触发器和中断屏蔽触发器</h5><p>每台外部设备都必须配置一个中断请求触发器INTR,当其为“1”时，表示该设备向CPU提出中断请求。但是设备欲提出中断请求时，其设备本身必须准备就绪，即接口内的完成触发器D的状态必须为“1”。</p><p>由于计算机应用的范围越来越广泛，向CPU提出中断请求的原因也越来越多，除了各种I&#x2F;O设备外，还有其他许多突发性事件都是引起中断的因素，为此，把凡能向CPU提出中断请求的各种因素统称为中断源。当多个中断源向CPU提出中断请求时，CPU必须坚持一个原则，即在任何瞬间只能接受一个中断源的请求。所以，当多个中断源同时提出请求时，CPU必须对各中断源的请求进行排队，且只能接受级别最高的中断源的请求，不允许级别低的中断源中断正在运行的中断服务程序。这样，在I&#x2F;O接口中需设置一个屏蔽触发器MASK,当其为“1”时，表示被屏的中断服务程序。这样，在I&#x2F;O接口中需设置一个屏蔽触发器MASK,当其为“1”时，表示被屏蔽，即封锁其中断源的请求。可见中断请求触发器和中断屏蔽触发器在I&#x2F;O接口中是成对出现的。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211335034.png" class="" title="image-20230921211335034"><h5 id="排队器"><a href="#排队器" class="headerlink" title="排队器"></a>排队器</h5><p>如上所述，当多个中断源同时向CPU提出请求时，CPU只能按中断源的不同性质对其排队，给予不同等级的优先权，并按优先等级的高低予以响应。就I&#x2F;O中断而言，速度越高的I&#x2F;O设备，优先级越高</p><p>图下面的一排门电路是链式排队器的核心。每个接口中有一个反相器和一个“与非”门（如图中点画线框内所示），它们之间犹如链条一样串接在一起，故称为链式排队器。该电路中级别最高的中断源是1号，其次是2号、3号、4号。不论是哪个中断源（一个或多个）提出中断请求，排队器输出端INTP只有一个高电平。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211632244.png" class="" title="image-20230921211632244"><h5 id="中断向量地址形成部件（设备编码器）"><a href="#中断向量地址形成部件（设备编码器）" class="headerlink" title="中断向量地址形成部件（设备编码器）"></a>中断向量地址形成部件（设备编码器）</h5><p>CPU一且响应了&#x2F;0中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同的设备有不同的中断服务程序，每个服务程序都有一个人口地址，CPU必须找到这个入口地址。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211847534.png" class="" title="image-20230921211847534"><h4 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I&#x2F;O中断处理过程"></a>I&#x2F;O中断处理过程</h4><h5 id="CPU响应中断的条件和时间"><a href="#CPU响应中断的条件和时间" class="headerlink" title="CPU响应中断的条件和时间"></a>CPU响应中断的条件和时间</h5><p>CPU响应I&#x2F;O设备提出中断请求的条件是必须满足CPU中的允许中断触发器EINT为“1”。该触发器可用开中断指令置位（称为开中断）：也可用关中断指令或硬件自动使其复位（称为关中断)。</p><p>I&#x2F;O设备准备就绪的时间（即D&#x3D;1)是随机的，而CPU是在统一的时刻(每条指令执行阶段结束前)向接口发中断查询信号，以获取&#x2F;0的中断请求。因此，CPU响应中断的时间一定是在每条指令执行阶段的结束时刻。</p><h5 id="I-O处理中断的过程"><a href="#I-O处理中断的过程" class="headerlink" title="I&#x2F;O处理中断的过程"></a>I&#x2F;O处理中断的过程</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921214815629.png" class="" title="image-20230921214815629"><p>下面以输人设备为例，结合图，说明I&#x2F;O中断处理的全过程。当CPU通过I&#x2F;O指令的地址码选中某设备后，则</p><ol><li>由CPU发启动I&#x2F;O设备命令，将接口中的B置“1”，D置“0”。</li><li>接口启动输入设备开始工作。</li><li>输人设备将数据送人数据缓冲寄存器。</li><li>输人设备向接口发出“设备工作结束”信号，将D置“1”，B置“0”，标志设备准备就绪。</li><li>当设备准备就绪(D&#x3D;1),且本设备未被屏蔽(MASK&#x3D;0)时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。</li><li>设备中断请求触发器INTR被置“1”，标志设备向CPU提出中断请求。与此同时，INTR送至排队器，进行中断判优。</li><li>若CPU允许中断(EINT&#x3D;1),设备又被排队选中，即进入中断响应阶段，由中断响应信号NTA将排队器输出送至编码器形成向量地址。</li><li>向量地址送至PC，作为下一条指令的地址。</li><li>由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进人中断服务阶段，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。</li><li>中断服务程序的最后一条指令是中断返回指令，当其执行结束时，即中断返回至原程序的断点处。</li></ol><h4 id="中断服务程序流程"><a href="#中断服务程序流程" class="headerlink" title="中断服务程序流程"></a>中断服务程序流程</h4><h5 id="中断服务的流程"><a href="#中断服务的流程" class="headerlink" title="中断服务的流程"></a>中断服务的流程</h5><p>不同设备的服务程序是不相同的，可它们的程序流程又是类似的，一般中断服务程序的流程分四大部分：保护现场、中断服务、恢复现场和中断返回。</p><ul><li>保护现场</li></ul><p>保护现场有两个含义，其一是保存程序的断点；其二是保存通用寄存器和状态寄存器的内容。前者由中断隐指令完成，后者由中断服务程序完成。具体而言，可在中断服务程序的起始部分安排若干条存数指令，将寄存器的内容存至存储器中保存，或用进栈指令(PUSH)将各寄存器的内容推入堆栈保存，即将程序中断时的“现场”保存起来。</p><ul><li>中断服务</li></ul><p>这是中断服务程序的主体部分，对于不同的中断请求源，其中断服务操作内容是不同的，例如，打印机要求CPU将需打印的一行字符代码，通过接口送入打印机的缓冲存储器中以供打印机打印。又如，显示设备要求CPU将需显示的一屏字符代码通过接口送人显示器的显示存储器中。</p><ul><li>恢复现场</li></ul><p>这是中断服务程序的结尾部分，要求在退出服务程序前，将原程序中断时的“现场”恢复到原来的寄存器中。通常可用取数指令或出栈指令(POP),将保存在存储器（或堆栈）中的信息送回到原来的寄存器中。</p><ul><li>中断返回</li></ul><p>中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p><h5 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h5><ul><li>单重中断 不允许中断现行的中断服务程序</li><li>多重中断 允许级别更高的中断源中断现行的中断服务程序</li></ul><h5 id="单重中断和多重中断的服务程序流程"><a href="#单重中断和多重中断的服务程序流程" class="headerlink" title="单重中断和多重中断的服务程序流程"></a>单重中断和多重中断的服务程序流程</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921215635101.png" class="" title="image-20230921215635101"><p>计算机在处理中断的过程中，有可能出现新的中断请求，此时如果CPU暂停现行的中断服务程序，转去处理新的中断请求，这种现象称为中断嵌套，或多重中断。倘若CPU在执行中断服务程序时，对新的中断请求不予理睬，这种中断称为单重中断。这两种处理方式的中断服务程序路有区别，上图分别为单重中断和多重中断服务程序流程。比较上图可以发现，其区别在于“开中断”的设置时间不同。</p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><h4 id="DMA方式特点"><a href="#DMA方式特点" class="headerlink" title="DMA方式特点"></a>DMA方式特点</h4><h5 id="DMA-和程序中断两种方式的数据通路"><a href="#DMA-和程序中断两种方式的数据通路" class="headerlink" title="DMA 和程序中断两种方式的数据通路"></a>DMA 和程序中断两种方式的数据通路</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926201541917.png" class="" title="image-20230926201541917"><p>由于主存和DMA接口之间有一条数据通路，因此主存和设备交换信息时，不通过CPU,也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高。这一特点特别适合于高速I&#x2F;O或辅存与主存之间的信息交换。因为高速I&#x2F;O设备若每次申请与主机交换信息时，都要等待CPU做出中断响应后再进行，很可能因此使数据丢失。值得注意的是，若出现高速I&#x2F;O(通过DMA接口)和CPU同时访问主存，CPU必须将总线(如地址线、数据线)占有权让给DMA接口使用，即DMA采用周期窃取的方式占用一个存取周期。</p><h5 id="DMA-与主存交换数据的三种方式"><a href="#DMA-与主存交换数据的三种方式" class="headerlink" title="DMA 与主存交换数据的三种方式"></a>DMA 与主存交换数据的三种方式</h5><ul><li>停止 CPU 访问主存</li></ul><p>当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202217133.png" class="" title="image-20230926202217133"><ul><li>周期挪用（或周期窃取）</li></ul><p>在这种方法中，每当I&#x2F;O设备发出DMA请求时，IO设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。I&#x2F;O设备请求DMA传送会遇到三种情祝。一种是CPU此时不需要访问主存（如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需要访问主存)，故I&#x2F;O设备与CPU不发生冲突。第二种情况是I&#x2F;O设备请求DMA传送时，CPU正在访问主存，此时必须待存取周期结束，CPU才能将总线占有权让出。第三种情况是I&#x2F;O设备要求访问主存时，CPU也要求访问主存，这就出现了访问冲突。此刻，I&#x2F;O访存优先于CPU访问主存，因为I&#x2F;O不立即访问主存就可能丢失数据，这时I&#x2F;O要窃取一、二个存取周期，意味着CPU在执行访问主存指令过程中插入了DMA请求，并挪用了一、二个存取周期，使CPU延缓了一、二个存取周期再访问主存。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202243779.png" class="" title="image-20230926202243779"><ul><li>DMA 与 CPU 交替访问</li></ul><p>这种方法适合于CPU的工作周期比主存存取周期长的情况。例如，CPU的工作周期为1.2u3,主存的存取周期小于0.6us,那么可将一个CPU周期分为C和C2两个分周期，其中C,专供DMA访存，C2专供CPU访存，</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202301140.png" class="" title="image-20230926202301140"><h4 id="DMA-接口的功能和组成"><a href="#DMA-接口的功能和组成" class="headerlink" title="DMA 接口的功能和组成"></a>DMA 接口的功能和组成</h4><h5 id="DMA-接口功能"><a href="#DMA-接口功能" class="headerlink" title="DMA 接口功能"></a>DMA 接口功能</h5><p>利用DMA方式传送数据时，数据的传输过程完全由DMA接口电路控制，故DMA接口又有DMA控制器之称。DMA接口应具有如下几个功能。</p><ul><li>向CPU申请DMA传送。</li><li>在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响CPU正常活动或引起总线竞争。</li><li>在DMA期间管理系统总线，控制数据传送。</li><li>确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度。</li><li>在数据块传送结束时，给出DMA操作完成的信号。</li></ul><h5 id="DMA-接口组成"><a href="#DMA-接口组成" class="headerlink" title="DMA 接口组成"></a>DMA 接口组成</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202653060.png" class="" title="image-20230926202653060"><ul><li>主存地址寄存器(AR)</li></ul><p>AR用于存放主存中需要交换数据的地址。在DMA传送数据前，必须通过程序将数据在主存中的首地址送到主存地址寄存器。在DMA传送过程中，每交换一次数据，将地址寄存器内容加1，直到一批数据传送完毕为止。</p><ul><li>字计数器(WC)</li></ul><p>WC用于记录传送数据的总字数，通常以交换字数的补码值预置。在DMA传送过程中，每传送一个字，字计数器如1，直到计数器为0，即最高位产生进位时，表示该批数据传送完毕（若交换字数以原码值预置，则每传送一个字，字计数器减1，直到计数器为0时，表示该批数据传送结束)。于是DMA接口向CPU发中断请求信号。</p><ul><li>数据缓冲寄存器(BR)</li></ul><p>BR用于暂存每次传送的数据。通常DMA接口与主存之间采用字传送，而DMA与设备之间可能是字节或位传送。因此DMA接口中还可能包括有装配或拆卸字信息的硬件逻辑，如数据移位缓冲寄存器、字节计数器等。</p><ul><li>DMA控制逻辑</li></ul><p>DMA控制逻辑负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。每当设备准备好一个数据字（或一个字传送结束），就向DMA接口提出申请(DREQ),DMA控制逻辑便向CPU请求DMA服务，发出总线使用权的请求信号(HRQ)。待收到CPU发出的响应信号HLDA后，DMA控制逻辑便开始负责管理DMA传送的全过程，包括对主存地址寄存器和字计数器的修改、识别总线地址、指定传送类型（输入或输出）以及通知设备已经被授予一个DMA周期(DACK)等。</p><ul><li>中断机构</li></ul><p>当字计数器溢出（全“0”）时，表示一批数据交换完毕，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作.DMA操作的后处理。必须注意，这里的中断与5.5节介绍的I&#x2F;O中断的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一批数据传送结束。它们是I&#x2F;O系统中不同的中断事件。</p><ul><li>设备地址寄存器(DAR)</li></ul><p>DAR存放I&#x2F;O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号、盘面号和柱面号。具体内容取决于设备的数据格式和地址的编址方式。</p><h4 id="DMA-的工作过程"><a href="#DMA-的工作过程" class="headerlink" title="DMA 的工作过程"></a>DMA 的工作过程</h4><h5 id="DMA-传送过程"><a href="#DMA-传送过程" class="headerlink" title="DMA 传送过程"></a>DMA 传送过程</h5><p>DMA的数据传送过程分为预处理、数据传送和后处理3个阶段。</p><h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>在DMA接口开始工作之前，CPU必须给它预置如下信息。</p><ol><li>给DMA控制逻辑指明数据传送方向是输人（写主存）还是输出（读主存）。</li><li>向DMA设备地址寄存器送人设备号，并启动设备。</li><li>向DMA主存地址寄存器送入交换数据的主存起始地址。</li><li>对字计数器赋予交换数据的个数。</li></ol><p>上述工作由CPU执行几条输入输出指令完成，即程序的初始化阶段。这些工作完成后，CPU继续执行原来的程序，当I&#x2F;O设备推备好发送的数据（输人）或上次接收的数据已经处理完毕（输出）时，它便通过DMA接口向CPU提出占用总线的申请，若有多个DMA同时申请，则按轻重缓急由硬件排队判优逻辑决定优先等。待I&#x2F;O设备得到主存总线的控制权后，数据的传送便由该DMA接口进行管理。</p><h6 id="DMA-传送过程示意"><a href="#DMA-传送过程示意" class="headerlink" title="DMA 传送过程示意"></a>DMA 传送过程示意</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203301196.png" class="" title="image-20230926203301196"><p>以数据输入为例：</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203631295.png" class="" title="image-20230926203631295"><ol><li>当设备准备好一个字时，发出选通信号，将该字读到DMA的数据级冲寄存器(BR)中，表示数据缓冲寄存器“满”（如果I&#x2F;O设备是面向字符的，则一次读入一个字节，组装成一个字）。</li><li>与此同时设备向DMA接口发请求(DREQ)。</li><li>DMA接口向CPU申请总线控制权(HRQ)。</li><li>CPU发回HLDA信号，表示允许将总线控制权交给DMA接口。</li><li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器写。</li><li>通知设备已被授予一个DMA周期(DACK),并为交换下一个字做准备。</li><li>将DMA数据缓冲寄存器的内容送数据总线。</li><li>主存将数据总线上的信息写至地址总线指定的存储单元中。</li><li>修改主存地址和字计数值。</li><li>判断数据块是否传送结束，若未结束，则继续传送；若已结束，（宇计数器溢出），则向CPU申请程序中断，标志数据块传送结束。</li></ol><p>以数据输出为例：</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203744324.png" class="" title="image-20230926203744324"><ol><li>当DMA数据缓冲寄存器已将输出数据送至&#x2F;0设备后，表示数据缓冲寄存器已“空”。</li><li>设备向DMA接口发请求(DREQ)。</li><li>DMA接口向CPU申请总线控制权(HRQ)。</li><li>CPU发回HLDA信号，表示允许将总线控制权交给DMA接口使用。</li><li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器读。</li><li>通知设备已被授予一个DMA周期(DACK),并为交换下一个字做准备。</li><li>主存将相应地址单元的内容通过数据总线读入到DMA的数据缓冲寄存器中。</li><li>将DMA数据缓神寄存器的内容送到输出设备，若为字符设备，则需将其拆成字符输出。</li><li>修改主存地址和字计数值。</li><li>判断数据块是否已传送完毕，若未完毕，继续传送；若已传送完毕，则向CPU申请程序中断。</li></ol><h6 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h6><p>当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，做一些DMA的结束工作的后处理部分。这包括校验送入主存的数据是否正确；决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化，若不需要传送，则停止外设；测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序。</p><h5 id="DMA-接口与系统的连接方式"><a href="#DMA-接口与系统的连接方式" class="headerlink" title="DMA 接口与系统的连接方式"></a>DMA 接口与系统的连接方式</h5><h6 id="具有公共请求线的-DMA-请求"><a href="#具有公共请求线的-DMA-请求" class="headerlink" title="具有公共请求线的 DMA 请求"></a>具有公共请求线的 DMA 请求</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204157036.png" class="" title="image-20230926204157036"><p>为具有公共请求线的DMA请求方式，若干个DMA接口通过一条公用的DMA请求线向CPU申请总线控制权。CPU发出响应信号，用链式查询方式通过DMA接口，首先选中的设备获得总线控制权，即可占用总线与主存传送信息。</p><h6 id="独立的-DMA-请求"><a href="#独立的-DMA-请求" class="headerlink" title="独立的 DMA 请求"></a>独立的 DMA 请求</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204213449.png" class="" title="image-20230926204213449"><p>)是独立的DMA请求方式，每一个DMA接口各有一对独立的DMA请求线和DMA响应线，它由CPU的优先级判别机构裁决首先响应哪个请求，并在响应线上发出响应信号，被获得响应信号的DMA接口便可控制总线与主存传送数据。</p><p>与程序中断方式相比，DMA方式有如下特点。</p><ul><li>从数据传送看，程序中断方式靠程序传送，DMA方式靠硬件传送。</li><li>从CPU响应时间看，程序中断方式是在一条指令执行结束时响应，而DMA方式可在指令周期内的任一存取周期结束时响应。</li><li>程序中断方式有处理异常事件的能力，DMA方式没有这种能力，主要用于大批数据的传送，如硬盘存取、图像处理、高速数据采集系统等，可提高数据吞吐量。</li><li>程序中断方式需要中断现行程序，故需保护现场；DMA方式不中断现行程序，无须保护现场。</li><li>DMA的优先级比程序中断的优先级高。</li></ul><h4 id="DMA-接口的类型"><a href="#DMA-接口的类型" class="headerlink" title="DMA 接口的类型"></a>DMA 接口的类型</h4><h5 id="选择型"><a href="#选择型" class="headerlink" title="选择型"></a>选择型</h5><p>这种类型的DMA接口的基本组成，它的主要特点是在物理上可连接多个设备，在逻辑上只允许连接一个设备，即在某一段时间内，DMA接口只能为一个设备服务，关键是在预处理时将所选设备的设备号送人设备地址寄存器。</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204614841.png" class="" title="image-20230926204614841"><h5 id="多路型"><a href="#多路型" class="headerlink" title="多路型"></a>多路型</h5><p>多路型DMA接口不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作，各个设备采用字节交叉的方式通过DMA接口进行数据传送。在多路型DMA接口中，为每个与它连接的设备都设置了一套寄存器，分别存放各自的传送参数。分</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204638266.png" class="" title="image-20230926204638266"><p>多路型 DMA 接口的工作原理</p><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204937986.png" class="" title="image-20230926204937986"><p>上图是多路型DMA接口工作原理示意图。图中磁盘、磁带、打印机同时工作。磁盘、磁带、打印机分别每隔30us、45us、150us向DM接口发DMA请求，磁盘的优先级高于磁带，磁带的优先级高于打印机。</p><p>假设DMA接口完成一次DMA数据传送需5s,由图可见，打印机首先发请求，故DMA接口首先为打印机服务(T1);接着磁盘、磁带同时又有DMA请求，DMA接口按优先级别先响应磁盘请求(T2),再响应磁带请求(T3),每次DMA传送都是一个字节。这样，在90多微秒的时间里，DMA接口为打印机服务一次(T1),为磁盘服务4次(T2、T4、T6、T7),为磁带服务3次(T3、T5、T8)。可见DMA接口还有很多空闲时间，可再容纳更多的设备。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/09/18/mysql%E7%AF%87/"/>
    <url>/2023/09/18/mysql%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h6 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h6><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th align="right">用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 Bytes</td><td>(-128，127)</td><td>(0，255)</td><td align="right">小整数值</td></tr><tr><td>SMALLINT</td><td>2 Bytes</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td align="right">大整数值</td></tr><tr><td>MEDIUMIN</td><td>3 Bytes</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td align="right">大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 Bytes</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td align="right">大整数值</td></tr><tr><td>BIGINT</td><td>8 Bytes</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td align="right">极大整数值</td></tr><tr><td>FLOAT</td><td>4 Bytes</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="right">单精度<br/>浮点数值</td></tr><tr><td>DOUBLE</td><td>8 Bytes</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="right">双精度<br/>浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td align="right">小数值</td></tr></tbody></table><h6 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h6><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="center">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01&#x2F;9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="center">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901&#x2F;2155</td><td align="left">YYYY</td><td align="center">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="center">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="center">混合日期和时间值，时间戳</td></tr></tbody></table><h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6><table><thead><tr><th>CHAR</th><th>0-255 bytes</th><th>定长字符串</th></tr></thead><tbody><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><h6 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT DATABASE 数据库名;<br></code></pre></td></tr></table></figure><h6 id="查看MySQL服务器中的所有的数据库"><a href="#查看MySQL服务器中的所有的数据库" class="headerlink" title="查看MySQL服务器中的所有的数据库"></a>查看MySQL服务器中的所有的数据库</h6><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show databases<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h6 id="删除一个数据库"><a href="#删除一个数据库" class="headerlink" title="删除一个数据库"></a>删除一个数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE 数据库名称;<br></code></pre></td></tr></table></figure><h6 id="选择一个数据库"><a href="#选择一个数据库" class="headerlink" title="选择一个数据库"></a>选择一个数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE 数据库名字;<br></code></pre></td></tr></table></figure><h6 id="查看正在使用的数据库"><a href="#查看正在使用的数据库" class="headerlink" title="查看正在使用的数据库"></a>查看正在使用的数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure><h4 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h4><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><h5 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE if not exists 表名(<br>字段名  类型(长度) [约束],<br>字段名  类型(长度) [约束],<br>   ...<br>);<br>类型：<br>      varchar(n)字符串<br>      int   整形<br>      double浮点<br>      date   时间<br>      timestamp时间戳<br>约束：<br>primary key  主键，被主键修饰字段中的数据，不能重复、不能为null。<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建分类表<br>CREATE TABLE category ( <br>cid varchar(20) primary key,#分类ID <br>cname VARCHAR(100) #分类名称<br>);<br></code></pre></td></tr></table></figure><h5 id="验证表结构"><a href="#验证表结构" class="headerlink" title="验证表结构"></a>验证表结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># SHOW CREATE TABLE 表名\G<br>SHOW CREATE TABLE category\G<br></code></pre></td></tr></table></figure><h5 id="查看数据库中的所有表"><a href="#查看数据库中的所有表" class="headerlink" title="查看数据库中的所有表"></a>查看数据库中的所有表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure><h5 id="查看表结构："><a href="#查看表结构：" class="headerlink" title="查看表结构："></a>查看表结构：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># desc 表名;<br>desc category;<br></code></pre></td></tr></table></figure><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># drop table 表名;<br>drop table category;<br></code></pre></td></tr></table></figure><h5 id="修改表结构格式"><a href="#修改表结构格式" class="headerlink" title="修改表结构格式"></a>修改表结构格式</h5><h6 id="添加列："><a href="#添加列：" class="headerlink" title="添加列："></a>添加列：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#alter table 表名 add 列名 类型(长度) [约束];注意是` 而不是’<br>ALTER TABLE category ADD `desc` VARCHAR(20); <br></code></pre></td></tr></table></figure><h6 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#alter table 表名 change 旧列名 新列名 类型(长度) 约束;<br>ALTER TABLE category CHANGE `desc` description VARCHAR(30);<br></code></pre></td></tr></table></figure><h6 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a>删除列：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#alter table 表名 drop 列名;<br>ALTER TABLE category DROP description;<br></code></pre></td></tr></table></figure><h6 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名:"></a>修改表名:</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#rename table 表名 to 新表名;<br>RENAME TABLE `category` TO category2;<br></code></pre></td></tr></table></figure><h4 id="数据库操作语言"><a href="#数据库操作语言" class="headerlink" title="数据库操作语言"></a>数据库操作语言</h4><h5 id="插入表记录：insert"><a href="#插入表记录：insert" class="headerlink" title="插入表记录：insert"></a>插入表记录：insert</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>向表中插入数据<br>insert into 表 (字段1,字段2,字段3...) values(值1,值2,值3...);<br>向表中插入所有字段,字段的顺序为创建表时的顺序<br>insert into 表 values(值1,值2,值3..);<br>值与字段必须对应，个数相同，类型相同<br>值的数据大小必须在字段的长度范围内<br>除了数值类型外，其它的字段类型的值必须使用引号引起。（建议单引号）<br>如果要插入空值，可以不写字段，或者插入 null。<br>*/<br>INSERT INTO category(cid,cname) VALUES(&#x27;c001&#x27;,&#x27;电器&#x27;); <br>INSERT INTO category(cid,cname) VALUES(&#x27;c002&#x27;,&#x27;服饰&#x27;); <br>INSERT INTO category(cid,cname) VALUES(&#x27;c003&#x27;,&#x27;化妆品&#x27;); <br>INSERT INTO category(cid,cname) VALUES(&#x27;c004&#x27;,&#x27;书籍&#x27;);<br>INSERT INTO category(cid) VALUES(&#x27;c005&#x27;); <br>insert into category values(&#x27;06&#x27;,&#x27;玩具&#x27;),(&#x27;07&#x27;,&#x27;蔬菜&#x27;);<br></code></pre></td></tr></table></figure><h5 id="更新表记录：update"><a href="#更新表记录：update" class="headerlink" title="更新表记录：update"></a>更新表记录：update</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>更新所有记录的指定字段<br>update 表名 set 字段名=值,字段名=值,...;<br>更新符合条件记录的指定字段<br>update 表名 set 字段名=值,字段名=值,... where 条件;<br>列名的类型与修改的值要一致.<br>修改值得时候不能超过最大长度.<br>除了数值类型外，其它的字段类型的值必须使用引号引起<br><br>*/<br>update category set cname  = &#x27;家电’; <br>update category set cname  = &#x27;水果&#x27; where cid = &#x27;c001&#x27;; <br></code></pre></td></tr></table></figure><h5 id="删除记录：delete"><a href="#删除记录：delete" class="headerlink" title="删除记录：delete"></a>删除记录：delete</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>delete from 表名 [where 条件];<br>或者清空表<br>truncate table 表名;  <br>*/<br>#删除cid为005的纪录<br>delete from category where cid = &#x27;005&#x27;; <br>#清空表数据<br>truncate category;  <br></code></pre></td></tr></table></figure><h4 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h4><h5 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h5><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p><p>1.主键必须包含唯一的值。</p><p>2.主键列不能包含 NULL 值。</p><p>3.每个表都应该有一个主键，并且每个表只能有一个主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 方式一：创建表时，在字段描述处，声明指定字段为主键：<br>CREATE TABLE persons<br>(<br> id int PRIMARY KEY,<br> lastName varchar(255),<br> firstName varchar(255),<br> address varchar(255),<br> city varchar(255)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>方式二：创建表时，在constraint约束区域，声明指定字段为主键：<br>格式：[constraint 名称] primary key (字段列表)<br>关键字constraint可以省略，如果需要为主键命名，constraint不能省略，主键名称一般没用。<br>字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。声明两个以上字段为主键，我们称为联合主键。<br>*/<br>CREATE TABLE persons2<br>(<br>  firstName varchar(255),<br>  lastName  varchar(255),<br>  address   varchar(255),<br>  city      varchar(255),<br>  CONSTRAINT pk_personID PRIMARY KEY (firstName, lastName)<br>);<br></code></pre></td></tr></table></figure><h5 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE persons DROP PRIMARY KEY;<br></code></pre></td></tr></table></figure><h5 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h5><p>我们通常希望在每次插入新记录时，数据库自动生成字段的值。</p><p>我们可以在表中使用 auto_increment（自动增长列）关键字，自动增长列类型必须是整型，自动增长列必须为键(一般是主键)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE persons4<br>(<br>  id      int PRIMARY KEY AUTO_INCREMENT,<br>  lastName  varchar(255),<br>  firstName varchar(255),<br>  address   varchar(255),<br>  city      varchar(255)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#向persons添加数据时，可以不为Id字段设置值，也可以设置成null，数据库将自动维护主键值：<br>INSERT INTO persons4 (firstName,lastName) VALUES (&#x27;Bill&#x27;,&#x27;Gates&#x27;)<br>INSERT INTO persons4 (id,firstName,lastName) VALUES (NULL,&#x27;Bill&#x27;,&#x27;Gates&#x27;)<br></code></pre></td></tr></table></figure><p>扩展：默认AUTO_INCREMENT 的开始值是 1，如果希望修改起始值，请使用下列 SQL 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE persons AUTO_INCREMENT=100<br></code></pre></td></tr></table></figure><h5 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h5><p>NOT NULL 约束强制列不接受 NULL 值。</p><p>NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE persons5<br>(<br>  id      int          NOT NULL,<br>  lastName  varchar(255) NOT NULL,<br>  firstName varchar(255),<br>  address   varchar(255),<br>  city      varchar(255)<br>);<br></code></pre></td></tr></table></figure><h5 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h5><p>lUNIQUE 约束唯一标识数据库表中的每条记录。</p><p>lUNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p><p>lPRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p><p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE persons<br>(<br>  id      int UNIQUE,<br>  lastName  varchar(255) NOT NULL,<br>  firstName varchar(255) UNIQUE ,<br>  address   varchar(255),<br>  city      varchar(255)<br>)<br></code></pre></td></tr></table></figure><h4 id="DQL查询操作"><a href="#DQL查询操作" class="headerlink" title="DQL查询操作"></a>DQL查询操作</h4><h5 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [distinct]<br>*| 列名,列名<br>from 表<br>where 条件<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建商品表：<br>create table product(<br> pid int primary key,<br> pname varchar(20),<br> price double,<br> category_id varchar(32)<br>);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(1,&#x27;联想&#x27;,5000,&#x27;c001&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(2,&#x27;海尔&#x27;,3000,&#x27;c001&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(3,&#x27;雷神&#x27;,5000,&#x27;c001&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(4,&#x27;杰克琼斯&#x27;,800,&#x27;c002&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(5,&#x27;真维斯&#x27;,200,&#x27;c002&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(6,&#x27;花花公子&#x27;,440,&#x27;c002&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(7,&#x27;劲霸&#x27;,2000,&#x27;c002&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(8,&#x27;香奈儿&#x27;,800,&#x27;c003&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(9,&#x27;相宜本草&#x27;,200,&#x27;c003&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(10,&#x27;面霸&#x27;,5,&#x27;c003&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(11,&#x27;好想你枣&#x27;,56,&#x27;c004&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(12,&#x27;香飘飘奶茶&#x27;,1,&#x27;c005&#x27;);<br>INSERT INTO product(pid,pname,price,category_id) VALUES(13,&#x27;海澜之家&#x27;,1,&#x27;c002&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1.查询所有的商品.  <br>select *  from product;<br>#2.查询商品名和商品价格. <br>select pname,price from product;<br>#3.别名查询.使用的关键字是as（as可以省略的）.  <br>#3.1表别名: <br>select * from product as p;<br>#3.2列别名：<br>select pname as pn from product; <br>#4.去掉重复值.  <br>select distinct price from product;<br>#5.查询结果是表达式（运算查询）：将所有商品的价格+10元进行显示.<br>select pname,price+10 from product;<br></code></pre></td></tr></table></figure><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><strong>条件查询</strong></h5><img src="/2023/09/18/mysql%E7%AF%87/image-20230929154858166.png" class="" title="image-20230929154858166"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查询商品名称为“花花公子”的商品所有信息：<br>select * from product where pname=&#x27;花花公子&#x27;;<br>#查询价格为800商品<br>select * from product where price=800;<br>#查询价格不是800的所有商品<br>select * from product where price&lt;&gt;800;<br>select * from product where price!=800;<br>select * from product where not(price=800);<br>#查询商品价格大于60元的所有商品信息<br>select * from product where price&gt;60;<br>#查询商品价格在200到1000之间所有商品<br>select * from product where price&gt;=200 and price&lt;=1000;<br>select * from product where price between 200 and 1000;<br>#查询商品价格是200或800的所有商品<br>select * from product where price=200 or price=800;<br>select * from product where price in(200,800);<br>#查询含有&#x27;霸&#x27;字的所有商品<br>select * from product where pname like&#x27;%霸%&#x27;;<br>#查询以&#x27;香&#x27;开头的所有商品<br>select * from product where pname like&#x27;香%&#x27;;<br>#查询第二个字为&#x27;想&#x27;的所有商品<br>select * from product where pname like&#x27;_想%&#x27;;<br>#查询没有分类的商品<br>select * from product where category_id is null;<br>#查询有分类的商品<br>select * from product where category_id is not null;<br></code></pre></td></tr></table></figure><h5 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h5><p>通过order by语句，可以将查询出的结果进行排序。暂时放置在select语句的最后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;<br> ASC 升序 (默认)<br> DESC 降序<br>*/<br>#1.使用价格排序(降序)<br>select * from product order by price desc;<br>#2.在价格排序(降序)的基础上，以分类排序(降序)<br>select * from product order by price desc,category_id desc;<br>#3.显示商品的价格(去重复)，并排序(降序)<br>select distinct price from product order by price desc;<br><br></code></pre></td></tr></table></figure><h5 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h5><p>之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</p><img src="/2023/09/18/mysql%E7%AF%87/image-20230929160953036.png" class="" title="image-20230929160953036"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1 查询商品的总条数<br>select count(*) from product;<br>#2 查询价格大于200商品的总条数<br>select count(*) from product where price&gt;200;<br>#3 查询分类为&#x27;c001&#x27;的所有商品的总和<br>select sum(price) from product where category_id=&#x27;c001&#x27;;<br>#4 查询分类为&#x27;c002&#x27;所有商品的平均价格<br>select avg(price) from product where category_id=&#x27;c002&#x27;;<br>#5 查询商品的最大价格和最小价格<br>select max(price),min(price) from product;<br></code></pre></td></tr></table></figure><h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><p>分组查询是指使用group by字句对查询信息进行分组。</p><p>格式：</p><p>SELECT 字段1,字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;</p><p>分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。</p><p>having与where的区别:</p><p>1).having是在分组后对数据进行过滤.,where是在分组前对数据进行过滤</p><p>2).having后面可以使用分组函数(统计函数),where后面不可以使用分组函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1 统计各个分类商品的个数<br>select category_id,count(*) from product group by category_id;<br>#2 统计各个分类商品的个数,且只显示个数大于1的信息<br>select category_id,count(*) from product group by category_id having count(*)&gt;1;<br></code></pre></td></tr></table></figure><h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h5><p>分页查询在项目开发中常见，由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条，第一页显示1-5条，第二页显示6-10条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>SELECT 字段1，字段2... FROM 表名 LIMIT M,N<br>M: 整数，表示从第几条索引开始，计算方式 （当前页-1）*每页显示条数<br>N: 整数，表示查询多少条数据<br>SELECT 字段1，字段2... FROM 表明 LIMIT 0,5<br>SELECT 字段1，字段2... FROM 表明 LIMIT 5,5<br>*/<br><br># 查询第一条到第五条商品信息<br>select * from product limit 0,5;<br># 查询第六条到第十条商品信息<br>select * from product limit 5,5;<br></code></pre></td></tr></table></figure><h5 id="insert-into-select语句"><a href="#insert-into-select语句" class="headerlink" title="insert into select语句"></a>insert into select语句</h5><p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">/*<br>INSERT INTO table2<br>SELECT column_name(s)<br>FROM table1;<br>*/<br>create table product2(<br> pid int primary key,<br> pname varchar(20),<br> price double<br>);<br>insert into product2 select pid,pname,price from product where category_id = &#x27;c001&#x27;;<br><br></code></pre></td></tr></table></figure><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p>实际开发中，一个项目通常需要很多张表才能完成。例如：一个商城项目就需要分类表(category)、商品(products)、订单表(orders)等多张表。且这些表的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001104203985.png" class="" title="image-20231001104203985"><h5 id="表与表之间的关系"><a href="#表与表之间的关系" class="headerlink" title="表与表之间的关系"></a>表与表之间的关系</h5><p>一对多关系：常见实例：客户和订单，分类和商品，部门和员工.</p><p>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键.</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001104323733.png" class="" title="image-20231001104323733"><h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p>现在我们有两张表“分类表”和“商品表”，为了表明商品属于哪个分类，通常情况下，我们将在商品表上添加一列，用于存放分类cid的信息，此列称为：外键</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001104458230.png" class="" title="image-20231001104458230"><img src="/2023/09/18/mysql%E7%AF%87/image-20231001104503174.png" class="" title="image-20231001104503174"><p>此时“分类表category”称为：主表，“cid”我们称为主键。“商品表products”称为：从表，category_id称为外键。我们通过主表的主键和从表的外键来描述主外键关系，呈现就是一对多关系。</p><p>外键特点：</p><ul><li>从表外键的值是对主表主键的引用。</li><li>从表外键类型，必须与主表主键类型一致</li></ul><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysq">alter table 从表 add [constraint] [外键名称] foreign key (从表外键字段名) references 主表 (主表的主键);<br></code></pre></td></tr></table></figure><p>[外键名称] 用于删除外键约束的，一般建议“_fk”结尾： alter table 从表 drop foreign key 外键名称</p><h5 id="一对多操作"><a href="#一对多操作" class="headerlink" title="一对多操作"></a>一对多操作</h5><img src="/2023/09/18/mysql%E7%AF%87/image-20231001104903570.png" class="" title="image-20231001104903570"><ul><li>category分类表，为一方，也就是主表，必须提供主键cid</li><li>products商品表，为多方，也就是从表，必须提供外键category_id</li></ul><p>注意插入数据前要先确保外键对应的表包含数据，如果关联的表没有数据，此时该表的主键值作为另一表的外键值，插入数据就会报错。比如A表的主键id字段是B表的外键，给B表插入数据前必须保证A表的主键至少是有数据的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">###创建分类表<br>create table category(<br>  cid varchar(32) PRIMARY KEY ,<br>  cname varchar(100)  #分类名称<br>);<br><br># 商品表<br>CREATE TABLE products (<br>  pid varchar(32) PRIMARY KEY  ,<br>  name VARCHAR(40) ,<br>  price DOUBLE ,<br>  category_id varchar(32)<br>);<br>#添加约束<br>alter table products add constraint product_fk foreign key (category_id) references category (cid);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1 向分类表中添加数据<br>insert into category values(&#x27;c001&#x27;,&#x27;服饰&#x27;);<br><br>#2 向商品表添加普通数据，含有外键信息(category表中存在这条数据)<br>INSERT INTO products (pid ,pname ,category_id) VALUES(&#x27;p002&#x27;,&#x27;商品名称2&#x27;,&#x27;c001&#x27;);<br><br>#3 向商品表添加普通数据，含有外键信息(category表中不存在这条数据) -- 失败,异常<br>INSERT INTO products (pid ,pname ,category_id) VALUES(&#x27;p003&#x27;,&#x27;商品名称2&#x27;,&#x27;c999&#x27;);<br><br>#4 删除指定分类(分类被商品使用) -- 执行异常<br>DELETE FROM category WHERE cid = &#x27;c001&#x27;;<br></code></pre></td></tr></table></figure><ul><li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li><li><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li><li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li></ul><img src="/2023/09/18/mysql%E7%AF%87/image-20231001114342522.png" class="" title="image-20231001114342522"><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>子查询：一条select语句结果作为另一条select语法一部分（查询条件，查询结果，表等）。</p><p>select ….查询字段 … from … 表.. where … 查询条件</p><h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四增加1000, 转账成功 :</p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务</p><h5 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h5><h6 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs msyql">drop table if exists account;<br>create table account(<br>id int primary key AUTO_INCREMENT comment &#x27;ID&#x27;,<br>name varchar(10) comment &#x27;姓名&#x27;,<br>money double(10,2) comment &#x27;余额&#x27;<br>) comment &#x27;账户表&#x27;;<br>insert into account(name, money) VALUES (&#x27;张三&#x27;,2000), (&#x27;李四&#x27;,2000);<br></code></pre></td></tr></table></figure><h5 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h5><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h5 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h5><p>赃读：一个事务读到另外一个事务还没有提交的数据。</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001121950972.png" class="" title="image-20231001121950972"><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001122024209.png" class="" title="image-20231001122024209"><p> 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001122047944.png" class="" title="image-20231001122047944"><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><img src="/2023/09/18/mysql%E7%AF%87/image-20231001122114993.png" class="" title="image-20231001122114993"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看事务隔离级别<br>SELECT @@TRANSACTION_ISOLATION;<br># 设置事务隔离级别<br>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED |<br>READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;<br></code></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是 MySQL 中一种十分重要的数据库对象。它是数据库性能调优技术的基础，常用于实现数据的快速检索。</p><p> 索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。</p><p>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</p><ol><li>顺序访问</li></ol><p>顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。这种方式实现比较简单，但是当表中有大量数据的时候，效率非常低下。</p><ol start="2"><li>索引访问</li></ol><p>索引访问是通过遍历索引来直接访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。</p><h5 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h5><p>根据存储方式的不同，MySQL 中常用的索引在物理上分为以下两类。</p><p>B-树索引</p><p>B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。B-树索引是一个典型的数据结构，基于这种树形数据结构，表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。</p><p>哈希索引</p><p>哈希（Hash）一般翻译为“散列”，也有直接音译成“哈希”的，就是把任意长度的输入（又叫作预映射，pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</p><p>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。</p><h5 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h5><h6 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#语法：<br>#CREATE INDEX indexName ON mytable(username(length)); <br>#给category表的cname字段添加索引<br><br>create index index_cname on category (cname(20));<br></code></pre></td></tr></table></figure><h5 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#语法：<br>#ALTER table tableName ADD INDEX indexName(columnName)<br><br>alter table products add index index_comment(price);<br></code></pre></td></tr></table></figure><h5 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#1、查看表中所有索引<br>SHOW INDEX FROM table_name;<br>#2、查看数据库所有索引<br>SELECT * FROM mysql.`innodb_index_stats` a WHERE a.`database_name` = &#x27;数据库名&#x27;;<br><br>#2、查看某一表索引<br>SELECT * FROM mysql.`innodb_index_stats` a WHERE a.`database_name` = &#x27;数据库名&#x27; and a.table_name like &#x27;%表名%&#x27;;<br><br></code></pre></td></tr></table></figure><h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#语法：<br>#DROP INDEX [indexName] ON mytable;<br>#执行<br><br>DROP INDEX indexName ON mytable;<br></code></pre></td></tr></table></figure><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 语法：<br># CREATE UNIQUE INDEX indexName ON mytable(username(length)) <br># 执行：<br><br>CREATE UNIQUE INDEX indexName ON mytable(username(16))<br><br># 删除索引<br># 语法：<br># DROP INDEX [indexName] ON mytable;<br># 执行：<br><br>alter table mytable drop index indexName;<br></code></pre></td></tr></table></figure><p>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p><p>4.对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。</p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><h5 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构<img src="/2023/09/18/mysql%E7%AF%87/image-20231001155250052.png" class="" title="image-20231001155250052"></h5><ul><li>连接层</li></ul><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于TCP&#x2F;IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><ul><li>服务层</li></ul><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li>引擎层</li></ul><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</p><ul><li>存储层</li></ul><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h5 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h5><p>而对于存储引擎，他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。接下来就来介绍一下存储引擎。</p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。</p><h6 id="建表时指定存储引擎"><a href="#建表时指定存储引擎" class="headerlink" title="建表时指定存储引擎"></a>建表时指定存储引擎</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [ COMMENT 字段1注释 ] ,<br>......<br>字段n 字段n类型 [COMMENT 字段n注释 ]<br>) ENGINE = INNODB [ COMMENT 表注释 ] ;<br></code></pre></td></tr></table></figure><h6 id="查询当前数据库支持的存储引擎"><a href="#查询当前数据库支持的存储引擎" class="headerlink" title="查询当前数据库支持的存储引擎"></a>查询当前数据库支持的存储引擎</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建表 my_myisam , 并指定MyISAM存储引擎<br>create table my_myisam(<br>id int,<br>name varchar(10)<br>) engine = MyISAM ;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建表 my_memory , 指定Memory存储引擎<br>create table my_memory(<br>id int,<br>name varchar(10)<br>) engine = Memory ;<br></code></pre></td></tr></table></figure><h5 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h5><h6 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h6><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。</p><p>特点:</p><ul><li>DML操作遵循ACID模型，支持事务；</li><li>行级锁，提高并发访问性能；</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><p> 文件:</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;innodb_file_per_table&#x27;;<br></code></pre></td></tr></table></figure><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件夹，不同的文件夹代表不同的数据库，我们直接打开itcast文件夹。</p><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p>逻辑存储结构：</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001161223812.png" class="" title="image-20231001161223812"><p>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</p><p>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</p><p>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><p>页 : 页是组成区的最小单元，<strong>页也是****InnoDB</strong> <strong>存储引擎磁盘管理的最小单元</strong>，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)</p><h6 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h6><p>MyISAM是MySQL早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p> 文件：</p><ul><li>xxx.sdi：存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h6 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h6><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p> 特点:</p><ul><li>内存存放</li><li>hash索引（默认）</li></ul><p>文件：</p><p>xxx.sdi：存储表结构信息</p><h5 id="区别及特点"><a href="#区别及特点" class="headerlink" title="区别及特点"></a>区别及特点</h5><img src="/2023/09/18/mysql%E7%AF%87/image-20231001161645458.png" class="" title="image-20231001161645458"><h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><h5 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p><img src="/2023/09/18/mysql%E7%AF%87/image-20231001162022742.png" class="" title="image-20231001162022742">]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层(三)</title>
    <link href="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/"/>
    <url>/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本章最重要的内容是：</p><ul><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议(PPP协议以及CSMA&#x2F;CD协议)的特点。</li><li>数据链路层的三个基本问题：封装成帧、透明传输和差错检测。</li><li>以太网MAC层的硬件地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。</li></ul><span id="more"></span><p>数据链路层属于计算机网络的低层。数据链路层使用的信道主要有以下两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式。</li><li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><h3 id="数据链路层的几个共同问题"><a href="#数据链路层的几个共同问题" class="headerlink" title="数据链路层的几个共同问题"></a>数据链路层的几个共同问题</h3><h4 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h4><p>我们在这里要明确一下，<strong>“链路”</strong>和<strong>“数据链路”</strong>并不是一回事。所谓<strong>链路</strong>(link)就是从一个节点到<strong>相邻节点</strong>的一段物理线路（有线或无线)，而中间没有任何其他的交换节点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</p><p><strong>数据链路(data link)<strong>则是另一个概念。这是因为当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输（这将在后面几节讨论)。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用网络适配器（既有硬件，也包括软件）来实现这些协议。一般的适配器都包括了数据链路层和物理层这两层的功能。也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。物理链路就是上面所说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。早期的数据通信协议曾叫作通信</strong>规程</strong>(procedure)。因此在数据链路层，规程和协议是同义语。</p><p><strong>桢</strong>——点对点信道的数据链路层的协议数据单元</p><p>数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是IP数据报（或简称为数据报、分组或包)。</p><p>为了把主要精力放在点对点信道的数据链路层协议上，可以采用下图所示的三层模型。在这种三层模型中，不管在哪一段链路上的通信（主机和路由器之间或两个路由器之间)，我们都看成是节点和节点的通信（如图中的节点A和节点B),而每个节点只有下三层—网络层、数据链路层和物理层。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910194724135.png" class="" title="image-20230910194724135"><p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p><ol><li>节点A的数据链路层把网络层交下来的P数据报添加首部和尾部封装成帧。</li><li>节点A把封装好的帧发送给节点B的数据链路层。</li><li>若节点B的数据链路层收到的帧无差错，则从收到的帧中提取出P数据报交给上面的网络层：否则丢弃这个帧。数据链路层不必考虑物理层如何实现比特传输的细节。我们甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方，如下图所示</li></ol><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910194930340.png" class="" title="image-20230910194930340"><h4 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h4><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：封装成帧、透明传输和差错检测。</p><h5 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h5><p>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。下图表示用帧首部和帧尾部封装成帧的一般概念。我们知道，分组交换的一个重要概念就是：所有在互联网上传送的数据都以分组（即IP数据报）为传送单位。网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限一最大传送单元MTU(Maximum Transfer Unit)。下图给出了帧的首部和尾部的位置，以及帧的数据部分与MTU的关系</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910195411903.png" class="" title="image-20230910195411903"><h5 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h5><p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。但当数据部分是非ASCⅡ码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样(如图3-6所示)，数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧)，而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH)。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910200044140.png" class="" title="image-20230910200044140"><p>像上图所示的帧的传输显然就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了。数据中的“EOT”将被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。但实际上在数据中出现的字符“E0T”并非控制字符而仅仅是二进制数据00000100。</p><p>前面提到的“透明”是一个很重要的术语。它表示：某一个实际存在的事物看起来却好像不存在一样（例如，你看不见在你前面有块100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p><p>前面提到的“透明”是一个很重要的术语。它表示：某一个实际存在的事物看起来却好像不存在一样（例如，你看不见在你前面有块100%透明的玻璃的存在）。“在数据链路层透明传送数据”表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。</p><p>为了解决透明传输问题，就必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。<strong>具体的方法</strong>是：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B,二进制是00011011)。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充(byte stuffing)或字符填充(character stuffing)。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。下图表示用字节填充法解决透明传输的问题。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910222053765.png" class="" title="image-20230910222053765"><h5 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h5><p>现实的通信链路都不会是理想的。这就是说，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。这就叫作<strong>比特差错</strong>。比特差错是传输差错中的一种。本小节所说的“差错”，如无特殊说明，就是指“比特差错”。在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率BER</strong>(Bit Error Rate)。例如，误码率为10^-10时，表示平均每传送10个比特就会出现一个比特的差错。误码率与信噪比有很大的关系。如果设法提高信噪比，就可以使误码率减小。实际的通信链路并非是理想的，它不可能使误码率下降到零。因此，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。目前在数据链路层广泛使用了<strong>循环冗余检验</strong>CRC(Cyclic Redundancy Check)的检错技术。</p><h6 id="CRC循环冗余校验码的原理"><a href="#CRC循环冗余校验码的原理" class="headerlink" title="CRC循环冗余校验码的原理"></a>CRC循环冗余校验码的原理</h6><p>发送端，先把数据划分为组，假定每组k位比特，在每组M后面再添加供差错检测用的n位冗余码（帧检验序列FCS），然后构成一个帧发送出去，那么就是一共发送k+n位</p><p>接收端，接收到k+n位之后，将接收到都除以相同的P，然后检出余数R，如果余数R为0，则证明传输正确。</p><h6 id="冗余码FCS的计算"><a href="#冗余码FCS的计算" class="headerlink" title="冗余码FCS的计算"></a>冗余码FCS的计算</h6><ol><li>用二进制的模2运算进行2^n乘M的运算，这相当于在M后面添加n个0</li><li>得到的k+n位的数除以事先选定好的长度为n+1位的除数P，得出商是Q，余数是R，余数R比除数P少1位，即R是n位。</li><li>将余数R作为冗余码拼接在数据M后面，一起发送出去。</li></ol><p>计算过程如下图所示</p><ol><li>假定要传输的数据为M&#x3D;101001（k&#x3D;6）；</li><li>假定除数为P&#x3D;1101（因为选定的是除数P是4位，所以n&#x3D;3，也就是P的位数-1）</li><li>在M后面加n个0（n&#x3D;3，所以加3个0），得到M’&#x3D;101001000；</li><li>用M’除以P</li></ol><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910223309774.png" class="" title="image-20230910223309774"><h6 id="除数P是哪来的"><a href="#除数P是哪来的" class="headerlink" title="除数P是哪来的"></a>除数P是哪来的</h6><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230910223644470.png" class="" title="image-20230910223644470"><p>最后再强调一下，在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受，即：“<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错</strong>”。接收端丢弃的帧虽然曾<strong>收到</strong>了，但最终还是因为有差错被丢弃，即没有被<strong>接受</strong>。以上所述的可以<strong>近似</strong>地表述为（通常都是这样认为）：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。请注意，我们现在并没有要求数据链路层向网络层提供“可靠传输”的服务。所谓“可靠传输”就是：数据链路层的发送端发送什么，在接收端就收到什么。传输差错可分为两大类：一类就是前面所说的最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。例如，发送方连续传送三个帧：[#1][#2][#3]。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：</p><ul><li>帧丢失：收到#1]-[#3]（丢失[#2]）。</li><li>帧重复：收到[#1]-[#2]-[#2]-[#3]（收到两个[#2]）。</li><li>帧失序：收到[#1]-[#3]-[#2]（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样)。</li></ul><p>以上三种情况都属于“<strong>出现传输差错</strong>”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。在学完运输层，我们就会知道在什么情况下接收端可能会出现帧重复或帧失序。总之，我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。</p><h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><h4 id="各字段的意义"><a href="#各字段的意义" class="headerlink" title="各字段的意义"></a>各字段的意义</h4><p>PPP的帧格式如图所示。PPP帧的首部和尾部分别为四个字段和两个字段。</p><p>首部的第一个字段和尾部的第二个字段都是标志字段F(Flag),规定为0x7E(符号“0x”表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是PPP帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃。</p><p>首部中的地址字段A规定为0xFF（即11111111），控制字段C规定为0x03（即00000011)。最初曾考虑以后再对这两个字段的值进行其他定义，但至今也没有给出。可见这两个字段实际上并没有携带PPP帧的信息。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913113344001.png" class="" title="image-20230913113344001"><p>PPP首部的第四个字段是2字节的协议字段。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0xC021,则信息字段是PPP链路控制协议LCP的数据，而0x8021表示这是网络层的控制数据。</p><p>信息字段的长度是可变的，不超过1500字节。尾部中的第一个字段(2字节)是使用CRC的帧检验序列FCS。</p><h4 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h4><p>当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。</p><p>当PPP使用异步传输时，它把转义符定义为0x7D(即01111101)，并使用字节填充，RFC1662规定了如下所述的填充方法：</p><ol><li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D,0x5E)。</li><li>若信息字段中出现一个0x7D的字节（即出现了和转义字符一样的比特组合），则把0x7D转变成为2字节序列(0x7D,0x5D)。</li><li>若信息字段中出现ASCI码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列(0x7D,0x23)。由于在发送端进行了字节填充，因此在链路上传送的信息字节数就超过了原来的信息字节数。但接收端在收到数据后再进行与发送端字节填充相反的变换，就可以正确地恢复出原来的信息。</li></ol><h4 id="比特零填充"><a href="#比特零填充" class="headerlink" title="比特零填充"></a>比特零填充</h4><p>PPP协议用在SONET&#x2F;SDH链路时，使用同步传输（一连串的比特连续传送）而不是异步传输（逐个字符地传送）。在这种情况下，PPP协议采用零比特填充方法来实现透明传输。零比特填充的具体做法是：在发送端，先扫描整个信息字段（通常用硬件实现，但也可用软件实现，只是会慢些)。只要发现有5个连续1，则立即填入一个0。因此经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流（如图3-11所示)。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913120324664.png" class="" title="image-20230913120324664"><h4 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h4><p>我们通过PPP帧的格式讨论了PPP帧是怎样组成的。但PPP链路一开始是怎样被初始化的？当用户拨号接入ISP后，就建立了一条从用户个人电脑到ISP的物理连接。这时，用户个人电脑向ISP发送一系列的链路视频讲解控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的P地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机了。</p><p>当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。上述过程可用如图所示的状态图来描述。</p><p>PPP链路的起始和终止状态永远是图中的“<strong>链路静止</strong>”(Link Dead)状态，这时在用户个人电脑和ISP的路由器之间并不存在物理层的连接。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913120728341.png" class="" title="image-20230913120728341"><p>当用户个人电脑通过调制解调器呼叫路由器时（通常是在屏幕上用鼠标点击一个连接按钮)，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP就进入“<strong>链路建立</strong>”(Link Establish)状态，其目的是建立链路层的LCP连接。</p><p>这时LCP开始协商一些配置选项，即发送LCP的配置请求帧(Configure-.Request)。这是个PPP帧，其协议字段置为LCP对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：</p><ol><li>配置确认帧(Configure-.Ack):所有选项都接受。</li><li>配置否认帧(Configure-.Nak):所有选项都理解但不能接受。</li><li>配置拒绝帧(Configure-.Reject):选项有的无法识别或不能接受，需要协商。</li></ol><p>LCP配置选项包括链路上的最大帧长、所使用的鉴别协议(Authentication Protocol)的规约（如果有的话），以及不使用PPP帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在PPP帧的首部中省略这两个字节)。</p><p>协商结束后双方就建立了LCP链路，接着就进入“<strong>鉴别</strong>”(Authenticate)状态。在这一状态，只允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用口令鉴别协议PAP(Password Authentication Protocol),则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的<strong>口令握手鉴别协议</strong>CHAP(Challenge-Handshake Authentication Protocol)。若鉴别身份失败，则转到“<strong>链路终止</strong>”(Link Terminate)状态。若鉴别成功，则进入“网络层协议”Network-LayerProtocol)状态。</p><p>在“网络层协议”状态，PPP链路两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信。</p><p>如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块（如分配IP地址)时就要使用NCP中支持IP的协议一IP控制协议IPCP(IP Control Protocol)。IPCP分组也封装成PPP帧（其中的协议字段为Ox8021)在PPP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和IP首部，以减少在链路上发送的比特数。</p><p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”(Link Open)状态。链路的两个PPP端点可以彼此向对方发送分组。两个PPP端点还可发送回送请求LCP分组(Echo-Request)和回送回答LCP分组(Echo-Reply),以检查链路的状态。数据传输结束后，可以由链路的一端发出终止请求LCP分组(Terminate-Request)请求终止链路连接，在收到对方发来的终止确认LCP分组(Terminate-Ack)后，转到“链路终止”状态。如果链路出现故障，也会从“链路打开”状态转到“链路终止”状态。当调制解调器的载波停止后，则回到“链路静止”状态。</p><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p>广播信道可以进行一对多的通信。下面要讨论的局域网使用的就是广播信道。局域网是在20世纪70年代末发展起来的。局域网技术在计算机网络中占有非常重要的地位。</p><h4 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h4><p>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。在局域网刚刚出现时，局域网比广域网具有较高的数据率、较低的时延和较小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率。</p><p>局域网具有如下的一些优点：</p><ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性(reliability)、可用性(availability)和生存性(survivability)。</li></ul><p>局域网可按网络拓扑进行分类。图a是星形网。由于集线器的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了非常广泛的应用。图(b)是环形网，图(c)为总线网，各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名，但以太网后来又演变成了星形网。经过四十多年的发展，以太网的速率已大大提高。现在最常用的以太网的速率是1Gbit&#x2F;s(家庭或中小企业)、10Gbit&#x2F;s(数据中心)和100Gbt&#x2F;s(长距离传输)，且其速率仍在继续提高。现在以太网已成为了局域网的同义词</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913122113630.png" class="" title="image-20230913122113630"><p>必须指出，局域网工作的层次跨越了数据链路层和物理层。由于局域网技术中有关数据链路层的内容比较丰富，因此我们就把局域网的内容放在数据链路层这一章中讨论。但这并不表示局域网仅仅和数据链路层有关。</p><p>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。这在技术上有两种方法：</p><ol><li>静态划分信道，如在第2章的2.4节中已经介绍过的频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用。</li><li>动态媒体接入控制，它又称为**多点接入(**multiple access),其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：</li></ol><ul><li>随机接入</li></ul><p>随机接入的特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突)，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</p><ul><li>受控接入</li></ul><p>受控接入的特点是用户不能随机地发送信息而必须服从一定的控制：这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询(polling),或称为轮询。</p><p>属于随机接入的以太网将被重点讨论。受控接入则由于目前在局域网中使用得较少，</p><p>由于以太网的数据率己演进到每秒吉比特甚至高达400吉比特，因此通常就用“传统以太网”来表示最早流行的10Mbt&#x2F;s速率的以太网。为了讨论原理，下面我们就从传统以太网开始。</p><h5 id="以太网的两个主要标准"><a href="#以太网的两个主要标准" class="headerlink" title="以太网的两个主要标准"></a>以太网的两个主要标准</h5><p>逻辑链路控制LLC(Logical Link Control)子层和媒体接入控制MAC(Medium Access Control)子层。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913123042264.png" class="" title="image-20230913123042264"><p>目前使用最多的局域网只剩下DIX Ethernet V2(简称为以太网)，而不是EEE802委员会制定的几种局域网。EEE802委员会制定的逻辑链路控制子层LLC(即IEEE802.2标准)的作用已经消失了，很多厂商生产的适配器上就仅装有MAC协议而没有LLC协议。本章在介绍以太网时就不再考虑LLC子层。这样对以太网工作原理的讨论会更加简洁。</p><h5 id="适配器的作用"><a href="#适配器的作用" class="headerlink" title="适配器的作用"></a>适配器的作用</h5><p>计算机与外界局域网的连接是通过适配器(adapter)。适配器本来是在主机箱内插入的块网络接口板（或者是在笔记本电脑中插入一块PCMCIA卡一个人计算机存储器卡接口适配器)。这种接口板又称为网络接口卡NIC (Network Interface Card)或简称为“网卡”。由于现在计算机主板上都已经嵌入了这种适配器，不再使用单独的网卡了，因此本书使用适配器这个更准确的术语。在这种通信适配器上面装有处理器和存储器（包括RAM和ROM)。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的&#x2F;O总线以并行传输方式进行的。因此，适配器的一个重要功能就是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。适配器还要能够实现以太网协议。</p><p>适配器在接收和发送各种帧时，不使用计算机的CPU。这时计算机中的CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。图3-15表示适配器的作用。我们特别要注意，计算机的硬件地址（在本章的3.3.5节讨论）就在适配器的ROM中，而计算机的软件地址一P地址（在第4章讨论），则在计算机的存储器中。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913123512657.png" class="" title="image-20230913123512657"><h4 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><p>总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。这种就是广播通信方式。但我们并不总是要在局域网上进行一对多的广播通信。为了在总线上实现一对一的通信，可以使每一台计算机的适配器都拥有一个与其他适配器都不同的地址。在发送数据帧时，在帧的首部写明接收站的地址。现在的电子技术可以很容易做到：仅当数据帧中的目的地址与适配器ROM中存放的硬件地址一致时，该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧就丢弃。这样，具有广播特性的总线上就实现了一对一的通信。</p><p>人们也常把局域网上的计算机称为<strong>“主机</strong>”“<strong>工作站</strong>”“<strong>站点</strong>”或“<strong>站</strong>”。在本书中，这几个名词都可以当成是同义词。</p><p>为了通信的简便，以太网采取了以下两种措施：</p><p>第一，采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，以太网提供的服务是尽最大努力的交付，即不可靠的交付。当目的站收到有差错的数据帧时(例如，用CRC查出有差错)，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来决定。例如，如果高层使用TCP协议，那么TCP就会发现丢失了一些数据。于是经过一定的时间后，TCP就把这些数据重新传递给以太网进行重传。但以太网并不知道这是重传帧，而是当作新的数据帧来发送。</p><p>我们知道，总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。以太网采用最简单的随机接入，但有很好的协议用来减少冲突发生的概率。这好比有一屋子的人在开讨论会，没有会议主持人控制发言。想发言的随时可发言，不需要举手示意。但我们还必须有个协议来协调大家的发言。这就是：如果你听见有人在发言，那么你就必须等别人讲完了才能发言（否则就干扰了别人的发言）。但有时碰巧两个或更多的人同时发言了，那么一旦发现冲突，大家都必须立即停止发言，等听到没有人发言了你再发言。以太网采用的协调方法和上面的办法非常像，<strong>它使用的协议是CSMA&#x2F;CD,意思是载波监听多点接入&#x2F;碰撞检测(Carrier Sense Multiple Access with Collision Detection)。</strong></p><p>第二，以太网发送的数据都使用曼彻斯特Manchester)编码的信号。我们在第2章的2.2.2节中已经简单地介绍过曼彻斯特编码了。我们知道，二进制基带数字信号通常就是高、低电压交替出现的信号。使用这种信号的最大问题就是当出现一长串连续的1或连续的0时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。如图3-16所示，曼彻斯特编码的编码方法是把每一个码元再分成两个相等的间隔。码元1是前一个间隔为低电压而后一个间隔为高电压。码元0则正好相反，从高电压变到低电压（也可采用相反的约定，即1是“前高后低”而0是“前低后高”)。这样就保证了在每一个比特的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来。但是从曼彻斯特编码的波形图也不难看出其缺点，这就是它所占的频带宽度比原始的基带信号增加了一倍(因为每秒传送的码元数加倍了)。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913124141451.png" class="" title="image-20230913124141451"><p>“<strong>多点接入</strong>”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。</p><p><strong>“载波监听</strong>”也就是“边发送边监听”。这里必须指出，在通信领域，在大多数情况下，Carrier的标准译名是“载波”。但对于以太网，总线上根本没有什么“载波”。其实英语Carrier有多种意思，如“承运器”“传导管”或“运载工具”等。因此在以太网中，把Carrier译为“载体”或“媒体”可能更加准确些。考虑到“载波”这个译名已经在我国广泛流行了好几十年，本书也就继续使用这个不准确的译名。我们知道，载波监听就是不管在想要发送数据之前，还是在发送数据之中，每个站都必须不停地检测信道。在发送前检测信道，是为了避免冲突。如果检测出已经有其他站在发送，则本站就暂时不要发送数据。在发送中检测信道，是为了及时发现如果有其他站也在发送，就立即中断本站的发送。这就称为碰撞检测。</p><p>“<strong>碰撞检测</strong>”是适配器边发送数据边检测信道上的信号电压的变化情况。当两个或几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加）。当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。这时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。因此，任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器就要立即停止发送，免得继续进行无效的发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</p><p>图所示的例子可以说明这种情况。设图中的局域网两端的站A和B相距1k,用同轴电缆相连。电磁波在1k电缆的传播时延约为5us(这个数字应当记住)。因此，A向B发出的数据，在约5s后才能传送到B。换言之，B若在A发送的数据到达B之前发送自己的帧（因为这时B的载波监听检测不到A所发送的信息），则必然要在某个时间和A发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的单程端到端传播时延记为x。发送数据的站希望尽早知道是否发生了碰撞。那么，A发送数据后，最迟要经过多长时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞？从图不难看出，这个时间最多是两倍的总线端到端的传播时延(2)，或总线的端到端往返传播时延。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延（这两个站之间的距离最大）为端到端传播时延。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230913125033086.png" class="" title="image-20230913125033086"><p>显然，在使用CSMA&#x2F;CD协议时，一个站不可能同时进行发送和接收（但必须边发送边监听信道)。因此使用CSMA&#x2F;CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工通信）。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230914172406680.png" class="" title="image-20230914172406680"><p>由此可见，每一个站在自己发送<strong>数据之后的一小段时间内</strong>，<strong>存在着遭遇碰撞的可能性</strong>。这一小段时间是不确定的，它取决于另一个发送数据的站到本站的距离。因此，以太网不能保证在检测到信道空闲后的某一时间内，一定能够把自己的数据帧成功地发送出去（因为存在产生碰撞的可能)。以太网的这一特点称为发送的不确定性。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</p><p>从图可看出，最先发送数据帧的A站，在发送数据帧后至多经过时间2t他就可知道所发送的数据帧是否遭受了碰撞。这就是δ→0的情况。因此以太网的端到端往返时间2t称为<strong>争用期</strong>(contention period),它是一个很重要的参数。争用期又称为碰撞窗口(collisionwindow)。这是因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</p><h6 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a><strong>截断二进制指数退避</strong>算法</h6><p>以太网使用<strong>截断二进制指数退避</strong>(truncated binary exponential backoff)算法来确定碰撞后重传的时机。截断二进制指数退避算法并不复杂。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是退避一个随机的时间。这点很容易理解，因为几个发生碰撞的站将会同时检测到信道变成了空闲。如果大家都同时重传，必然接连发生碰撞。如果采用退避算法，生成了最小退避时间的站将最先获发送权。以后其余的站的退避时间到了，但发送数据之前监听到信道忙，就不会马上发送数据了。</p><p>为了尽可能减小重传时再次发生冲突的概率，退避算法有如下具体的规定：</p><ul><li>基本退避时间为争用期2t,具体的争用期时间是51.2us。对于10Mbit&#x2F;s以太网，在争用期内可发送512比特，即64字节。也可以说争用期是512比特时间。1比特时间就是发送1比特所需的时间。所以这种时间单位与数据率密切相关。为了方便，也可以直接使用比特作为争用期的单位。争用期是512比特，即争用期是发送512比特所需的时间。</li><li>从离散的整数集合[0,1，…，(2^k^-1)]中随机取出一个数，记为r。重传应推后的时间就是r倍的争用期。上面的参数k按下面的公式计算：k&#x3D;Min[重传次数，10]可见当重传次数不超过10时，参数k等于重传次数：但当重传次数超过10时，k就不再增大而一直等于10。</li><li>当重传达16次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突)，则丢弃该帧，并向高层报告。例如，在第1次重传时，k&#x3D;1,随机数r从整数0,1}中选一个数。因此重传的站可选择的重传推迟时间是0或2π，在这两个时间中随机选择一个。若再发生碰撞，则在第2次重传时，k&#x3D;2,随机数r就从整数0,1,2,3}中选一个数。因此重传推迟的时间是在0.2x,4x和6x这4个时间中随机地选取一个。若再发生碰撞，则在第2次重传时，k&#x3D;2,随机数r就从整数0,1,2,3}中选一个数。因此重传推迟的时间是在0,2x,4x和6x这4个时间中随机地选取一个。同样，若再发生碰撞，则重传时k&#x3D;3,随机数r就从整数0,1,2,3,4,5,6,7}中选一个数。依此类推。若连续多次发生冲突，就表明可能有较多的站参与争用信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为<strong>动态退避</strong>），因而减小发生碰撞的概率，有利于整个系统的稳定。</li></ul><p>下面介绍<strong>强化碰撞</strong>的概念。这就是当发送数据的站一旦发现发生了碰撞时，除立即停止发送数据外，还要再继续发送32比特或48比特的人为干扰信号(jamming signal),以便让所有用户都知道现在已经发生了碰撞（对于10Mbit&#x2F;s以太网，发送32或48)比特只需要3.2（或4.8）μs。</p><p>根据以上所讨论的，可以把CSMA&#x2F;CD协议的要点归纳如下：</p><ul><li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部（见后面的3.4.3节)，组成以太网帧，放入适配器的缓存中。但在发送之前，必须先检测信道。</li><li>检测信道：若检测到信道忙，则继续不停地检测，一直等待信道转为空闲。此时若在96比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li><li>在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可<br>能性：<ul><li>发送成功：<br>如果在争用期内一直未检测到碰撞，就认为发送成功（如果接收方收到了有差错的帧，就丢弃它，后续的工作由高层来处理)。发送完毕后，其他什么也不做。然后回到(1)。</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待r倍512比特时间后，返回到步骤(2)，继续检测信道。但若重传达16次仍不能成功，则停止重传而向上报错。以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</li></ul></li></ul><h4 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h4><p>传统以太网最初使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫作**集线器(**hub),</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230917230121908.png" class="" title="image-20230917230121908"><p>集线器的一些特点如下：</p><ul><li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。也就是说，<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA&#x2F;CD协议</strong>（更具体些说，是各站中的适配器执行CSMA&#x2F;CD协议）。网络中的各站必须竞争对传输媒体的控制，<strong>并且在同一时刻至多只允许一个站发送数据。</strong></li><li>一个集线器有许多端口①，例如，8至16个，每个端口通过RJ-45插头（与电话机使用的插头RJ-11相似，但略大一些)用两对双绞线与一台计算机上的适配器相连（这种插座可连接4对双绞线，实际上只用2对，即发送和接收各使用一对双绞线)。因此，<strong>一个集线器很像一个多端口的转发器。</strong></li><li><strong>集线器工作在物理层</strong>，它的每个端口仅仅简单地转发比特收到1就转发1，收到0就转发0，不进行碰撞检测。若两个端口同时有信号输入（即发生碰撞），那么所有的端口都将收不到正确的帧。图3-20是具有三个端口的集线器的示意图。</li><li>集线器采用了专门的芯片，进行自适应串音回波抵消。这样就可使端口转发出去的较强信号不致对该端口接收到的较弱信号产生干扰（这种干扰即近端串音）。每个比特在转发之前还要进行再生整形并重新定时。</li></ul><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230917230313131.png" class="" title="image-20230917230313131"><p>集线器本身必须非常可靠。现在的堆叠式(stackable)集线器由4~8个集线器堆叠起来使用。集线器一般都有少量的容错能力和网络管理功能。例如，假定在以太网中有一个适配器出了故障，不停地发送以太网帧。这时，集线器可以检测到这个问题，在内部断开与出故障的适配器的连线，使整个以太网仍然能够正常工作。模块化的机箱式智能集线器有很高的可靠性。它全部的网络功能都以模块方式实现。各模块均可进行热插拔，出故障时不断电即可更换或增加新模块。集线器上的指示灯还可显示网络上的故障情况，给网络的管理带来了很大的方便。</p><h4 id="以太网的利用率"><a href="#以太网的利用率" class="headerlink" title="以太网的利用率"></a>以太网的利用率</h4><p>下面我们讨论一下以太网的信道利用率。<br>假定一个10Mbt&#x2F;s以太网同时有10个站在工作，那么每一个站所能发送数据的平均速率似乎应当是总数据率的1&#x2F;10（即1Mbit&#x2F;s)。其实不然，因为多个站在以太网上同时工作就可能会发生碰撞。当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到100%。</p><p>图的例子是以太网的信道被占用的情况。一个站在发送帧时出现了碰撞。经过一个争用期2t后（t是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站就发送成功了。假定发送帧需要的时间是T<del>0</del>。它等于帧长(bit)除以发送速率(10Mbit&#x2F;s)。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918131512337.png" class="" title="image-20230918131512337"><p>我们应当注意到，成功发送一个帧需要占用信道的时间是T<del>0</del>+t,比这个帧的发送时间要多一个单程端到端时延t。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是t。因此，必须在经过时间T。+后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p><p>从可看出，要提高以太网的信道利用率，就必须减小t与T<del>0</del>之比。在以太网中定义了参数α，它是以太网单程端到端时延t与帧的发送时间T<del>0</del>之比：</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918131741603.png" class="" title="image-20230918131741603"><p>当α→0时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数α越大，表明争用期所占的比例越大，这就使得每发生一次碰撞就浪费了不少的信道资源，使得信道利用率明显降低。因此，以太网的参数α的值应当尽可能小些。从式可看出，这就要求式分子的数值要小些，而分母T<del>0</del>的数值要大些。这就是说，当数据率一定时，以太网的连线的长度受到限制（否则的数值会太大)，同时以太网的帧长不能太短（否则T<del>0</del>的值会太小，使α值太大）。</p><p>现在考虑一种理想化的情况。假定以太网上的各站发送数据都不会产生碰撞（这显然已经不是CSMA&#x2F;CD,而是需要使用一种特殊的调度方法)，并且能够非常有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是T<del>0</del>+t,而帧本身的发送时间是<del>0</del>。于是我们可计算出极限信道利用率S<del>max</del>为：</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918132017910.png" class="" title="image-20230918132017910"><p>式的意义是：虽然实际的以太网不可能有这样高的极限信道利用率，但式指出了只有当参数α远小于1才能得到尽可能高的极限信道利用率。反之，若参数α远大于1(即每发生一次碰撞，就要浪费相对较多的传输数据的时间)，则极限信道利用率就远小于1,而这时实际的信道利用率就更小了。据统计，当以太网的利用率达到30%时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p><h4 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h4><h5 id="MAC层的硬件地址"><a href="#MAC层的硬件地址" class="headerlink" title="MAC层的硬件地址"></a>MAC层的硬件地址</h5><p>在局域网中，硬件地址又称为物理地址或MAC地址（因为这种地址用在MAC帧中)。</p><p>大家知道，在所有计算机系统的设计中，标识系统(identification system)都是一个核心问题。在标识系统中，地址就是识别某个系统的一个非常重要的标识符。在讨论地址问题时，很多人常常引用著名文献SHOC78给出的如下定义：“<strong>名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处</strong>。”</p><p>这个非形式的定义固然很简单，但有时却不够准确。严格地讲，名字应当与系统的所在地无关。这就像我们每一个人的名字一样，不随我们所处的地点而改变。为此EEE802标准为局域网规定了一种48位的全球地址（一般都简称为“地址”），这就是局域网上的每一台计算机中固化在适配器的ROM中的地址。因此，请特别注意下面两点：</p><ul><li>假定连接在局域网上的一台计算机的适配器坏了而我们更换了一个新的适配器，那么这台计算机的局域网的“地址”也就改变了，虽然这台计算机的地理位置一点也没有变化，所接入的局域网也没有任何改变。</li><li>假定我们把位于南京的某局域网上的一台笔记本电脑携带到北京，并连接在北京的某局域网上。虽然这台电脑的地理位置改变了，但只要电脑中的适配器不变，那么该电脑在北京的局域网中的“地址”仍然和它在南京的局域网中的“地址”一样。</li></ul><p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。我们知道适配器有过滤功能。当适配器从网络上每收到一个MAC帧就先用硬件检查MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源了。这里“发往本站的帧”包括以下三种帧：</p><ul><li>单播(unicast)帧（一对一），即收到的帧的MAC地址与本站的MAC地址相同。</li><li>广播(broadcast)帧（一对全体），即发送给本局域网上所有站点的帧（全1地址）。</li><li>多播(multicast)帧（一对多），即发送给本局域网上一部分站点的帧。</li></ul><p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p><h5 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h5><p>这里介绍使用得最多的以太网V2的MAC帧格式，图中假定网络层使用的是IP协议。实际上使用其他的协议也是可以的。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918133325777.png" class="" title="image-20230918133325777"><p>以太网V2的MAC帧较为简单，由五个字段组成。前两个字段分别为6字节长的<strong>目的地址和源地址字段</strong>。第三个字段是2字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。例如，当类型字段的值是0x0800时，就表示上层使用的是IP数据报。第四个字段是<strong>数据字段</strong>，其长度在46到1500字节之间(46字节是这样得出的：最小长度64字节减去18字节的首部和尾部就得出数据字段的最小长度)。最后一个字段是4字节的**帧检验序列FCS(使用CRC检验)**。当传输媒体的误码率为1×10^-8^时，MAC子层可使未检测到的差错小于1×10^-14^。FCS检验的范围就是整个的MAC帧，从目的地址开始到FCS为止的这五个字段，但不包括物理层插入的8字节的前同步码和帧开始定界符。</p><p>从图可看出，在传输媒体上实际传送的要比MAC帧还多8个字节。这是因为当一个站在刚开始接收MAC帧时，由于适配器的时钟尚未与到达的比特流达成同步，因此MAC帧的最前面的若干位就无法接收，结果使整个的MAC成为无用的帧。为了接收端迅速实现位同步，从MAC子层向下传到物理层时还要在帧的前面插入8个字节（由硬件生成)，它由两个字段构成。第一个字段是7个字节的<strong>前同步码</strong>(1和0交替码)，它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现位同步”（位同步就是比特同步的意思）。第二个字段是<strong>帧开始定界符</strong>，定义为10101011。它的前六位的作用和前同步码一样，最后的两个连续的1就是告诉接收端适配器：“MAC帧的信息马上就要来了，请适配器注意接收。”MAC帧的FCS字段的检验范围不包括前同步码和帧开始定界符。顺便指出，在使用SONET&#x2F;SDH进行同步传输时则不需要用前同步码，因为在同步传输时收发双方的位同步总是一直保持着的。</p><p>IEEE802.3标准规定凡出现下列情况之一的即为无效的MAC帧：</p><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列FCS查出有差错</li><li>收到的帧的MAC客户数据字段的长度不在46-1500字节之间。考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间。对于检查出的无效MAC帧就简单地丢弃。以太网不负责重传丢弃的帧。</li></ul><h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><h4 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h4><p>扩展以太网更常用的方法是在数据链路层进行的。最初人们使用的是网桥(bridge)。网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，并不是向所有的端口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个端口，或者是把它丢弃(即过滤)。</p><p>1990年问世的交换式集线器(switching hub),很快就淘汰了网桥。交换式集线器常称为<strong>以太网交换机</strong>(switch)或第二层交换机(L2 switch),强调这种交换机工作在数据链路层。“交换机”并无准确的定义和明确的概念。著名网络专家Perlman认为：“交换机”应当是一个市场名词，而交换机的出现的确使数据的转发更加快速了[PERLO0]。本书也使用这个广泛被接受的名词一以太网交换机。下面简单地介绍以太网交换机的特点。</p><h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><p>以太网交换机实质上就是一个<strong>多端口的网桥</strong>，通常都有十几个或更多的端口，和工作在物理层的转发器、集线器有很大的差别。以太网交换机的每个端口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在<strong>全双工方式</strong>。以太网交换机还具有并行性，即能同时连通多对端口，使多对主机能同时通信（而网桥只能一次分析和转发一个帧）。相互通信的主机都独<strong>占传输媒体，无碰撞地传输数据</strong>。换句话说，每一个端口和连接到端口的主机构成了一个碰撞域，具有N个端口的以太网交换机的碰撞域共有N个。以太网交换机的端口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。因此，如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的端口繁忙时，发送帧的这两台主机的端口会把收到的帧暂存一下，以后再发送出去。</p><p>以太网交换机是一种即插即用设备，其内部的<strong>帧交换表（又称为地址表）</strong>是通过自<strong>学习算法</strong>自动地逐渐建立起来的。实际上，这种交换表就是一个<strong>内容可寻址存储器</strong>CAM(Content Addressable Memory)。以太网交换机由于使用了专用的交换结构芯片，用硬件转发收到的帧，其转发速率要比使用软件转发的网桥快很多。</p><h5 id="以太网交换机的自学功能"><a href="#以太网交换机的自学功能" class="headerlink" title="以太网交换机的自学功能"></a>以太网交换机的自学功能</h5><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918134848441.png" class="" title="image-20230918134848441"><p>假定在图中的以太网交换机有4个端口，各连接一台计算机，其MAC地址分别是A,B,C和D。交换表最重要的就是两个项目：目的MAC地址和转发端口。在一开始，以太网交换机里面的交换表是空的（如图(a)所示）。</p><p>假定A先向B发送一帧，从端口1进入到交换机。交换机收到帧后，先查找交换表。现在表中没有B的地址。于是，交换机把此帧的源地址A和端口1写入交换表中，并向除端口1以外的所有端口广播这个帧（从端口1收到的帧显然不应再从端口1转发出去）广播发送可以保证让B收到这个帧，而C和D在收到帧后，因目的地址不匹配将丢弃此帧。这一过程也称为过滤。</p><p>由于在交换表中写入了项目(A,1),因此以后不管从哪个端口收到帧，只要其目的地址是A,就把收到的帧从端口1转发出去送交A。这样做的依据是：既然A发送的帧是从端口1进入交换机的，那么从端口1转发出的帧肯定到达A。接下来假定B通过端口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A,表明凡是发给A的帧（即目的地址为A的帧）都应从端口1转发。显然，现在应直接把收到的帧从端口1转发给A,而没有必要再广播收到的帧。交换表这时用源地址B写入一个项目B,3),表明今后如有发送给B的帧，应从端口3转发。</p><p>经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的端口号(2或4)写入交换表中。这样，交换表中的项目就逐渐增多了，以后再转发帧时就可以直接从交换表中找到转发的端口，而不必使用发送广播帧</p><p>考虑到有时可能要在交换机的端口更换主机，或者主机要更换其网络适配器，这就需要及时更改交换表中的项目。为此，当交换表中写入一个项目时就记下当时的时间，只要超过预先设定的时间（例如300秒），该项目就自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。这就是说，图3-25中的交换表实际上是有三列，即MAC地址、端口和写入时间。</p><p>但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。</p><p>为了解决这种兜圈子问题，IEEE的802.lD标准制定了一个生成树协议STP(SpanningTree Protocol)。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>首先，一个以太网是一个广播域。在以太网上经常会出现大量的广播帧。在交换机的交换表的建立过程中要使用许多广播帧。我们经常使用的ARP和DHCP协议（这将在后面两章中讲到)，也都要在以太网中传送很多的广播帧。在一个主机数量很大的以太网上传播广播帧，必然会消耗很多的网络资源。如果网络的配置出了些差错，就有可能发生广播帧在网络中无限制地兜圈子（如图3-26所示那样)，形成了“广播风暴”，使整个的网络瘫痪。</p><p>如果使每一个小部门各拥有自己的较小的局域网，那么这不但可使局域网的广播域范围缩小，同时也提高了局域网的安全性。在以太网交换机出现后，我们可以很方便灵活地建立虚拟局域网VLAN(Virtual LAN)。这样就把一个较大的局域网，分割成为一些较小的局域网，而每一个局域网是一个较小的广播域。</p><p>在IEEE802.1Q标准中，对虚拟局域网VLAN是这样定义的：虚拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918140522713.png" class="" title="image-20230918140522713"><p>这样的802.1Q帧在什么地方使用呢？我们可以用图给出的简单例子来说明。交换机#1连接了7台计算机，组成了一个局域网（一个广播域）。现在把局域网分为两个虚拟局域网VLAN-10和VLAN-20。这里的10和20是虚拟局域网的编号，由交换机管理人员设定。这个编号就是图3-27中的VID字段的值。</p><img src="/2023/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/image-20230918140858704.png" class="" title="image-20230918140858704"><p>现在我们有了两个较小的广播域。每台计算机都是通过接入<strong>链路</strong>(access link)连接到以太网交换机的。管理人员划分虚拟局域网的方法有多种。例如，按交换机的端口划分，或按MAC地址划分。每台主机并不知道自己的VID值（但交换机必须知道这些信息）。这些主机通过接入链路发送到交换机的帧都是标准的以太网帧。在一个用多个交换机连接起来的较大的局域网中，可以灵活地划分虚拟局域网，不受地理位置的限制。一个虚拟局域网的范围可以跨越不同的交换机。当然，所使用的交换机必须要能够识别和处理虚拟局域网。在图中，在另外一层楼的交换机#2连接了5台计算机，并与交换机#1相连接。交换机#2中的两台计算机加入到VLAN-10,而另外3台加入到VLAN-20。</p><p>这两个虚拟局域网虽然都跨越了两个交换机，但都各自是一个广播域。连接两个交换机端口之间的链路称为汇<strong>聚链路(trunk link)或干线链路</strong>。</p><p>现在假定A向B发送帧。由于交换机#1能够根据帧首部的目的MAC地址，识别B属于本交换机管理的VLAN-10,因此就像在普通以太网中那样直接进行帧的转发，不需要使用VLAN标签。这是最简单的情况。现在假定A向E发送帧。交换机#1查到E并没有连接到本交换机，因此必须从汇聚链路把帧转发到交换机2，但在转发之前，要插入VLAN标签。不插入VLAN标签，交换机#2就不知道应把帧转发给哪一个VLAN。因此在汇聚链路传送的帧是802.1Q帧。交换机#2在向E转发帧之前，要拿走已插入的VLAN标签，因此E收到的帧就是A发送的标准以太网帧，而不是802.1Q帧。图说明了这种情况。如果A向C发送帧，情况又怎样呢？这种情况就复杂些了，因为这是在不同网络之间的通信。虽然A和C都连接到同一个交换机，但它们已经处在不同的网络中(VLAN-10和VLAN-20)。这问题是互连网络中的通信问题，已经超过了本章数据链路层的范围。这要由属于上面的网络层中的路由器来解决。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层(二)</title>
    <link href="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章首先讨论物理层的基本概念。然后介绍有关数据通信的重要概念，以及各种传输媒体的主要特点，但传输媒体本身并不属于物理层的范围。在讨论几种常用的信道复用技术后，对数字传输系统进行简单介绍。最后再讨论几种常用的宽带接入技术。</p><span id="more"></span><h3 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p>首先要强调指出，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。大家知道，现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么。用于物理层的协议也常称为物理层<strong>规程</strong>（procedure)。其实物理层规程就是物理层协议。只是在“协议”这个名词出现之前人们就先使用了“规程”这一名词。</p><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：</p><ul><li>机械特性</li></ul><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。平时常见的各种规格的接插件都有严格的标准化的规定。</p><ul><li>电气特性</li></ul><p>指明在接口电缆的各条线上出现的电压的范围。</p><ul><li>功能特性</li></ul><p>指明某条线上出现的某一电平的电压的意义。</p><ul><li>过程特性</li></ul><p>指明对于不同功能的各种可能事件的出现顺序。</p><p>大家知道，数据在计算机内部多采用并行传输方式。但数据在通信线路（传输媒体）上的传输方式一般都是串行传输（这是出于经济上的考虑），即逐个比特按照时间顺序传输。因此物理层还要完成传输方式的转换。具体的物理层协议种类较多。这是因为物理连接的方式很多（例如，可以是点对点的，也可以采用多点连接或广播连接)，而传输媒体的种类也非常之多（如架空明线、双绞线、对称电缆、同轴电缆、光缆，以及各种波段的无线信道等)。因此在学习物理层时，应将重占放在堂据其本概念上。</p><h3 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h3><h5 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h5><p>一个数据通信系统可划分为三大部分，即源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908132617208.png" class="" title="image-20230908132617208"><p>源系统一般包括以下两个部分：</p><ul><li>源点(source)源点设备产生要传输的数据，例如，从计算机的键盘输入汉字，计算机产生输出的数字比特流。源点又称为源站或信源。</li><li>发送器通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。现在很多计算机使用内置的调制解调器（包含调制器和解调器)，用户在计算机外面看不见调制解调器。</li></ul><p>目的系统一般也包括以下两个部分：</p><ul><li>接收器接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li>终点(destination)终点设备从接收器获取传送来的数字比特流，然后把信息输出(例如，把汉字在计算机屏幕上显示出来)。终点又称为目的站或信宿。</li></ul><p>在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统。</p><p>下面我们先介绍一些常用术语</p><p>通信的目的是传送<strong>消息</strong>(message)。话音、文字、图像、视频等都是消息。<strong>数据</strong>(data)是运送消息的实体。根据<strong>RFC4949</strong>给出的定义，数据是使用特定方式表示的信息，通常是有意义的符号序列。这种信息的表示可用计算机或其他机器（或人）处理或产生。<strong>信号</strong>(signal)则是数据的电气或电磁的表现。</p><p>根据信号中代表消息的参数的取值方式不同，信号可分为以下两大类：</p><ul><li>模拟信号，或连续信号——代表消息的参数的取值是连续的。例如在上图中，用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。</li><li>数字信号，或离散信号——代表消息的参数的取值是离散的。例如在上图中，用户家中的计算机到调制解调器之间或在电话网中继线上传送的就是数字信号。在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一种代表1状态。</li></ul><h5 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h5><p>在许多情况下，我们要使用“<strong>信道</strong>(channel)”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条<strong>通信电路</strong>往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li>单向通信</li></ul><p>又称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>线电广播或有线电广播以及电视广播就属于这种类型。</p><ul><li>双向交替通信</li></ul><p>又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式是一方发送另一方接收，过一段时间后可以再反过来。</p><ul><li>双向同时通信</li></ul><p>又称为全双工通信，即通信的双方可以同时发送和接收信息。单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道（每个方向各一条)。显然，双向同时通信的传输效率最高。</p><p>这里注意，有时人们也常用<strong>“单工</strong>”这个名词表示“<strong>双向交替通信</strong>”。如常说的“单工电台”并不是只能进行单向通信。正因为如此，ITU-T才不采用“单工”“半双工”和“全双工”这些容易弄混的术语作为正式的名词。来自信源的信号常称为<strong>基带信号</strong>（即基本频带信号）。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含较多的低频分量，甚至有直流分量，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带<strong>信号进行调制</strong>(modulation)。</p><p>调制可分为两大类。一类是仅仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为<strong>编码</strong>(coding)。另一类调制则需要使用载波(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>(即仅在一段频率范围内能够通过信道)，而使用载波的调制称为<strong>带通调制</strong>。</p><h6 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h6><ul><li><p>不归零制：正电平代表1，负电平代表0。</p></li><li><p>归零制：正脉冲代表1，负脉冲代表0。</p></li><li><p>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。但也可反过来定义。</p></li><li><p>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</p></li></ul><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908134543743.png" class="" title="image-20230908134543743"><p>从信号波形中可以看出，曼彻斯特(Manchester)编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力)，而曼彻斯特编码具有自同步能力。</p><h6 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h6><ul><li>调幅(AM)：即载波的振幅随基带数字信号而变化。例如，0或1分别对应于无载波或有载波输出。</li><li>调频(FM)：即载波的频率随基带数字信号而变化。例如，0或1分别对应于频率f1或f2。</li><li>调相(PM)：即载波的初始相位随基带数字信号而变化。例如，0或1分别对应于相位0度或180度。</li></ul><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908135030466.png" class="" title="image-20230908135030466"><p>为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。例如，正交振幅调制QAM(Quadrature Amplitude Modulation)。</p><h5 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h5><p>几十年来，通信领域的学者一直在努力寻找提高数据传输速率的途径这个问题很复杂，因为任何实际的信道都不是理想的，都不可能以任意高的速率进行传送。我们知道，数字通信的优点就是：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要我们从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就可视为无影响。例如，图a表示信号通过实际的信道传输后虽然有失真，但在接收端还可识别并恢复出原来的码元。但图b就不同了，这时信号的失真已很严重，在接收端无法识别码元是1还是0。码元传输的速率越高、信号传输的距离越远、噪声干扰越大或传输媒体质量越差，在接收端的波形的失真就越严重。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908135730608.png" class="" title="image-20230908135730608"><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个。</p><ul><li>信道能够通过的频率范围</li></ul><p>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。像上图所示的发送信号是一种典型的矩形脉冲信号，它包含很丰富的高频分量。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。这样，在接收端收到的信号波形就失去了码元之间的清晰界限。这种现象叫作码间串扰。严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。早在1924年，奈奎斯特(Nyquist)就推导出了著名的<strong>奈氏准则</strong>。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。奈氏准则的推导已超出本书的范围，这可在通信原理教科书中查阅到。这里我们只需要知道奈氏准则的结论，这就是：<strong>在带宽为W(Hz)的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W(码元&#x2F;秒)。传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别)成为不可能。</strong>例如，信道的带宽为4000Hz,那么最高码元传输速率就是每秒8000个码元。</p><ul><li>信噪比</li></ul><p>噪声存在于所有的电子设备和通信信道中。由于噪声是随机产生的，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误(1误判为0或0误判为1)。但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。因此，信噪比就很重要。所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为<strong>S&#x2F;N</strong>。但通常大家都是使用分贝(dB)作为度量单位。即：<br>$$<br>信噪比(dB)&#x3D;10 log_{10}(S&#x2F;N)(dB)<br>$$<br>在1948年，信息论的创始人<strong>香农(<strong>Shannon)推导出了著名的香农公式。香农公式指出：</strong>信道的极限信息传输速率C</strong>是<br>$$<br>C&#x3D;Wlog_2(1+S&#x2F;N)(bit&#x2F;s)<br>$$<br>式中，W为信道的带宽（以Hz为单位），S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。香农公式的推导可在通信原理教科书中找到。这里只给出其结果。</p><p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。香农公式指出了信息传输速率的上限。香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。不过，香农没有告诉我们具体的实现方法。这要由研究通信的专家去寻找。<br>从以上所讲的不难看出，对于频带宽度已确定的信道，如果信噪比也不能再提高了，并且码元传输速率也达到了上限值，那么还有什么办法提高信息的传输速率呢？这就是用编码的方法让<strong>每一个码元携带更多比特的信息量</strong>。</p><h3 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h3><p><strong>传输媒体</strong>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即<strong>导引型传输媒体</strong>和非导引型传输媒体（这里的“导引型”的英文就是guided,.也可译为“导向传输媒体”)。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播：而非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。</p><h5 id="引导下传输媒体"><a href="#引导下传输媒体" class="headerlink" title="引导下传输媒体"></a>引导下传输媒体</h5><ul><li>双绞线</li></ul><p>双绞线也称为双扭线，是最古老但又是最常用的传输媒体。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合(ws)起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。使用双绞线最多的地方就是到处都有的电话系统。几乎所有的电话都用双绞线连接到电话交换机。这段从用户电话机到交换机的双绞线称为<strong>用户线</strong>或用<strong>户环路</strong>(subscriberloop)。通常将一定数量的这种双绞线捆成电缆，在其外面包上护套。现在的以太网（主流的计算机局域网)基本上也是使用各种类型的双绞线电缆进行连接的。</p><p><strong>无屏蔽双绞线UTP</strong>(Unshielded Twisted Pair)的价格较便宜。当数据的传送速率增高时，可以采用屏蔽双绞线(Shielded Twisted Pair,简称为STP)。</p><ul><li>同轴电缆</li></ul><p>同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及绝缘保护套层所组成。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p><ul><li>光纤</li></ul><p>从20世纪70年代到现在，通信和计算机都发展得非常快。据统计，计算机的运行速度大约每10年提高10倍。在通信领域里，信息的传输速率则提高得更快，从20世纪70年代的56kbit&#x2F;s(使用铜线)提高到现在的数百Gbit&#x2F;s(使用光纤)，并且这个速率还在继续提高。因此，光纤通信成为现代通信技术中的一个十分重要的领域。</p><p>光纤通信就是利用光导纤维（以下简称为光纤）传递光脉冲来进行通信的。有光脉冲相当于1，而没有光脉冲相当于0。由于可见光的频率非常高，约为108MHz的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤的优点，而且还具有其他的一些特点：</p><ul><li>具有通信容量非常大</li><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在现有电缆管道已拥塞不堪的情况下特别有利。</li></ul><h5 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h5><p>无线传输可使用的频段很广。从前面给出的图以看出，人们现在已经利用了好几个波段进行通信。紫外线和更高的波段目前还不能用于通信。图2-5的最下面一行还给出了ITU对波段取的正式名称。例如，LF波段的波长是从1km-10km(对应于30kHz-300kHz)。LF,MF和HF的中文名字分别是低频、中频(300kHz-3MHz)和高频(3MHz-30MHz)。更高的频段中的V,U,S和E分别对应于Very,Ultra,Super和Extremely,.相应的频段的中文名字分别是甚高频(30MHz-300MHz)、特高频(300MHz-3GHz)、超高频(3GHz-30GHz)和极高频(30GHz-300GHz),最高的一个频段中的T是Tremendously,目前尚无标准译名。在低频LF的下面其实还有几个更低的频段，如甚低频VLF、特低频ULF、超低频SLF和极低频ELF等，因不用于一般的通信，故未画在图中。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908142801389.png" class="" title="image-20230908142801389"><p>无线电微波通信在当前的数据通信中占有特殊重要的地位。微波的频率范围为300MHz-300GHz(波长1m-1mm),但主要使用2GHz~40GHz的频举范围。微波在空间主要是直线传播，由于地球表面是个曲面，因此其传播距离受到限制，一般只有50k左右。但若采用100m高的天线塔，则传播距离可增大到100km。微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。</p><p>短波通信（即高频通信）主要靠电离层的反射。但电离层的不稳定所产生的衰落现象，以及电离层反射所产生的多径效应，使得短波信道的通信质量较差。当利用无线信道传送数字信号时，必须使误码率（即比特错误率）不大于可容许的范围。下图中的曲线是根据通信理论计算出的，我们这里只需知道有关的三个基本概念。</p><img src="/2023/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/image-20230908151235595.png" class="" title="image-20230908151235595"><ul><li>对于给定的调制方式和数据率，信噪比越大，误码率就越低。这个结论的得出是符合直觉的。当我们在嘈杂的餐厅用餐时，同桌的人可能听不清你说的话。提高嗓门会使说话的效果好些，但太大声说话也会影响周围顾客正常用餐。手机的情况也相似。若提高手机的发射功率，固然可以提高信噪比，但这必将缩短电池的使用时间。若增大电池的体积和重量，又会使手机携带不方便。过大的发射功率，还会干扰临近手机的正常通信，或影响人体健康。可见，如何提高信噪比需要综合考虑。</li><li>对于同样的信噪比，具有更高数据率的调制技术的误码率也更高。例如，当信噪比为10dB时，若采用1Mbit&#x2F;s数据率的二进制相移键控BPSK调制技术，则误码率小于107。但若采用4Mbit&#x2F;s数据率的正交振幅调制16QAM,则误码率为10，己经无法使用了。又如，当信噪比为20dB时，若采用4Mbit&#x2F;s数据率的正交振幅调制16QAM,则误码率小于107。但若采用1Mbit&#x2F;s数据率的二进制相移键控BPSK,则误码率变得非常小，从图中的曲线已无法查到其数值。</li><li>如果移动用户在进行通信时还在不断改变自己的地理位置，就会引起无线信道特性的改变，因而信噪比和误码率都会发生变化。因此，用户的移动设备的物理层应当有一定的自适应能力，可以根据所处的环境特性选择最合适的调制和编码技术，以便在保证容许的误码率的条件下，获得尽可能高的数据传输速率。为实现远距离通信必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站把前一站送来的信号经过放大后再发送到下一站，这种通信方式称为“微波接力”。大多数长途电话业务使用4GHz~6GHz的频率范围。</li></ul><p>常用的卫星通信方法是在地球站之间利用位于约3万6千公里高空的人造同步地球卫星作为中继器的一种微波接力通信。对地静止通信卫星就是在太空的无人值守的微波通信的中继站。可见卫星通信的主要优缺点大体上应当和地面微波通信差不多。卫星通信的最大特点是通信距离远，且通信费用与通信距离无关。同步地球卫星发射出的电磁波能辐射到地球上的通信覆盖区的跨度达1万8千多公里，面积约占全球的三分之一。只要在地球赤道上空的同步轨道上，等距离地放置3颗相隔120度的卫星，就能基本上实现全球的通信。</p><p>卫星通信的另一特点就是具有<strong>较大的传播时延</strong>。由于各地球站的天线仰角并不相同，因此不管两个地球站之间的地面距离是多少（相隔一条街或相隔上万公里），从一个地球站经卫星到另一地球站的传播时延均在250~300ms之间。一般可取为270ms。这和其他的通信有较大差别（请注意：这和两个地球站之间的距离没有什么关系）。对比之下，地面微波接力通信链路的传播时延一般取为3.3us&#x2F;km。请注意，“卫星信道的传播时延较大”并不等于“用卫星信道传送数据的时延较大”。这是因为传送数据的总时延除了传播时延，还有发送时延、处理时延和排队时延等部分。传播时延在总时延中所占的比例有多大，取决于具体情况。但利用卫星信道进行交互式的网上游戏显然是不合适的。在十分偏远的地方，或在离大陆很远的海洋中，要进行通信就几乎完全要依赖于卫星通信。卫星通信还非常适合于广播通信，因为它的覆盖面很广。但从安全方面考虑，卫星通信系统的保密性则相对较差。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概述(一)</title>
    <link href="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>这是对作为一个互联网（网中网）的 Internet 进行概述，讨论 Internet 的组成部分。这个目标的部分内容为介绍协议分层和 TCP&#x2F;IP 协议簇</p><span id="more"></span><h3 id="计算机网络在信息时代中的作用"><a href="#计算机网络在信息时代中的作用" class="headerlink" title="计算机网络在信息时代中的作用"></a>计算机网络在信息时代中的作用</h3><p>Internet的中文译名并不统一。现有的Internet译名有两种：<br>        因特网，这个译名是全国科学技术名词审定委员会推荐的。虽然因特网这个译名较为准确，但却长期未得到推广。本书的前几版都采用因特网这个译名。<br>        互联网，这是目前流行最广的、事实上的标准译名。现在我国的各种报刊杂志、政府文件以及电视节目中都毫无例外地使用这个译名。Internet是由数量极大的各种计算机网络互连起来的，采用互联网这个译名能够体现出Internet最主要的特征。本书从第7版开始，改用“互联网”作为Internet的译名。</p><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>计算机网络（简称为<strong>网络</strong>）由若干<strong>节点</strong>和连接这些节点的<strong>链路</strong>组成。网络中的节点可以是计算机、集线器、交换机或路由器等（在后续的两章我们将会介绍集线器、交换机和路由器等设备的作用)。下图给出了一个具有四个节点和三条链路的网络。我们看到，有三台计算机通过三条链路连接到一个集线器上。这是一个非常简单的计算机网终（可简称为网终)又加在下图中，有多个网悠通过二些路由器相互连接起来，构成了一个覆盖范围更大的计算机网络。这样的网铭称为互连网internetwork或internet)。因此互连网是“网络的网络”(network of networks)甲一朵云表示一个网络的好处，就是可以先不考虑每一个网络中的细节，而是集中精力讨论与这个互连网有关的一些问题。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171508256.png" class="" title="image-20230829171508256"><p>请读者注意，当我们使用一朵云来表示网络时，可能会有两种不同的情况。一种情况如图(a)所示，用云表示的网络已经包含了网络中的计算机。但有时为了讨论问题的方便例如，要讨论几个计算机之间如何进行通信)，也可以把有关的计算机画在云的外面，如下图所示。习惯上，与网络相连的计算机常称为主机（host)。在互连网中不可缺少的路由器，是一种特殊的计筒机（有中央处理器、存储器、操作系统等），但不能称为主机。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829171654918.png" class="" title="image-20230829171654918"><p>这样，我们初步建立了下面的基本概念：<br>网络把许多计算机连接在一起，而互连网则把许多网络通过一些路由器连接在一起。与网络相连的计算机常称为主机。</p><h4 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h4><ol><li>第一阶段是从单个网络ARPANET向互连网发展的过程</li><li>第二阶段的特点是建成了三级结构的互联网</li><li>第三阶段的特点是逐渐形成了全球范围的多层次ISP结沟的旦肤网。</li></ol><h4 id="互联网的标准化工作"><a href="#互联网的标准化工作" class="headerlink" title="互联网的标准化工作"></a>互联网的标准化工作</h4><p>制定互联网的正式标准要经过以下三个阶段：</p><ul><li>互联网草案(nternet Draft)一互联网草案的有效期只有六个月。在这个阶段还不能算是RFC文档。</li><li>建议标准(Proposed Standard)一从这个阶段开始就成为RFC文档。</li><li>互联网标准(nternet Standard)一如果经过长期的检验，证明了某个建议标准可以成为互联网标准时，就给它分配一个标准编号，记为STDxx,这里STD是“Standard”的英文缩写，而“xx”是标准的编号（有时也写成4位数编号，如STD0005)。一个互联网标准可以和多个RFC文档关联。</li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul><li>边缘部分:由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829172920816.png" class="" title="image-20230829172920816"><ul><li>核心部分:由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换)</li></ul><h4 id="互联网的边缘部分"><a href="#互联网的边缘部分" class="headerlink" title="互联网的边缘部分"></a>互联网的边缘部分</h4><p>我们先要明确下面的概念。我们说：“主机A和主机B进行通信”，实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式(C&#x2F;S方式)和对等方式(P2P方式)下面分别对这两种方式进行介绍。</p><p>1.客户-服务器方式</p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服多和被服务的关系。在下图中，主机A运行客户程序而主机B运行服务器程序。在这种情况下，A是客户而B是服务器。客户A向服务器B发出请求服务，而服务器B向客户A提供服务。这里最主要的特征就是：客户是服务请求方，服务器是服务提供方。<br>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829173123722.png" class="" title="image-20230829173123722">在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点。<p>客户程序：</p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p>服务器程序：</p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般需要有强大的硬件和高级的操作系统支持。客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</li></ul><p>2.对等连接方式</p><p>是指两台主机在通信时，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件(P2P软件)，它们就可以进行平等的对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为P2P方式。</p><p>在下图中，主机C,D,E和F都运行了P2P程序，因此这几台主机都可进行对等通信（如C和D,E和F,以及C和F)。实际上，对等连接方式从本质上看仍然使用客户服务器方式，只是对等连接中的每一台主机既是客户同时又是服务器。例如主机C,当C请求D的服务时，C是客户，D是服务器。但如果C又同时向F提供服务，那么C又同时起着服务器的作用。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174035901.png" class="" title="image-20230829174035901"><h4 id="互联网的核心部分"><a href="#互联网的核心部分" class="headerlink" title="互联网的核心部分"></a>互联网的核心部分</h4><p>网络核心部分是互联网中最复杂的部分，因为网络中的核心部分要向网络边缘部分中的大量主机提供连通性，使边缘部分中的任何一台主机都能够与其他主机通信。在网络核心部分起特殊作用的是<strong>路由器</strong>(router),它是一种专用计算机（但不叫作主机)。路由器是实现<strong>分组交换</strong>(packet switching)的关键构件，其任务是<strong>转发收到的分组</strong>，这是网络核心部分最重要的功能。</p><p>1、电路交换的特点</p><p>从通信资源的分配角度来看，<strong>交换</strong>(switching)就是按照某种方式动态地分配传输线路的资源。在使用电路交换打电话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条<strong>专用的物理通路</strong>。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的<br>物理通路（即把刚才占用的所有通信资源归还给电信网）。这种必须经过“<strong>建立连接（占用通信资源)→通适（一直占用通信贪源→释放连接（归还通信资源）</strong>”三个步骤的交换方式称为电路交换。如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后再重新拨号。</p><p>2、分组交换的特点</p><p>分组交换则采用存储转发技术。下图表示把一个报文划分为几个分组后再进行传送。通常我们把要发送的整块数据称为一个<strong>报文</strong>(message)。在发送报文之前，先把较长的报文划分为一个个更小的等长数据段，例如，视频讲解每个数据段为1024bit。在每一个数据段前面，加上一些必要的控制信息组成的首部(header)后，就构成了一个<strong>分组</strong>(packet)。分组又称为“包”，而分组的首部也可称为“包头”。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829174914172.png" class="" title="image-20230829174914172"><p>位于<strong>网络边缘部分的主机</strong>和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器则用来转发分组，即进行分组交换。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地（有时会经过几十个不同的路由器）以存储转发的方式，把分组交付最终的<br>目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175504654.png" class="" title="image-20230829175504654"><p>图的最下方归纳了三种交换方式在数据传送阶段的主要特点：</p><ul><li>电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换—整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。</li><li>分组交换—单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点。</li></ul><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829175607493.png" class="" title="image-20230829175607493"><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><h4 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h4><p>关于计算机网络的较好的定义是这样的[PETE12]1:计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><h4 id="几种不同类别的计算机网络"><a href="#几种不同类别的计算机网络" class="headerlink" title="几种不同类别的计算机网络"></a>几种不同类别的计算机网络</h4><ul><li>按照网络的作用范围进行分类</li></ul><p>广域网WAN(Wide Area Network)广域网的作用范围通常为几十到几千公里，因而有时也称为远程网(long haul network)</p><p>城域网MAN(Metropolitan Area Network)城域网的作用范围一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5~50km。</p><p>局域网LAN(Local Area Network)局域网一般用微型计算机或工作站通过高速通信线路相连（速率通常在10Mbit&#x2F;s以上），但地理上则局限在较小的范围（如1km左右）。</p><p>个人区域网PAN(Personal Area Network)个人区域网就是在个人工作的地方把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络，因此也常称为无线个人区域网WPAN(Wireless PAN),其范围很小，大约在I0m左右。</p><ul><li>按照网络的使用者进行分类</li></ul><p>公用网(public network)这是指电信公司（国有或私有）出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为公众网。</p><p>专用网(private network)这是某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</p><ul><li>用来把用户接入到互联网的网络</li></ul><p>这种网络就是接入网AN(Access Network),它又称为本地接入网或居民接入网</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><ul><li>速率</li></ul><p>计算机发送的信号都是数字形式的。比特(bit)来源于binary digit,意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的信息量的单位。网络技术中的速率指的是数据的传送速率,它也称为数据率(data rate)或比特率(bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit&#x2F;s(比特每秒)</p><ul><li>带宽</li></ul><p>“带宽”(bandwidth)有以下两种不同的意义：</p><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。例如，在传统的通信线路上传送的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,即话音的主要成分的频率范围)。这种意义的带宽的单位是赫(或千赫、兆赫、吉赫等)。在过去很长的一段时间，通信的主干线路传送的是模拟信号(即连续变化的信号)。因此，表示某信道允许通过的信号频带范围就称为该信道的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”。在本书中提到“带宽”时，主要是指这个意思。这种意义的带宽的单位就是数据率的单位bit&#x2F;s,是“比特每秒”。</li></ol><ul><li>吞吐量</li><li>时延</li></ul><p>时延(delay或latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或迟延。</p><p>发送时延：发送时延(transmission delay)是主机或路由器发送数据帧所需要的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182020809.png" class="" title="image-20230829182020809"><p>传播时延：是电磁波在信道中传播一定的距离需要花费的时间</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829182128702.png" class="" title="image-20230829182128702"><p>处理时延：处理时延主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找转发表等，这就产生了处理时延</p><p>排队时延：排队时延分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><ul><li>时延带宽积</li></ul><p>时延带宽积&#x3D;传播时延×带宽</p><ul><li>往返时间PTT</li></ul><p>在计算机网络中，往返时间RTT(Round-Trip Time)也是一个重要的性能指标。这是因为在许多情况下，互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道双向交互一次所需的时间。例如，A向B发送数据。如果数据长度是100MB,发送速率是1O0Mhit&#x2F;s.那么</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194040018.png" class=""><p>假定B正确收完100MB的数据后，就立即向A发送确认。再假定A只有在收到B的确认信息后，才能继续向B发送数据。显然，这就要等待一个往返时间RTT(这里假定确认信息很短，可忽略B发送确认的发送时延)。如果RTT&#x3D;2s,那么可以算出A向B发送数据的有效数据率。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194236316.png" class="" title="image-20230829194236316"><ul><li>利用率</li></ul><h4 id="计算机网络的非性能特征"><a href="#计算机网络的非性能特征" class="headerlink" title="计算机网络的非性能特征"></a>计算机网络的非性能特征</h4><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于维护和管理</li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h4><h6 id="网络协议三个要素组成："><a href="#网络协议三个要素组成：" class="headerlink" title="网络协议三个要素组成："></a>网络协议三个要素组成：</h6><ul><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：即事件实现顺序的详细说明</li></ul><h6 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h6><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829194710875.png" class="" title="image-20230829194710875"><ul><li>应用层(application layer)</li></ul><p>应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程就是指主机中正在运行的程序。对于不同的网络应用需要有不同的应用层协议。互联网中的应用层协议很多，如域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议，等等。我们把应用层交互的数据单元称为报文(message)。</p><ul><li>运输层(transport layer)</li></ul><p>运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。所谓“通用的”，是指并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议：</p><ol><li>传输控制协议TCP(Transmission Control Protocol)提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。</li><li>用户数据报协议UDP(User Datagram Protocol)—提供无连接的尽最大努力(besteffort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。</li></ol><ul><li>网络层(network layer)</li></ul><p>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用P协议，因此分组也叫作P数据报，或简称为数据报。本书把“分组”和“数据报”作为同义词使用。请注意：不要将运输层的“用户数据报协议UDP”和网络层的“IP数据报”弄混。此外，无论在哪一层传送的数据单元，都可笼统地用“分组”来表示。</p><ul><li>数据链路层(data link layer)</li></ul><p>数据链路层常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing),在两个相邻节点间的链路上传送帧(frame)。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p><ul><li>物理层(physical layer)</li></ul><p>在物理层上所传数据的单位是比特。发送方发送1（或0）时，接收方应当收到1（或0)而不是0（或1）。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。当然，解释比特代表的意思，不是物理层的任务。请注意，传递信息所利用的一些物理传输媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而是在物理层协议的下面。因此也有人把物理层下面的物理传输媒体当作第0层。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829195444407.png" class="" title="image-20230829195444407"> <h4 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h4><ul><li>实体：实体(entity)这一较为抽象的名词表示任何可发送或接收信息的硬件或软件进程。在许多情况下，实体就是一个特定的软件模块。</li><li>协议：协议是控制两个对等实体（或多个实体)进行通信的规则的集合。</li></ul><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</p><p>首先，协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。也就是说，下面的协议对上面的实体是透明的。其次，协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。另外，并非在一个层内完成的全部功能都称为服务。只有那些能够被高一层实体“看得见”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语。</p><p>在同一系统中相邻两层的实体进行交互（即交换信息）的地方，通常称为服务访问点SAP(Service Access Point)。服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口，有点像邮政信箱（可以把邮件放入信箱和从信箱中取走邮件），但这种层间接口和两个设备之间的硬件接口（并行的或串行的）并不一样。OSI把层与层之间交换的数据的单位称为服务数据单元SDU(Service Data Unit),它可以与PDU不一样。例如，可以是多个SDU合成为一个PDU,也可以是一个SDU划分为几个PDU。</p><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200113587.png" class="" title="image-20230829200113587"><h4 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP&#x2F;IP的体系结构"></a>TCP&#x2F;IP的体系结构</h4><img src="/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/image-20230829200230496.png" class="" title="image-20230829200230496">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器(三)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此<br>外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。</p><span id="more"></span><h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><h5 id="3-1-1存储器的分类"><a href="#3-1-1存储器的分类" class="headerlink" title="3.1.1存储器的分类"></a>3.1.1存储器的分类</h5><p>按存储介质分类：</p><ul><li>半导体存储器TTL 、MOS</li><li>磁表面存储器    磁头、磁载体</li><li>磁芯存储器        硬磁材料、环中元件</li><li>光盘存储器        激光、磁光材料</li></ul><p>按存取方式分类：</p><p>​存取时间与物理地址无关（随机访问）</p><ul><li>随机存取器       在程序的执行过程中可读可写</li><li>只读存储器       在程序的执行过程中只读</li></ul><p>​存取时间与物理地址有关（串行访问）</p><ul><li>顺序存取存储器     磁带</li><li>直接存取存储器     磁盘</li></ul><p>按在计算机中的作用分类：</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114021837.png" class="" title="image-20230828114021837"><h5 id="3-1-2存储器的层次结构"><a href="#3-1-2存储器的层次结构" class="headerlink" title="3.1.2存储器的层次结构"></a>3.1.2存储器的层次结构</h5><ul><li>存储器三个主要特性的关系</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114241506.png" class="" title="image-20230828114241506"><ul><li>缓存 -主存层次和主存 -辅存层次</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114428289.png" class="" title="image-20230828114428289"><h4 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h4><h5 id="3-2-1概述"><a href="#3-2-1概述" class="headerlink" title="3.2.1概述"></a>3.2.1概述</h5><p>主存储器（简称主存）的基本结构已在第1章介绍过。实际上，根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p><h6 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114829534.png" class="" title="image-20230828114829534"><h6 id="主存与CPU的联系"><a href="#主存与CPU的联系" class="headerlink" title="主存与CPU的联系"></a>主存与CPU的联系</h6><p>现代计算机的主存都由半导体集成电路构成，图中的驱动器、译码器和读写电路均制作在存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和CPU芯片可通过总线连接</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115057618.png" class="" title="image-20230828115057618"><p>当要从存储器读出某一信息字时，首先由CPU将该字的地址送到MAR,经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读至数据总线上，至于该信息由MDR送至什么地方，这已不是主存的任务，而是由CPU决定的。若要向主存存入一个信息字时，首先CPU将该字所在主存单元的地址经MAR到地址总线，并将信息字送入MDR,然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写人到对应地址线指出的主存单元中。</p><h6 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h6><p>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写人一个存储字。不同的机器存储字长也不同，为了满足字符处理的需要，常用8位二进制数表示一个字节，因此存储字长都取8的倍数。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370机的字长为32位，它可按字节寻址，即它的每一个存储字包含4个可独立寻址的字节，其地址分配如图所示。字地址是用该字高位字节的地址来表示，故其字地址是4的整数倍，正好用地址码的末两位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115954328.png" class="" title="image-20230828115954328"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120051543.png" class="" title="image-20230828120051543"><p>由图所示，对24位地址线的主存而言，按字节寻址的范围是16M,按字寻址的范围<br>为4M。由图所示，对24位地址线而言，按字节寻址的范围仍为16M,但按字寻址的范<br>围为8M。</p><h6 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h6><ul><li>存储容量：主存 存放二进制代码的总位数<ul><li>存储容量&#x3D;存储单元个数 ×存储字长</li></ul></li><li>存储速度<ul><li>存取时间：存储器的访问时间、读出时间、写入时间</li><li>存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间读周期 写周期</li></ul></li><li>存储器带宽：位&#x2F;秒</li></ul><h5 id="3-2-2半导体存储芯片介绍"><a href="#3-2-2半导体存储芯片介绍" class="headerlink" title="3.2.2半导体存储芯片介绍"></a>3.2.2半导体存储芯片介绍</h5><h6 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120855844.png" class="" title="image-20230828120855844"><ul><li><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读&#x2F;写电路的配合下完成对被选中单元的读&#x2F;写操作。</p></li><li><p>读&#x2F;写电路包括读出放大器和写人电路，用来完成读&#x2F;写操作。</p></li><li><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p></li><li><p>地址线是单向输入的，其位数与芯片容量有关。</p></li><li><p>数据线是双向的（有的芯片可用成对出现的数据线分别作为输入或输出），其位数与芯片可<br>读出或写人的数据位数有关。数据线的位数与芯片容量有关。</p></li><li><p>地址线和数据线的位数共同反映存储芯片的容量。例如，地址线为10根，数据线为4根，测芯片容量为2×4&#x3D;4K位；又如地址线为14根，数据线为1根，则其容量为16K位。</p></li><li><p>控制线主要有读&#x2F;写控制线与片选线两种。不同存储芯片的读&#x2F;写控制线和片选线可以不同。有的芯片的读&#x2F;写控制线共用1根（如2114），有的分用两根（如6264）；有的芯片的片选线用1根（如2114），有的用2根（如6264)。读&#x2F;写控制线决定芯片进行读&#x2F;写操作，片选线用来选择存储芯片。由于半导体存储器是由许多芯片组成的，为此需用片选信号来确定哪个芯片被选中。例如，一个64K×8位的存储器可由32片16K×1位的存储芯片组成，如图所示。但每次读出一个存储字时，只需选中8片。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828122056796.png" class="" title="image-20230828122056796"></li></ul><h6 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h6><p>半导体存储芯片的译码驱动方式有两种：线选法和重合法</p><ul><li>线选法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123207033.png" class="" title="image-20230828123207033"><p>图是一个16×1字节线选法存储芯片的结构示意图。它的特点是用一根字选择线（字线)，直接选中一个存储单元的各位（如一个字节）。这种方式结构较简单，但只适于容量不大的存储芯片。如当地址线为1111时，则第15根字线被选中，对应图4.9中的最后一行8位代码便可直接读出或写人。</p><ul><li>重合法</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123235418.png" class=""><p>图是一个1K×1位重合法结构示意图。显然，只要用64根选择线(X、Y两个方向各32根)，便可选择32×32矩阵中的任一位。例如，当地址线为全0时，译码输出X。和Y。有效，矩阵中第0行、第0列共同选中的那位即被选中。由于被选单元是由X、Y两个方向的地址决定的，故称为重合法。当欲构成1K×1字节的存储器时，只需用8片如图4.10所示的芯片即可。</p><h5 id="3-2-3随机存储器"><a href="#3-2-3随机存储器" class="headerlink" title="3.2.3随机存储器"></a>3.2.3随机存储器</h5><h6 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h6><p>存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路，图4.11是一个由6个MOS管组成的基本单元电路。</p><p>图中T1-T4是一个由MOS管组成的触发器基本电路，T5、T6犹如一个开关，受行地址选择信号控制。由T1~T6。这6个M0S管共同构成一个基本单元电路。T7、T8。受列地址选择控制，分别与位线A’和A相连，它们并不包含在基本单元电路内，而是芯片内同一列的各个基本单元电路所共有的。</p><p>假设触发器已存有“1”信号，即A点为高电平。当需读出时，只要使行、列地址选择信号均有效，则使T5、T6、T7、T8均导通，A点高电平通过T6后，再由位线A通过T8作为读出放大器的输入信号，在读选择有效时，将“1”信号读出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904132216809.png" class="" title="image-20230904132216809"><p>写入时不论触发器原状态如何，只要将写入代码送至图的D端，在写选择有效时，经两个写放大器，使两端输出为相反电平。当行、列地址选择有效时，使T5、T6、T7、T8导通，并将A与A’点置成完全相反的电平。这样，就把欲写人的信息写入到该基本单元电路中。如欲写人“1”,即D&#x3D;1,经两个写放大器使位线A为高电平，位线A’为低电平，结果使A点为高，A’点为低，即写人了“1”信息。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904133958930.png" class="" title="image-20230904133958930"><p>2114RAM芯片的结构示意图如图所示。图中存储矩阵由64×64个基本单元电路组成，列I&#x2F;0电路即读&#x2F;写电路。10根地址线分为行地址A8-A3和列地址A9、A2、A1、A0,4根数据线为I&#x2F;O4-I&#x2F;O0,,它们是受输入&#x2F;输出三态门控制的双向总线，当CS和WE均为低电平时，输人三态门打开，I&#x2F;O4-I&#x2F;O0,上的数据即写人到指定地址单元中。当CS为低电平、WE为高电平时，输出三态门打开，列1&#x2F;0电路的输出经片内总线输出至数据线I&#x2F;O4~I&#x2F;O0上。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904134637357.png" class="" title="image-20230904134637357"><p>2114RAM芯片内的存储矩阵结构如图所示。其中每一个小方块均为一个由6个M0S管组成的基本单元电路，排列成64×64矩阵，64列对应64对T7,、T8管。又将64列分成4组，每组包含16列，并与一个读&#x2F;写电路相连，读&#x2F;写电路受WE和CS控制，4个读&#x2F;写电路对应4根数据线I&#x2F;O0-I&#x2F;O4。由图中可见，行地址经译码后可选中某一行；列地址经译码后可选中4组中的对应列，共4列。当对某个基本单元电路进行读&#x2F;写操作时，必须被行、列地址共同选中。例如，当A9-A0为全0时，对应行地址A8-A3为000000，列地址A、A2、A,、A。也为0000，则第0行的第0、16、32、48这4个基本单元电路被选中。此刻，若做读操作，则CS为低电平，WE为高电平，在读&#x2F;写电路的输出端1&#x2F;O1-I&#x2F;O4便输出第0行的第0、16、32、48这4个基本单元电路所存的信息。若做写操作，将写人信息送至I&#x2F;O0-I&#x2F;O4端口，并使CS为低电平、WE为低电平，同样这4个输人信息将分别写入到第0行的第0、16、32、48这4个单元之中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135156790.png" class="" title="image-20230904135156790"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135227371.png" class="" title="image-20230904135227371"><h6 id="动态RAM-DRAM"><a href="#动态RAM-DRAM" class="headerlink" title="动态RAM(DRAM)"></a>动态RAM(DRAM)</h6><p>常见的动态RAM基本单元电路有三管式和单管式两种，它们的共同特点都是靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。电容上的电荷一般只能维持1~2s,因此即使电源不掉电，信息也会自动消失。为此，必须在2s内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。由于它与静态RAM相比，具有集成度更高、功耗更低等特点，目前被各类计算机广泛应用。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135533598.png" class="" title="image-20230904135533598"><p>读出时，先对预充电管T4置一预充电信号（在存储矩阵中，每一列共用一个T4管)，使读数据线达高电平VDD。然后由读选择线打开T2,若T1的极间电容Cg存有足够多的电荷（被认为原存“1”)，使T1导通，则因T2、T1导通接地，使读数据线降为零电平，读出“0”信息。若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，由读出线的高低电平可区分其是读“1”，还是读“0”，只是它与原存信息反相。写入时，将写人信号加到写数据线上，然后由写选择线打开T3,这样，C.便能随输入信息充电（写“1”）或放电（写“0”）。</p><p>为了提高集成度，将三管电路进一步简化，去掉T1,把信息存在电容Cs上，将T2、T3合并成一个管子T,便得到单管M0S动态RAM基本单元电路，如图4.18所示。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904140145043.png" class="" title="image-20230904140145043"><p>读出时，字线上的高电平使T导通，若C,有电荷，经T管在数据线上产生电流，可视为读出“1”。若Cs无电荷，则数据线上无电流，可视为读出“0”。读操作结束时，Cs的电荷已释放完毕，故是破坏性读出，必须再生。写人时，字线为高电平使T导通，若数据线上为高电平，经T管对0，充电，使其存“1”；若数据线为低电平，则C,经T放电，使其无电荷而存“0”。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164519993.png" class="" title="image-20230904164519993"><p>这是一个1K×1位的存储芯片，图中每一小方块代表由3个M0S管组成的动态RAM基本单元电路。它们排列成32×32的矩阵，每列都有一个刷新放大器(用来形成再生信息)和一个预充电管（图中未画），芯片有10根地址线，采用重合法选择基本单元电路。</p><p>读出时，先置以预充电信号，接着按行地址A9-A5经行译码器给出读选择信号，同时由列地址A4~A0。经列译码器给出列选择信号。只有在行、列选择信号共同作用下的基本单元电路才能将其信息经读数据线送到读&#x2F;写控制电路，并从数据线D输出。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164942057.png" class="" title="image-20230904164942057"><p>写入时，在受行地址控制的行译码器给出的写选择信号的作用下；选中芯片的某一行，并在列地址的作用下，由列译码器的输出控制读&#x2F;写控制电路，只将数据线D的信息送到被选中列的写数据线上，信息即被写人到行列共同选中的基本单元电路中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165055182.png" class="" title="image-20230904165055182"><p>16K×1位的存储芯片共有16K个单管M0S基本单元电路，它们排列成128×128的矩阵，如图所示。图中的行线就是图4.18中的字线，列线就是图4.18中的数据线。128行分布在读放大器的左、右两侧（左侧为0<del>63行，右侧为64</del>127行）。每根行选择线与128个M0S管的栅极相连。128列共有128个读放大器，它的两侧又分别与64个M0S管相连，每根列线上都有一个列地址选择管。128个列地址选择管的输出又互相并接在一起与I&#x2F;0缓冲器相连，I&#x2F;0缓冲器的一端接输出驱动器，可输出数据；另一端接输入器，供数据输入</p><p>读出时，行、列地址受RAS和CAS控制，分两次分别存人行、列地址缓存器。行地址经行译码后选中一行，使该行上所有的M0S管均导通，并分别将其电容C,上的电荷反映到128个读放大器的某一侧（第0-63行反映到读放大器的左侧，第64-127行反映到读放大器的右侧）。读放大器的工作原理像一个撬撬板电路，类似于一个触发器，其左右两侧电平相反。此外列地址经列译码后选中某一列，该列上的列地址选择管导通，即可将读放大器右侧信号经读&#x2F;写线、I&#x2F;0缓冲器输出至Dout端。例如，选中第63行、第0列的单管MOS电路，若其C。有电荷为“1”状态，则反映到第0列读放大器的左侧为“1”，右侧为“0”，经列地址选择管输出至Dout为0，与原存信息反相。同理，第0-62行经读放大器至输出线Dout的信息与原存信息均反相。而读出第64~127行时，因它们的电容C。上的电荷均反映到读放大器的右侧，故经列地址选择管输出至Dout的信息均同相。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165802445.png" class="" title="image-20230904165802445"><p>写人时，行、列地址也要分别送人芯片内的行、列地址缓存器，经译码可选中某行、某列。输入信息D通过数据输人器，经I&#x2F;0缓冲器送至读&#x2F;写线上，但只有被选中的列地址选择管导通，可将读&#x2F;写线上的信息送至该列的读放大器右侧，破坏了读放大器的平衡，使读放大器的右侧与输人信息同相，左侧与输入信息反相，读放大器的信息便可写入到选中行的C,中。例如，选中第64行、第127列，输入信息为“1”，则第127列地址选择管导通，将“1”信息送至第127列的读放大器的右侧。虽然第64行上的128个M0S管均导通，但惟有第64行、第127列的M0S管能将读放大器的右侧信息“1”对C,充电，使其写入“1”。值得注意的是写人读放大器左侧行的信息与输入信息都是反相的，而由读出过程分析又知，对读放大器左侧行进行读操作时，读出的信息也是反相的，故最终结果是正确的。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165825227.png" class="" title="image-20230904165825227"><h6 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h6><p>由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的渎&#x2F;写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2s,这个时间称为刷新周期，又称再生周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证动态RAM内的信息不丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。</p><ul><li>集中刷新</li></ul><p>集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读&#x2F;写操作。例如，对128×128矩阵的存储芯片进行刷新时，若存取周期为0.55，刷新周期为2s(占4000个存取周期)，则对128行集中刷新共儒64us(占128个存取周期)，其余的1936s(共3872个存取周期)用来读&#x2F;写或维持信息，如图所示。由于在这64us时间内不能进行读&#x2F;写操作，故称为“死时间”，又称访存“死区”，所占比率28&#x2F;4000×100%&#x3D;3.2%,称为死时间率。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170137608.png" class="" title="image-20230904170137608"><ul><li>分散刷新</li></ul><p>分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期tc分成两段，前半段tm用来读&#x2F;写或维持信息，后半tr段用来刷新，即c&#x3D;tm+tr。若读&#x2F;写周期为0.5us,则存取周期为1s。仍以128×128矩阵的存储芯片为例，刷新按行进行，每隔128s就可将存储芯片全部刷新一遍，如图所示。这比允许的间隔2ms要短得多，而且也不存在停止读&#x2F;写操作的死时间，但存取周期长了，整个系统速度降低了。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170449800.png" class="" title="image-20230904170449800"><ul><li>异步刷新</li></ul><p>异步刷新是前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为2s的特点。例如，对于存取周期为0.5us,排列成128×128的存储芯片，可采取在2ms内对128行各刷新一遍，即每隔15.6s(2000s÷128≈15.6s)刷新一行，而每行刷新的时间仍为0.5s,如图所示。这样，刷新一行只停业一个存取周期，但对每行来说，刷新间隔时间仍为2ms,而“死时间”缩短为0.5心8。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170623026.png" class="" title="image-20230904170623026"><h6 id="动态RAM与静态RAM比较"><a href="#动态RAM与静态RAM比较" class="headerlink" title="动态RAM与静态RAM比较"></a>动态RAM与静态RAM比较</h6><p>目前，动态RAM的应用比静态RAM要广泛得多。其原因如下：</p><ul><li>在同样大小的芯片中，动态RAM的集成度远高于静态RAM,如动态RAM的基本单元电路为一个MOS管，静态RAM的基本单元电路可为4~6个MOS管。</li><li>动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少。</li><li>动态RAM的功耗比静态RAM小。</li><li>动态RAM的价格比静态RAM的价格便宜。当采用同一档次的实现技术时，动态RAM的容量大约是静态RAM容量的4-8倍，静态.RAM的存取周期比动态RAM的存取周期快8-16倍，但价格也贵8~16倍。.</li></ul><p>动态RAM也有缺点：</p><ul><li>由于使用动态元件（电容），因此它的速度比静态RAM低。</li><li>动态RAM需要再生，故需配置再生电路，也需要消耗一部分功率。通常，容量不大的高速缓冲存储器大多用静态RAM实现。</li></ul><h5 id="3-2-4只读存储器-ROM"><a href="#3-2-4只读存储器-ROM" class="headerlink" title="3.2.4只读存储器(ROM)"></a>3.2.4只读存储器(ROM)</h5><p>按R0M的原始定义，一且注入原始信息即不能改变，但随着用户的需要，总希望能任意修改ROM内的原始信息。这便出现了PROM、EPROM和EEPROM等。对半导体ROM而言，基本器件为两种：MOS型和TL型。</p><ul><li>掩模ROM(MROM)<ul><li>行列选择线交叉处有MOS管为“1”</li><li>行列选择线交叉处无MOS管为“0”</li></ul></li><li>PROM(一次性编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171603204.png" class="" title="image-20230904171603204"><ul><li>EPROM(多次编程)</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171626849.png" class="" title="image-20230904171626849"><ul><li><p>EEPROM(多次性编程)</p><ul><li>电可擦写</li><li>局部擦写</li><li>全部擦写</li></ul></li><li><p>Flash Memory(闪速型存储器)</p></li></ul><p>进入到20世纪.80年代，又出现了一种闪速存储器(lash Memory),又称快擦型存储器，它是在EPROM和EEPROM工艺基础上产生的一种新型的、具有性能价格比更好、可靠性更高的可擦写非易失性存储器。它既有EPROM的价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性。它具有整片擦除的特点，其擦除、重写的速度快。一块1M位的闪速存储芯片的擦除、重写时间小于5s,比一般标准的EEPROM快得多，已具备了RAM的功能，可与CPU直接连接。它还具有高速编程的特点，例如，采用快速脉冲编程算法对28256闪速存储芯片每字节的编程时间仅需100s。此外，该器件具有存储器访问周期短，功耗低及与计算机接口简单等优点。</p><h5 id="3-2-5存储器与CPU的连接"><a href="#3-2-5存储器与CPU的连接" class="headerlink" title="3.2.5存储器与CPU的连接"></a>3.2.5存储器与CPU的连接</h5><h6 id="存储芯片的扩展"><a href="#存储芯片的扩展" class="headerlink" title="存储芯片的扩展"></a>存储芯片的扩展</h6><ul><li>位扩展</li></ul><p>位扩展是指增加存储字长，例如，2片1K×4位的芯片可组成1K×8位的存储器，如图所示。图中2片2114的地址线A9-A0,、CS、WE都分别连在一起，其中一片的数据线作为高4位D7-D4,另一片的数据线作为低4位D3~D0。这样，便构成了一个1K×8位的存储器。（10根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172431505.png" class="" title="image-20230904172431505"><ul><li>字扩展</li></ul><p>字扩展是指增加存储器字的数量。例如，用2片1K×8位的存储芯片可组成一个2K×8位的存储器，即存储字增加了一倍，如图所示。在此，将A10用做片选信号。由于存储芯片的片选输入端要求低电平有效，故当A10为低电平时，CS0有效，选中左边的1K×8位芯片；当A10为高电平时，反相后CS1有效，选中右边的1K×8位芯片。（11根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172643451.png" class="" title="image-20230904172643451"><ul><li>位、字扩展</li></ul><p>字、位扩展是指既增加存储字的数量，又增加存储字长。图示意用8片1K×4位的芯片组成4K×8位的存储器。（12根地址线，8根数据线）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172920491.png" class="" title="image-20230904172920491"><p>由图中可见，每2片构成一组1K×8位的存储器，4组便构成4K×8位的存储器。地址线A11、A10经片选译码器得到4个片选信号CS0、CS1、CS2、CS3,分别选择其中1K×8位的存储芯片。WE为读&#x2F;写控制信号。</p><h6 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h6><p>存储芯片与CPU芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。</p><ul><li>地址线的连接</li></ul><p>存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU地址线的低位与存储芯片的地址线相连。CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。例如，设CPU地址线为16位A15-A0。,1K×4位的存储芯片仅有10根地址线A9-A0。,此时，可将CPU的低位地址A9-A0与存储芯片地址线A9-A0相连。又如，当用16K×1位存储芯片时，则其地址线有14根A13-A0。,此时，可将CPU的低位地址A13-A0。与存储芯片地址线A13~A0相连。</p><ul><li>数据线的连接</li></ul><p>同样，CPU的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p><ul><li>读&#x2F;写命令线的连接</li></ul><p>CPU读&#x2F;写命令线一般可直接与存储芯片的读&#x2F;写控制端相连，通常高电平为读，低电平为写。有些CPU的读&#x2F;写命令线是分开的，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p><ul><li>片选线的连接</li></ul><p>片选线的连接是CPU与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。片选有效信号与CPU的访存控制信号MREQ(低电平有效)有关，因为只有当CPU要求访存时，才需选择存储芯片。若CPU访问I&#x2F;O，则MRE0为高电平，表示不要求存储器工作。此外，片选有效信号还和地址有关，因为CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。通常需用到一些逻辑电路，如译码器及其他各种门电路，来产生片选有效信号。</p><ul><li>合理选择存储芯片</li></ul><p>合理选择存储芯片主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽重使连线简单方便。</p><h5 id="3-2-6存储器的校验"><a href="#3-2-6存储器的校验" class="headerlink" title="3.2.6存储器的校验"></a>3.2.6存储器的校验</h5><p>在计算机运行过程中，由于种种原因致使数据在存储过程中可能出现差错。为了能及时发现错误并及时纠正错误，通常可将原数据配成汉明编码。</p><h6 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h6><p>任意两组合法代码之间二进制位数的最少差异编码的纠错、检错能力与编码的最小距离有关</p><p>L-1&#x3D;D+C(D&gt;&#x3D;C)</p><ul><li>L:编码的最小距离  L&#x3D;3</li><li>D:检测错误的位数 具有一<strong>位</strong>纠错</li><li>C:纠正错误的位数</li></ul><p>汉明码是具有一位纠错能力的编码</p><h6 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h6><p>汉明码的三要素</p><ul><li>汉明码的组成需增添？位检测位</li></ul><p>$$<br>2^k&gt;&#x3D;n+k+1<br>$$</p><ul><li>检测位的位置?</li></ul><p>$$<br>2^i(i&#x3D;0,1,2,3,……)<br>$$</p><ul><li>检测为的取值？</li></ul><p>检测位的取值与该位所在的检测“小组”中承担的奇偶校验任务有关</p><h5 id="3-2-7提高访存速度的措施"><a href="#3-2-7提高访存速度的措施" class="headerlink" title="3.2.7提高访存速度的措施"></a>3.2.7提高访存速度的措施</h5><p>随着计算机应用领域的不断扩大，处理的信息量越来越多，对存储器的工作速度和容量要求也越来越高。此外，因CPU的功能不断增强，&#x2F;0设备的数量不断增多，致使主存的存取速度已成为计算机系统的瓶颈。可见，提高访存速度也成为迫不及待的任务。为了解决此问题，除了寻找高速元件和采用层次结构以外，调整主存的结构也可提高访存速度。</p><ul><li>单体多字系统</li></ul><p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可以在一个存取周期内，从同一地址取出4条指令，然后再逐条将指令送至CPU执行，即每隔1&#x2F;4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183437547.png" class="" title="image-20230904183437547"><p>图中示意了一个单体四字结构的存储器，每字W位。按地址在一个存取周期内可读出4×W位的指令或数据，使主存带宽提高到4倍。显然，采用这种办法的前提是：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p><ul><li>多体并行系统</li></ul><p>多体并行系统就是采用多体模块组成的存储器。每个模块有相同的容量和存取速度，各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读&#x2F;写电路，它们能并行工作，又能交叉工作。并行工作即同时访问N个模块，同时启动，同时读出，完全并行地工作（不过，同时读出的N个字在总线上需分时传送)。图4.42是适合于并行工作的高位交叉编址的多体存储器结构示意图，图中程序因按体内地址顺序存放（一个体存满后，再存人下一个体），故又有顺序存储之称。显然，高位地址可表示体号，低位地址为体内地址。按这种编址方式，只要合理调动，使不同的请求源同时访问不同的体，便可实现并行工作。例如，当一个体正与CPU交换信息时，另一个体可同时与外部设备进行直接存储器访问，实现两个体并行工作。这种编址方式由于一个体内的地址是连续的，有利于存储器的扩充。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183724260.png" class="" title="image-20230904183724260"><p>下图是按低位交叉编址的多体模块结构示意图。由于程序连续存放在相邻体中，故又有交叉存储之称。显然低位地址用来表示体号，高位地址为体内地址。这种编址方法又称为模M编址(M等于模块数)，表4.3列出了模4交叉编址的地址号。一般模块数M取2的方幂，使硬件电路比较简单。有的机器为了减少存储器冲突，采用质数个模块，例如，我国银河机的M为31,其硬件实现比较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183908836.png" class="" title="image-20230904183908836"><ul><li>高性能存储芯片<ul><li>SDRAM(同步DRAM):在系统时钟的控制下进行读入和写出，CPU无需等待</li><li>RDRAM:有Rambus开发，只要解决存储宽带问题</li><li>带Cache的DRAM:在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</li></ul></li></ul><h4 id="3-3高速缓冲存储器"><a href="#3-3高速缓冲存储器" class="headerlink" title="3.3高速缓冲存储器"></a>3.3高速缓冲存储器</h4><h5 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h5><p>在多体并行存储系统中，由于I&#x2F;O设备向主存请求的级别高于CPU访存，这就出现了CPU等待&#x2F;0设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU的工作效率。为了避免CPU与I&#x2F;O设备争抢访存，可在CPU与主存之间加一级缓存，这样，主存可将CPU要取的信息提前送至缓存，一旦主存在与&#x2F;0设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。从另一角度来看，主存速度的提高始终跟不上CPU的发展。据统计，CPU的速度平均每年改进60%，而组成主存的动态RAM速度平均每年只改进7%，结果是CPU和动态RAM之间的速度间隙平均每年增大50%。例如，100MHz的Pentium处理器平均每10ns就执行一条指令，而动态RAM的典型访问时间为60~120ns。这也希望由高速缓存Cache来解决主存与CPU速度的不匹配问题。</p><p>Cache的出现使CPU可以不直接访问主存，而与高速Cache交换信息。那么，这是否可能呢？通过大量典型程序的分析，发现CPU从主存取指令或取数据，在一定时间内，只是对主存局部地址区域的访问。这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用（如子程序、循环程序和一些常数），即指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性，这就称为程序访问的局部性原理。根据这一原理，很容易设想，只要将CPU近期要用到的程序和数据提前从主存送到Cache,那么就可以做到CPU在一定时间内只访问Cache.。一般Cache采用高速的SRAM制作，其价格比主存贵，但因其容量远小于主存，因此能很好地解决速度和成本的矛盾。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904184832650.png" class="" title="image-20230904184832650"><h6 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h6><p>任何时刻都有一些主存块处在缓存块中。CPU欲读取主存某字时，有两种可能：一种是所需要的字已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字)；另一种是所需的字不在Cache内，此时需将该字所在的主存整个字块一次调入Cache中(Cache与主存之间是字块传送)。如果主存块已调入缓存块，侧称该主存块与缓存块建立了对应关系。</p><p>上述第一种情况为CPU访问Cache命中，第二种情况为CPU访问Cache不命中。由于缓存的块数C远小于主存的块数M,因此，一个缓存块不能惟一地、永久地只对应一个主存块，故每个缓存块需设一个标记，用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位（或m位中的一部分）与缓存块的标记进行比较，以判断所读的信息是否已在缓存中。</p><p>Cache的容量与’块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。命中率是指CPU要访问的信息已在Cache内的比率。</p><h6 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904190947078.png" class="" title="image-20230904190947078"><ul><li>Cache存储体</li></ul><p>Cache存储体以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高。</p><ul><li>地址映射变换机构</li></ul><p>地址映射变换机构是将CPU送来的主存地址转换为Cache地址。由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。而地址变换又与主存地址以什么样的函数关系映射到Cache中（称为地址映射）有关</p><ul><li>替换机构</li></ul><p>当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache.。有关替换算法详见特别需指出的是，Cache对用户是透明的，即用户编程时所用到的地址是主存地址，用户根术不知道这些主存块是否已调入Cache内。因为，将主存块调入Cache的任务全由机器硬件自动完成。</p><ul><li>Cache的读写操作</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904195651008.png" class="" title="image-20230904195651008"><p>写操作比较复杂，因为对Cache块内写人的信息，必须与被映射的主存块内的信息完全一致。当程序运行过程中需对某个单元进行写操作时，会出现如何使Cache与主存内容保持一致的问题。目前主要采用以下几种方法。</p><ul><li>写直达法</li></ul><p>写直达法(Write-through),又称为存直达法（Store-through),即写操作时数据既写入Cache又写入主存。它能随时保证主存和Cache的数据始终一致，但增加了访存次数。</p><ul><li>写回法</li></ul><p>写回法(Write-back),又称为拷回法(Copy-back),即写操作时只把数据写入Cache而不写入主存，但当Cache数据被替换出去时才写回主存。可见写回法Cache中的数据会与主存中的不一致。为了识别Cache中的数据是否与主存一致，Cache中的每一块要增设一个标志位，该位有两个状态：“清”（表示未修改过，与主存一致）和“浊”（表示修改过，与主存不一致)。在Cache替换时，“清”的Cache块不必写回主存，因为此时主存中相应块的内容与Cache块是一致的。在写Cache时，要将该标志位设置为“浊”，替换时此Cache块要写回主存，同时要使标志位为“清”。</p><h6 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h6><p>Cache刚出现时，典型系统只有一个缓存，近年来普遍采用多个Cache。其含义.有两方面：一是增加Cache的级数；二是将统一的Cache变成分立的Cache</p><ul><li>单一缓存和二级缓存：片内Cache、片外Cache</li><li>统一缓存和分立缓存：统一缓存是指指令和数据都存放在同一缓存内的Cache;分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令Cache,一个称为数据Cache。.两种缓存的选用主要考虑如下两个因素。其一，它与主存结构有关，如果计算机的主存是统一的（指令、数据存储在同一主存内），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。其二，它与机器对指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般都采用分立缓存。</li></ul><h5 id="3-3-2-Cache——主存地址映射"><a href="#3-3-2-Cache——主存地址映射" class="headerlink" title="3.3.2 Cache——主存地址映射"></a>3.3.2 Cache——主存地址映射</h5><p>由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射（固定的映射关系)、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。</p><ul><li>直接映射</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201458711.png" class="" title="image-20230904201458711"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201608551.png" class="" title="image-20230904201608551"><p>这种方式的优点是实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。由图可见，主存地址高m位被分成两部分：低c位是指Cace的字块地址，高t位(t&#x3D;m一c)是指主存字块标记，它被记录在建立了对应关系的缓存块的“标记”位中。当缓存接到CPU送来的主存地址后，只儒根据中间c位字段（假设为00…01）找到Cache字块1，然后根据字块1的“标记”是否与主存地址的高t位相符来判断，若符合且有效位为“1”（有效位用来识别Cache存储块中的数据是否有效，因为有时Cache中的数据是无效的，例如，在初始时刻Cache应该是“空”的，其中的内容是无意义的)，表示该Cache块已和主存的某块建立了对应关系（即已命中)，则可根据b位地址从Cace中取得信息；若不符合，或有效位为“0”（即不命中)，则从主存读人新的字块来替代旧的字块，同时将信息送往CPU,并修改Cache“标记”。如果原来有效位为“0”，还得将有效位置成“1”。</p><p>直接映射方式的缺点是不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><ul><li>全相联映射</li></ul><p>全相联映射允许主存中每一字块映射到Cache中的任何一块位置上，如图所示。这种映射方式可以从已被占满的Cache中替换出任一旧字块。显然，这种方式灵活，命中率也更高，缩小了块冲突率。与直接映射相比，它的主存字块标记从t位增加到：t+c位，这就使Cache“标记”的位数增多，而且访问Cache时主存字块标记需要和Cache的全部“标记”位进行比较，才能判断出所访问主存地址的内容是否已在Cache内。这种比较通常采用“按内容寻址”的相联存储器（见附录4A)来完成。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904202232710.png" class="" title="image-20230904202232710"><p>总之，这种方式所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。</p><ul><li>组相联映射</li></ul><p>组相联映射是对直接映射和全相联映射的一种折中。它把Cache分为Q组，每组有R块，并有以下关系：</p><p>i&#x3D;j mod Q</p><p>其中，i为缓存的组好，j为主存的块号。某一主存块按模Q将其映射到级存的第i组内</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904203103631.png" class="" title="image-20230904203103631"><ul><li>直接 ：某一 主存块只能固定映射到某一缓存块 </li><li>全相联 ：某一主存块能映射到任一缓存块</li><li>组相联  ：某一主存块只能映射到某一缓存组中的任一块</li></ul><h5 id="3-3-3替换策略"><a href="#3-3-3替换策略" class="headerlink" title="3.3.3替换策略"></a>3.3.3替换策略</h5><ul><li>先进先出（First-In-First-Out,FIFO）</li></ul><p>FIF0算法选择最早调入Cache的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，开销小，但没有根据访存的局部性原理，故不能提高Cache的命中率。因为最早调人的信息可能以后还要用到，或者经常要用到，如循环程序。</p><ul><li>近期最少使用算法(Least Recently Used,LRU）</li></ul><p>LRU算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它需要随时记录Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU算法的平均命中率比FIFO的高。</p><ul><li>随机法</li></ul><p>随机法是随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块，但它也没有根据访存的局部性原理，故不能提高Cache的命中率。</p><h4 id="3-4辅助存储器"><a href="#3-4辅助存储器" class="headerlink" title="3.4辅助存储器"></a>3.4辅助存储器</h4><h5 id="3-4-1概述"><a href="#3-4-1概述" class="headerlink" title="3.4.1概述"></a>3.4.1概述</h5><p>辅助存储器作为主存的后援设备又称为外部存储器，简称外存，它与主存一起组成了存储器系统的主存一辅存层次。与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。而主存具有速度快、成本高、容量小等特点，而且大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。</p><p>目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。</p><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul><li>不能直接与CPU交换信息</li></ul><h6 id="磁表面存储技术"><a href="#磁表面存储技术" class="headerlink" title="磁表面存储技术"></a>磁表面存储技术</h6><ul><li>记录密度</li><li>存储容量</li><li>平均寻址时间 </li><li>数据传输率 </li><li>误码率 辅存的速</li></ul><h5 id="3-4-2磁记录原理和记录方式"><a href="#3-4-2磁记录原理和记录方式" class="headerlink" title="3.4.2磁记录原理和记录方式"></a>3.4.2磁记录原理和记录方式</h5><ul><li>磁记录原理</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204226140.png" class="" title="image-20230904204226140"><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204245123.png" class="" title="image-20230904204245123"><ul><li>磁表面存储器的记录方式</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204359480.png" class="" title="image-20230904204359480"><h5 id="3-4-3硬度磁盘存储器"><a href="#3-4-3硬度磁盘存储器" class="headerlink" title="3.4.3硬度磁盘存储器"></a>3.4.3硬度磁盘存储器</h5><h6 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h6><ul><li>固定磁头和移动磁头 </li><li>可换盘和固定盘</li></ul><h6 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204604155.png" class="" title="image-20230904204604155"><p>硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片3大部分组成</p><ul><li>磁盘驱动器</li></ul><p>磁盘驱动器是主机外的一个独立装置，又称磁盘机。大型磁盘驱动器要占用一个或几个机柜，温盘只是一个比砖还小的小匣子。驱动器主要包括主轴、定位驱动及数据控制等3部分。图示意了磁盘驱动器的主轴系统和定位驱动系统。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204817860.png" class="" title="image-20230904204817860"><ul><li><p>磁盘控制器</p><ul><li>接收主机发来的命令，转换成磁盘驱动器的控制命令 </li><li>实现主机和驱动器之间的数据格式转换 </li><li>控制磁盘驱动器读写</li></ul><p>磁盘控制器是主机与磁盘驱动器之间的接口</p></li><li><p>盘片：由硬质铝合金材料制成</p></li></ul><h5 id="3-4-4软磁盘存储器"><a href="#3-4-4软磁盘存储器" class="headerlink" title="3.4.4软磁盘存储器"></a>3.4.4软磁盘存储器</h5><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>高</td><td>低</td></tr><tr><td>磁头</td><td>固定、活动、浮动</td><td>活动</td></tr><tr><td>盘片</td><td>固定盘、盘组 大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>环境</td><td>苛刻</td><td></td></tr></tbody></table><h5 id="3-4-7光盘存储器"><a href="#3-4-7光盘存储器" class="headerlink" title="3.4.7光盘存储器"></a>3.4.7光盘存储器</h5><p>采用光存储技术 采用非磁性介质 采用磁性介质 </p><p>第一代光存储技术 不可擦写</p><p>第二代光存储技术  可擦写</p><h6 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h6><p>只读型和只写一次型 热作用（物理或化学变化）</p><p>可擦写光盘  热磁效应 </p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统总线(二)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>本章着重介绍系统总线的基本概念及其分类、结构和总线控制，逻辑。要求读者能对系统总<br>线在计算机硬件结构中的地位和作用有所了解。</p><span id="more"></span><h4 id="2-1系统总线的基本概念"><a href="#2-1系统总线的基本概念" class="headerlink" title="2.1系统总线的基本概念"></a>2.1系统总线的基本概念</h4><h5 id="2-1-1什么是总线？"><a href="#2-1-1什么是总线？" class="headerlink" title="2.1.1什么是总线？"></a>2.1.1什么是总线？</h5><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质</p><h5 id="2-1-2总线上的信息传送"><a href="#2-1-2总线上的信息传送" class="headerlink" title="2.1.2总线上的信息传送"></a>2.1.2总线上的信息传送</h5><p>串行</p><p>并行</p><h4 id="2-2-总线的分类"><a href="#2-2-总线的分类" class="headerlink" title="2.2 总线的分类"></a>2.2 总线的分类</h4><h5 id="2-2-1-片内总线"><a href="#2-2-1-片内总线" class="headerlink" title="2.2.1 片内总线"></a>2.2.1 片内总线</h5><p>片内总线：指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间，寄存器与算逻单元ALU之间都由片内总线连接</p><h5 id="2-2-2-系统总线"><a href="#2-2-2-系统总线" class="headerlink" title="2.2.2 系统总线"></a>2.2.2 系统总线</h5><p>系统总线分三类：数据总线、地址总线、控制总线</p><p>数据总线：用来传输各个功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关</p><p>地址总线：主要用来指出数据总线上的源数据或目的数据在主存单元的地址或I&#x2F;O设备地址，单项传输，与存储地址、I&#x2F;O地址有关</p><p>控制总线：用来发出各种控制信号的传输线，控制信号有输入（存储器读、存储器写、总线允许、中断确认）；控制信号有输出（中断请求、总线请求）</p><p>常见的控制型号如下：</p><ul><li>时钟：用来同步各个操作</li><li>复位：初始化所有部件</li><li>总线请求：表示某部件需获得总线使用权</li><li>总线允许：表示需要获得总线使用权的部件以获得控制权</li><li>中断请求：表示某部件提出中断请求</li><li>中断响应：表示中断请求已被接收</li><li>存储器写：将数据总线上的数据写至存储器的指定单元内</li><li>存储器读：将指定存储单元中的数据读到数据总线上</li><li>I&#x2F;O读：从指定的I&#x2F;O端口将数据读到数据总线上</li><li>I&#x2F;O写：将数据总线上的数据输出到指定的I&#x2F;O端口内</li><li>传输响应:表示数据应被接受，或已将数据送至数据总线上</li></ul><h5 id="2-2-3-通信总线"><a href="#2-2-3-通信总线" class="headerlink" title="2.2.3 通信总线"></a>2.2.3 通信总线</h5><p>通信总线：用于计算机系统之间或计算机系统与其他系统（控制仪表、移动通信等）之间的通信</p><p>传输方式：串行通信总线、并行同行总线</p><p>串行总线：是指数据在单条1位宽的传输线上，一位一位地按顺序分时传送，如1字节的数据，在串行传送中，1字节的数据要通过8此有地位到高位按顺序逐位传输</p><p>并行总线：是指数据在多条并行在1位宽的传输线上，同时由源传送到目的地，如1字节的数据，在并行传送中，要通过8条并行传输线同时由源传送到目的地。</p><h4 id="2-3总线特性及性能指标"><a href="#2-3总线特性及性能指标" class="headerlink" title="2.3总线特性及性能指标"></a>2.3总线特性及性能指标</h4><h5 id="2-3-1-总线的特征"><a href="#2-3-1-总线的特征" class="headerlink" title="2.3.1 总线的特征"></a>2.3.1 总线的特征</h5><ul><li>机型特性：尺寸、形状、管脚数 及排列顺序</li><li>电器特性：传输方向和有效的电平范围</li><li>功能特性：每根传输线的功能</li></ul><p>​功能分类：地址、数据、控制</p><p>​地址总线：用来指出地址码</p><p>​数据总线：用来传递数据</p><p>​控制总线：发出信号控制，既有从CPU发出的如存储器的读&#x2F;写、I&#x2F;O的读&#x2F;写，也有I&#x2F;O向CPU发来的，如中断请求、DMA请求</p><ul><li>时间特性：信号的时序关系</li></ul><h5 id="2-3-2-总线性能指标"><a href="#2-3-2-总线性能指标" class="headerlink" title="2.3.2 总线性能指标"></a>2.3.2 总线性能指标</h5><ul><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟同步&#x2F;异步：同步、不同步</li><li>总线复用：地址线与数据线复用</li><li>信号线数：地址线、数据线、控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、技术</li><li>其他指标：负载能力</li></ul><h5 id="2-3-3总线标准"><a href="#2-3-3总线标准" class="headerlink" title="2.3.3总线标准"></a>2.3.3总线标准</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110537846.png" class="" title="image-20230828110537846"><h4 id="2-4总线结构"><a href="#2-4总线结构" class="headerlink" title="2.4总线结构"></a>2.4总线结构</h4><h5 id="2-4-1-单总线结构"><a href="#2-4-1-单总线结构" class="headerlink" title="2.4.1 单总线结构"></a>2.4.1 单总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110613375.png" class="" title="image-20230828110613375"><h5 id="2-4-2多总线结构"><a href="#2-4-2多总线结构" class="headerlink" title="2.4.2多总线结构"></a>2.4.2多总线结构</h5><p>双总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110652825.png" class="" title="image-20230828110652825"><h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110711335.png" class="" title="image-20230828110711335"><p>三总线的另一结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110728329.png" class="" title="image-20230828110728329"><h5 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h5><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110750849.png" class="" title="image-20230828110750849"><h5 id="2-4-3总线结构举例"><a href="#2-4-3总线结构举例" class="headerlink" title="2.4.3总线结构举例"></a>2.4.3总线结构举例</h5><p>传统微型机总线</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110815002.png" class="" title="image-20230828110815002"><p>VL-BUS局部总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110840540.png" class="" title="image-20230828110840540"><p>PCI总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110904069.png" class="" title="image-20230828110904069"><p>多层 PCI 总线结构</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828110922273.png" class="" title="image-20230828110922273"><h4 id="2-5总线控制"><a href="#2-5总线控制" class="headerlink" title="2.5总线控制"></a>2.5总线控制</h4><h5 id="2-5-1-总线判优控制"><a href="#2-5-1-总线判优控制" class="headerlink" title="2.5.1 总线判优控制"></a>2.5.1 总线判优控制</h5><p>基本概念：</p><ul><li><p>主模块对总线有控制权</p></li><li><p>从模块        响应从主设备发来的总线命令</p></li><li><p>总线判优控制：集中式、分布式</p><p>集中式包括：</p><ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li></ul><p>链式查询方式</p><p>下图为链式查询，图中控制总线有3根线用于总线控制（BS总线忙、BR总线请求、BG总线统一），其中总线同意是串行的一个I&#x2F;O接口送至下一个I&#x2F;O接口。如果BG达到的接口有请求，BG信号就不再往下传，意味着改接口获得了总线的使用全，并建立总线忙BS信号，表示它占用了总线，可见在链式查询中，离总线控制部件最近的设备具有最高的优先级。这种方式的特点是：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，！对电路故障很敏感，且优光级别低的设备可能很难获得请求。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111006976.png" class="" title="image-20230828111006976"><p>计数器定时查询方式</p><p>下图是计数器定时查询方式。与链式查询方式相比，多了一组设备地址线，少了一<br>根总线同意线BG。总线控制部件接到由BR送来的总线请求信号后，在总线未被使用(BS&#x3D;0)<br>的情况下，总线控制部件屮的计数器开始计数，并通过设备地址线.向各设备发出一组地址信号。<br>当某个请求占用总线的设备地址与计数值一致时，便获得总线使用权，此吋终止计数查询。这种<br>方式的特点是：计数可以从“0”开始，此时一且设备的优先次序被固定，设备的优先级就按<br>0,1,…,n的顺序降序排列，而且固定不变；计数也可以从上一次计数的终止点开始，即是一种循<br>环方法，此时设备使用总线的优先级相等；计数器的初始值还可由程序设置，战优先次序可以改变。<br>这种方式对电路故障不如链式查询方式敏感，但增加了控制线（设备地址）数，控制也较复杂。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111057390.png" class="" title="image-20230828111057390"><p>​独立亲求方式</p><p>下图是独立请求方式。由图中可见，每一台设备均有一对总线请求线BR,和总线同意线BG:。当设备要求使用总线时，便发出该设备的请求信号。总线挖制部件中有一排队电路，可根据优先次序确定响应哪一台设备的靖求。这种方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），似控制线数量多，总线控删更复杂。链式查询中仪用两根线确定总线使用权属于哪个设备，在计数器查询巾大致用log2 n根线，其中n是允许接纳的最大设备数，而独立请求方式需采用2n根线。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111148122.png" class="" title="image-20230828111148122"><h5 id="1-5-2总线通信控制"><a href="#1-5-2总线通信控制" class="headerlink" title="1.5.2总线通信控制"></a>1.5.2总线通信控制</h5><p>目的：解决通信双方协调配合问题</p><p>总线传输周期：</p><ul><li>中请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者。</li><li>寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与木次传输的从模块。</li><li>传数阶段：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流人目的模块。</li><li>结束阶段：主模块的有关信息均从系统总线上撒除，让出总线使用权。</li></ul><p>总线通信的四种方式：</p><ul><li>同步通信：有统一时标控制数据传送</li><li>异步通信：采用应答方式，没有公共时钟标准</li><li>半同步通信：同步、异步结合</li><li>分离式通信：充分挖掘系统 总线每个瞬间的潜力</li></ul><p>某个输入设备向CPU传输数据的同步通信（同步式数据输入传输）</p><p>对于读命令，其传输周期如下：</p><ul><li>T1:主模块发地址。</li><li>T2:主模块发读命令。</li><li>T3:从模块提供数据。</li><li>T4:主模块撤销读命令，从模央撤销数据。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111244151.png" class="" title="image-20230828111244151"><p>图中总线传输周期是连接在总线上的两个部件完成一次完整且可靠的信息传输时间，它包<br>含4个时钟周期T1、T2、T3、T4。<br>        CPU在T1上升沿发出地址信息；在T2的上升沿发出读命令；与地址信号相符合的输入设备<br>按命令进行一系列内部操作，且必须在T3的上升沿到来之前将CPU所需的数据送到数据总线<br>上：CPU在T3时钟周期内，将数据线上的信息送到其内部寄存器中；CPU在T4的上升沿撤销读<br>命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。如果总线采用三态驱动<br>电路，则从T4起，数据总线呈浮空状态。</p><p>同步式数据输出传输</p><p>对于写命令，其传输周期如下：</p><ul><li>T1:主模块发地址</li><li>T1.5：主模块提供数据。</li><li>T2：主模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到<br>地址总线所指明的单元中。</li><li>T4：主模块撤销写命令和数据等信号。</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111309016.png" class="" title="image-20230828111309016"><p>这种通信的优点是规定明确、统一，模块间的配合简单一致。其缺点是主、从模块时间配合属于强制性“同步”，必须在限定时问内完成规定的要求。并对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而市，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏贝活性。</p><p>同步通信一般用于总线长度较短、各部件存取时问比较一致的场合。</p><p>在同步通信的总线系统中，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率。</p><p>异步通信</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828111331035.png" class="" title="image-20230828111331035"><p>1、不互锁方式</p><p>主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块<br>已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并<br>且经过一段时问（这段时问的设置对不同设备而言是不同的）确认主模块已收到回答信号后，自<br>动撤销回答信号。可见通信双方并无互锁关系。例如，CPU向主存写信息，CPU要先后给出地<br>址信号、写命令以及写入数据，即采用此种方式。</p><p>2、半互锁方式</p><p>主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系：而<br>从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一<br>段时间后自动撒销其回答信号，无互锁关系。由于一方存在互锁关系，一方不存在互锁关系，故<br>称半互锁方式。例如，在多机系统中，某个CPU需访问共享存储器（供所有CPU访问的存储器）<br>时，该CPU发出访存命令后，必须收到存储器未被占用的回答信号，才能真正进行访存操作。</p><p>3、全互锁</p><p>主模块发出请求信号，必须待从模块回答后再撤销其请求信号；从模块发出回答信号，必须<br>待获知主模块请求信号已撤销后，再撤销其回答信号。双方存在互锁关系，故称为全互锁方式。<br>例如，在网络通信中，通信双方采用的就是全互锁方式。</p><p>半同步通信（同步、异步结合）</p><ul><li>同步:发送方用系统 时钟前沿 发信号；接收方用系统 时钟后沿 判断、识别</li><li>异步：允许不同速度的模块和谐工作，增加一条 “等待”响应信号 WAIT</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/image-20230828112117228.png" class="" title="image-20230828112117228"><p>以输入数据为例的半通信时序</p><ul><li><p>T1:主模块发出地址信息</p></li><li><p>T2：主模块发出命令</p></li><li><p>T2当WAIT为低电平时，进入等待，Tw的宽度与T的宽度一致。</p></li><li></li><li></li><li></li><li><p>T3:从模块提供数据。</p></li><li><p>T4:主模块撤销读命令，从模块撤销数据。</p></li></ul><p>上述三种通信的共同电：</p><ul><li>主模块发地址、命令占用总线</li><li>从模块准备数据        不占用总线  总线空闲</li><li>从模块向主模块发数据     占用总线</li></ul><p>分离式通信</p><p>以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结束。在整个传输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据。进一步分析读命令传输周期，发现除了中请总线这一阶段外，其余时间主要花费在如下3个方面。<br>①主模块通过传输总线向从模块发送地址和命令。<br>②从模块按照命令进行读数据的必要淮备。<br>③从模块经数据总线向主模块提供数据。·<br>由②可见，对系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待，为了克服和利用这种消极等待，尤其在大型计算机系统中，总线的负载已处于饱和状态，充分挖掘系统总线每瞬间的潜力，对提高系统性能起到极大作用。为此人们又提出了“分离式”的通信方式，其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第一个子周期中，主模块A在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号（当有多个主模块时，此编号尤为重要)发到系统总线上，经总线传输后，由有关的从模块B接收下来。主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使州权，以便其他模块使用。在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将A模块所需的数据准备好，使出B模块中请总线使用权，一旦获谁，B模块便将A模块的编号、B模块的地址、A模块所器的数据等一系列信息送到总线上，供A模块接收。很明显，上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。</p><p>分离式通信特点：</p><ul><li>各模块欲占用总线使用权都必须提出申请。</li><li>在得到总线使用权后，主模块在限定的刷间内向对方传送信总，采用同步方式传送，不再等待对方的回答信号。</li><li>各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。</li><li>总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概论(一)</title>
    <link href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/"/>
    <url>/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>本章主要介绍计算机的组成概貌及工作原理，旨在使读者对计算机总体结构有一个概括的<br>了解，为深入学习后面各章打下基础。</p><span id="more"></span><h4 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h4><h5 id="1-1-1-计算机的软硬件概念"><a href="#1-1-1-计算机的软硬件概念" class="headerlink" title="1.1.1 计算机的软硬件概念"></a>1.1.1 计算机的软硬件概念</h5><p><strong>计算机系统有“硬件”和“软件”两大部分组成。</strong></p><p>​<strong>硬件</strong>：计算机的实体，如主机、外设等</p><p>​<strong>软件</strong>：由具有各类特殊的功能的信息（程序）组成</p><p>软件可以分为</p><p>​<strong>系统软件</strong>：用来管理整个计算机系统 。如 语言处理程序、操作系统、服务型程序、数据库管理系统、网络软件</p><p>​<strong>应用软件</strong>：按任务需要编制成的各种程序</p><h5 id="1-1-2-计算机系统的成层次结构"><a href="#1-1-2-计算机系统的成层次结构" class="headerlink" title="1.1.2 计算机系统的成层次结构"></a>1.1.2 计算机系统的成层次结构</h5><p><strong>方向：M4→M3→M2→M1→M0</strong></p><p>虚拟机器M4(高级语言机器)用编译程序翻译成汇编语言程序</p><p>虚拟机器M3(汇编语言机器)用汇编程序翻译成机器语言程序</p><p>虚拟机器M2(操作系统机器)用机器语言解释操作系统</p><p>传统机器M1(机器语言机器)用微程序解释机器指令</p><p>微程序机器M0(微指令系统)有硬件直接执行微指令</p><h5 id="1-1-3计算机组成和计算机体系结构"><a href="#1-1-3计算机组成和计算机体系结构" class="headerlink" title="1.1.3计算机组成和计算机体系结构"></a>1.1.3计算机组成和计算机体系结构</h5><p><strong>计算机体系结构</strong>：是指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。计算机系统的属性通常是指用机器语言编程的程序员所能看到的传统机器的属性，包括指令集、数据类型、存储器寻址技术、I&#x2F;O机理等，大都属于抽象概念</p><p><strong>计算机组成</strong>：是指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。例如，指令系统体现了机器的属性，这属于<em>计算机结构</em>的问题。但是指令的实现，即如何取出指令，分析指令，取操作数、运算、送结果等，这些属于<em>计算机组成问题</em></p><h4 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h4><h5 id="1-2-1冯·诺伊曼计算机的特点"><a href="#1-2-1冯·诺伊曼计算机的特点" class="headerlink" title="1.2.1冯·诺伊曼计算机的特点"></a>1.2.1冯·诺伊曼计算机的特点</h5><ul><li>计算机有运算器、存储器、控制器、输入设备、输出设备五大部件组成</li><li>指令和数据以同等的地位存放与存储器内，并可按地址访问</li><li>指令和数据均用二进制数表示</li><li>指令有操作码和地址码组成，操作码可以用来表示操作的性质，地址码可以用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定的条件下，可以根据运算结果或根据设定的条件改变执行的顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ul><h5 id="1-2-2计算机的硬件框图"><a href="#1-2-2计算机的硬件框图" class="headerlink" title="1.2.2计算机的硬件框图"></a>1.2.2计算机的硬件框图</h5><p>典型的冯·诺伊曼计算机解构框图</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201047407.png" class="" title="image-20230827201047407"><p>图中各部件的功能如下：</p><ul><li>运算器用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内</li><li>存储器用来存放数据指令和程序</li><li>控制器用来控制、指挥程序和数据的输入、运行及处理运算结果</li><li>输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有鼠标、键盘等</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等</li></ul><p>由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往集成在同一个芯片上，因此，通常将他们合起来称作中央处理器（Central Processing Unit,CPU）。把输入输出设备简称为I&#x2F;O设备（Input&#x2F;Output Equipment）</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201352277.png" class=""><p>主存储器是存储器子系统中的一类，用来存放程序和数据，可以直接与CPU交换信息。另一类成为辅助存储器，简称辅存，又称外存。</p><p>算数逻辑单元（Arithmetic Logic Unit,ALU）简称算逻部件，用来完成算术逻辑运算。</p><p>控制单元（Control Unit ,CU）用来解释存储器中的指令，并发出各种操作命令来执行指令。</p><p>ALU和CU是CPU的核心</p><p>I&#x2F;O设备也受CU控制，用来完成相对应的输入和输出操作</p><h5 id="1-2-3计算机的工作步骤"><a href="#1-2-3计算机的工作步骤" class="headerlink" title="1.2.3计算机的工作步骤"></a>1.2.3计算机的工作步骤</h5><p>用计算机解决问题有两大步骤。一是上机前的准备，另一个是上机运行</p><h6 id="上机前的准备"><a href="#上机前的准备" class="headerlink" title="上机前的准备"></a>上机前的准备</h6><ol><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序</li></ol><h6 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202137512.png" class="" title="image-20230827202137512"><h6 id="存储器的基本组成："><a href="#存储器的基本组成：" class="headerlink" title="存储器的基本组成："></a>存储器的基本组成：</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827201750247.png" class=""><p>主存储器包括存储体、各种逻辑部件及控制电路，存储体由很多存储单元组成，每个存储单元又包括若干个存储元件，每个存储元件存放一个二进制代码“0”和“1”。一个存储单元可以储存一串二进制代码，称这串二进制代码为一个存储字，这串二进制代码的位数成为存储字长。</p><ol><li>存储单元:存放一串二进制代码</li><li>存储字:存储单元中二进制代码的组合</li><li>存储字长:存储单元中二进制代码的位数 每个存储单元赋予一个地址号</li></ol><p>为了实现按地址访问的形式，主存中还得必须配置两个寄存器MAR和MDR</p><ol><li>MAR:存储器地址寄存器，反映存储单元的个数</li><li>MDR:存储器数据寄存器，反映存储字节长度</li></ol><p>设RAM&#x3D;4 位  MDR&#x3D;8位则 存储单元个数位16个，存储字长为8</p><h6 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h6><p>运算器最少包括三个寄存器和一个算数逻辑单元（ALU）其中ACC是累加器，MQ为乘商寄存器，X为操作数寄存器</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202644280.png" class="" title="image-20230827202644280"><p>M表示存储器的任意地址号，[M]表示对应M地址单元中的内容；X表示X寄存器,[X]表示X寄存器的内容；ACC表示累加器，[ACC]表示累加器中的内容；MQ表示乘商寄存器，[MQ]表示乘商寄存器中的内容</p><p>加法操作过程</p><p>假设ACC已经有前一时刻的运算运算结果，并作为下述运算中的一个操作数</p><p>即将[ACC]中看作被加数，先从主存中取一个存放在M地址号单元的加数[M]，送至运算器的X寄存器中，然后将被加数[ACC]与加数[X]相加，结果(和)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202827546.png" class="" title="image-20230827202827546"><p>减法操作过程</p><p>即将[ACC]中看作被减数，先从主存中取一个存放在M地址号单元的减数[M]，送至运算器的X寄存器中，然后将[ACC]-[X]，结果(差)保留在ACC中</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202846884.png" class="" title="image-20230827202846884"><p>乘法操作过程</p><p>即将[ACC]看作被乘数，先取出存放在主存M号地址单元中的乘数[M]并送入乘商寄存器MQ,在把被乘数送入X寄存器，并将ACC清“0”,然后[X]和[MQ]相乘，结果（积）的高位保留在ACC中，地位保留MQ中。</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202907215.png" class="" title="image-20230827202907215"><p>除法操作过程</p><p>即将[ACC]看作被除数，先取出存放在M地址单元内的除数[M]并送至X寄存器，然后[ACC]除以[X]，结果（商）暂留与MQ,[ACC]为余数R。若需要将商保留在ACC中，只需要做一步[MQ]→ACC即可</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827202931819.png" class="" title="image-20230827202931819"><p>控制器</p><p>控制器由程序计数器（Program Counter,PC）、指令寄存器（Instruction Register,IR）以及控制单元（CU）组成</p><p>PC：用来存放当前欲执行指令的地址，它与主存的MAR之间有一条直接通路且具有自动加1的功能，即可自动形成下一条指令的地址。</p><p>IR:用来存放当前的指令，IR的内来自主存的MDR。IR中的操作码（OP(IR)）送至CU,记作OP(IR)→CU,用来分析指令；其地址码（Ad(IR)）作为操作数的地址送至存储器的MAR,记作Ad(IR)→MAR。</p><p>CU：用来分析当前的指令所需完成的操作，并发出各种微操作命令序号，用以控制所有被控制对象</p><p>完成一条指令需要三个步骤：取指令、分析指令、执行指令</p><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203029187.png" class="" title="image-20230827203029187"><p>主机完成一条指令的过程</p><p>取指数为例</p><ol><li><p>PC把指令送给MAR</p></li><li><p>MAR把指令送给存储体</p></li><li><p>在控制器的控制下，把存储体指定存储单元中的那条取数指令取出，并送入MDR中</p></li><li><p>将取出的指令送入IR中</p><hr></li><li><p>把IR的操作码送入CU</p></li><li><p>CU经过译码后，在控制器的控制下，把指令中的地址部分送给存储器，以便数据从存储体中取出</p></li><li><p>MAR将地址送给存储体</p></li><li><p>在控制器的控制之下，把存储体中我们需要取的数送至MDR中</p></li><li><p>然后将MDR的数据送入ACC</p></li></ol><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203302609.png" class="" title="image-20230827203302609"><p>例子：</p><p>首先按下图的有序指令和数据，通过键盘输入到主从第0号至第12号单元中，并置PC的初始值为0（令程序的首选地址为0）。启动机器后，计算机便自动按存储器中所存放的指令顺序有序地逐条完成取指令、分析指令、和执行指令，直至最后一条指令为止。</p><p>例如</p><ul><li>PC→MAR,并命令存储器做读操作，此时0号单元中的内容”0000010000001000”,便被送入到MDR内</li><li>MDR→IR,完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000001”为取数指令</li><li>于是CU将IR中的地址码“0000001000”送至MAR(记作Ad(IR)→MAR),并命令存储器做只读操作</li><li>将地址单元的操作数X送至MDR</li><li>再由MDR中送至ACC中，完成指令的执行过程，此时完成第一条取数指令的全过程，即操作数在X送至运算器ACC中</li><li>PC完成自动加1操作，形成下一条指令的地址“1”</li><li>PC将第二条指令送入MAR中，命令主存储器做只读操作，将“0001000000001001”送入MDR中</li><li>MDR→IR，完成一条取指令的过程</li><li>经过CU分析（记作OP(IR)→MAR）,操作码为“000100”为乘法指令</li><li>CU向存储体发出读命令，取出对应地址为“0000001001”单元的操作数a</li><li>a经MDR送至运算器MQ</li><li>CU在向运算器发送乘法操作命令，完成ax的运算，并把结果ax存放在ACC中</li><li>PC+1→PC,形成下一条指令的地址“2”号</li></ul><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20230827203825422.png" class="" title="image-20230827203825422"><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%80/image-20231018154214841.png" class="" title="image-20231018154214841">]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
