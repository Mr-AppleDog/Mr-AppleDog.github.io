

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="存储器(三)">
<meta property="og:url" content="http://example.com/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/background/3.jpg">
<meta property="article:published_time" content="2023-08-27T13:00:02.000Z">
<meta property="article:modified_time" content="2023-09-05T13:45:41.270Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/background/3.jpg">
  
  
  
  <title>存储器(三) - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/background/00.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="存储器(三)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-27 21:00" pubdate>
          2023年8月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          126 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">存储器(三)</h1>
            
            
              <div class="markdown-body">
                
                <p>本章重点介绍主存储器的分类、工作原理、组成方式以及与其他部件（如CPU)的联系。此<br>外还介绍了高速缓冲存储器、磁表面存储器等的基本组成和工作原理。</p>
<span id="more"></span>

<h4 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h4><h5 id="3-1-1存储器的分类"><a href="#3-1-1存储器的分类" class="headerlink" title="3.1.1存储器的分类"></a>3.1.1存储器的分类</h5><p>按存储介质分类：</p>
<ul>
<li>半导体存储器	TTL 、MOS</li>
<li>磁表面存储器    磁头、磁载体</li>
<li>磁芯存储器        硬磁材料、环中元件</li>
<li>光盘存储器        激光、磁光材料</li>
</ul>
<p>按存取方式分类：</p>
<p>​	存取时间与物理地址无关（随机访问）</p>
<ul>
<li>随机存取器       在程序的执行过程中可读可写</li>
<li>只读存储器       在程序的执行过程中只读</li>
</ul>
<p>​	存取时间与物理地址有关（串行访问）</p>
<ul>
<li>顺序存取存储器     磁带</li>
<li>直接存取存储器     磁盘</li>
</ul>
<p>按在计算机中的作用分类：</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114021837.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828114021837">



<h5 id="3-1-2存储器的层次结构"><a href="#3-1-2存储器的层次结构" class="headerlink" title="3.1.2存储器的层次结构"></a>3.1.2存储器的层次结构</h5><ul>
<li>存储器三个主要特性的关系</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114241506.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828114241506">

<ul>
<li>缓存 -主存层次和主存 -辅存层次</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114428289.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828114428289">

<h4 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h4><h5 id="3-2-1概述"><a href="#3-2-1概述" class="headerlink" title="3.2.1概述"></a>3.2.1概述</h5><p>主存储器（简称主存）的基本结构已在第1章介绍过。实际上，根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p>
<h6 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828114829534.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828114829534">

<h6 id="主存与CPU的联系"><a href="#主存与CPU的联系" class="headerlink" title="主存与CPU的联系"></a>主存与CPU的联系</h6><p>现代计算机的主存都由半导体集成电路构成，图中的驱动器、译码器和读写电路均制作在存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和CPU芯片可通过总线连接</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115057618.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828115057618">

<p>当要从存储器读出某一信息字时，首先由CPU将该字的地址送到MAR,经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读至数据总线上，至于该信息由MDR送至什么地方，这已不是主存的任务，而是由CPU决定的。若要向主存存入一个信息字时，首先CPU将该字所在主存单元的地址经MAR到地址总线，并将信息字送入MDR,然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写人到对应地址线指出的主存单元中。</p>
<h6 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h6><p>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写人一个存储字。不同的机器存储字长也不同，为了满足字符处理的需要，常用8位二进制数表示一个字节，因此存储字长都取8的倍数。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370机的字长为32位，它可按字节寻址，即它的每一个存储字包含4个可独立寻址的字节，其地址分配如图所示。字地址是用该字高位字节的地址来表示，故其字地址是4的整数倍，正好用地址码的末两位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828115954328.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828115954328">

<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120051543.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828120051543">

<p>由图所示，对24位地址线的主存而言，按字节寻址的范围是16M,按字寻址的范围<br>为4M。由图所示，对24位地址线而言，按字节寻址的范围仍为16M,但按字寻址的范<br>围为8M。</p>
<h6 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h6><ul>
<li>存储容量：主存 存放二进制代码的总位数<ul>
<li>存储容量&#x3D;存储单元个数 ×存储字长</li>
</ul>
</li>
<li>存储速度<ul>
<li>存取时间：存储器的访问时间、读出时间、写入时间</li>
<li>存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间读周期 写周期</li>
</ul>
</li>
<li>存储器带宽：位&#x2F;秒</li>
</ul>
<h5 id="3-2-2半导体存储芯片介绍"><a href="#3-2-2半导体存储芯片介绍" class="headerlink" title="3.2.2半导体存储芯片介绍"></a>3.2.2半导体存储芯片介绍</h5><h6 id="半导体存储芯片的基本结构"><a href="#半导体存储芯片的基本结构" class="headerlink" title="半导体存储芯片的基本结构"></a>半导体存储芯片的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828120855844.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828120855844">

<ul>
<li><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读&#x2F;写电路的配合下完成对被选中单元的读&#x2F;写操作。</p>
</li>
<li><p>读&#x2F;写电路包括读出放大器和写人电路，用来完成读&#x2F;写操作。</p>
</li>
<li><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p>
</li>
<li><p>地址线是单向输入的，其位数与芯片容量有关。</p>
</li>
<li><p>数据线是双向的（有的芯片可用成对出现的数据线分别作为输入或输出），其位数与芯片可<br>读出或写人的数据位数有关。数据线的位数与芯片容量有关。</p>
</li>
<li><p>地址线和数据线的位数共同反映存储芯片的容量。例如，地址线为10根，数据线为4根，测芯片容量为2×4&#x3D;4K位；又如地址线为14根，数据线为1根，则其容量为16K位。</p>
</li>
<li><p>控制线主要有读&#x2F;写控制线与片选线两种。不同存储芯片的读&#x2F;写控制线和片选线可以不同。有的芯片的读&#x2F;写控制线共用1根（如2114），有的分用两根（如6264）；有的芯片的片选线用1根（如2114），有的用2根（如6264)。读&#x2F;写控制线决定芯片进行读&#x2F;写操作，片选线用来选择存储芯片。由于半导体存储器是由许多芯片组成的，为此需用片选信号来确定哪个芯片被选中。例如，一个64K×8位的存储器可由32片16K×1位的存储芯片组成，如图所示。但每次读出一个存储字时，只需选中8片。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828122056796.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828122056796"></li>
</ul>
<h6 id="半导体存储芯片的译码驱动方式"><a href="#半导体存储芯片的译码驱动方式" class="headerlink" title="半导体存储芯片的译码驱动方式"></a>半导体存储芯片的译码驱动方式</h6><p>半导体存储芯片的译码驱动方式有两种：线选法和重合法</p>
<ul>
<li>线选法</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123207033.png" srcset="/img/loading.gif" lazyload class="" title="image-20230828123207033">

<p>图是一个16×1字节线选法存储芯片的结构示意图。它的特点是用一根字选择线（字线)，直接选中一个存储单元的各位（如一个字节）。这种方式结构较简单，但只适于容量不大的存储芯片。如当地址线为1111时，则第15根字线被选中，对应图4.9中的最后一行8位代码便可直接读出或写人。</p>
<ul>
<li>重合法</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230828123235418.png" srcset="/img/loading.gif" lazyload class="">

<p>图是一个1K×1位重合法结构示意图。显然，只要用64根选择线(X、Y两个方向各32根)，便可选择32×32矩阵中的任一位。例如，当地址线为全0时，译码输出X。和Y。有效，矩阵中第0行、第0列共同选中的那位即被选中。由于被选单元是由X、Y两个方向的地址决定的，故称为重合法。当欲构成1K×1字节的存储器时，只需用8片如图4.10所示的芯片即可。</p>
<h5 id="3-2-3随机存储器"><a href="#3-2-3随机存储器" class="headerlink" title="3.2.3随机存储器"></a>3.2.3随机存储器</h5><h6 id="静态RAM-SRAM"><a href="#静态RAM-SRAM" class="headerlink" title="静态RAM(SRAM)"></a>静态RAM(SRAM)</h6><p>存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路，图4.11是一个由6个MOS管组成的基本单元电路。</p>
<p>图中T1-T4是一个由MOS管组成的触发器基本电路，T5、T6犹如一个开关，受行地址选择信号控制。由T1~T6。这6个M0S管共同构成一个基本单元电路。T7、T8。受列地址选择控制，分别与位线A’和A相连，它们并不包含在基本单元电路内，而是芯片内同一列的各个基本单元电路所共有的。</p>
<p>假设触发器已存有“1”信号，即A点为高电平。当需读出时，只要使行、列地址选择信号均有效，则使T5、T6、T7、T8均导通，A点高电平通过T6后，再由位线A通过T8作为读出放大器的输入信号，在读选择有效时，将“1”信号读出。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904132216809.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904132216809">

<p>写入时不论触发器原状态如何，只要将写入代码送至图的D端，在写选择有效时，经两个写放大器，使两端输出为相反电平。当行、列地址选择有效时，使T5、T6、T7、T8导通，并将A与A’点置成完全相反的电平。这样，就把欲写人的信息写入到该基本单元电路中。如欲写人“1”,即D&#x3D;1,经两个写放大器使位线A为高电平，位线A’为低电平，结果使A点为高，A’点为低，即写人了“1”信息。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904133958930.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904133958930">

<p>2114RAM芯片的结构示意图如图所示。图中存储矩阵由64×64个基本单元电路组成，列I&#x2F;0电路即读&#x2F;写电路。10根地址线分为行地址A8-A3和列地址A9、A2、A1、A0,4根数据线为I&#x2F;O4-I&#x2F;O0,,它们是受输入&#x2F;输出三态门控制的双向总线，当CS和WE均为低电平时，输人三态门打开，I&#x2F;O4-I&#x2F;O0,上的数据即写人到指定地址单元中。当CS为低电平、WE为高电平时，输出三态门打开，列1&#x2F;0电路的输出经片内总线输出至数据线I&#x2F;O4~I&#x2F;O0上。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904134637357.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904134637357">

<p>2114RAM芯片内的存储矩阵结构如图所示。其中每一个小方块均为一个由6个M0S管组成的基本单元电路，排列成64×64矩阵，64列对应64对T7,、T8管。又将64列分成4组，每组包含16列，并与一个读&#x2F;写电路相连，读&#x2F;写电路受WE和CS控制，4个读&#x2F;写电路对应4根数据线I&#x2F;O0-I&#x2F;O4。由图中可见，行地址经译码后可选中某一行；列地址经译码后可选中4组中的对应列，共4列。当对某个基本单元电路进行读&#x2F;写操作时，必须被行、列地址共同选中。例如，当A9-A0为全0时，对应行地址A8-A3为000000，列地址A、A2、A,、A。也为0000，则第0行的第0、16、32、48这4个基本单元电路被选中。此刻，若做读操作，则CS为低电平，WE为高电平，在读&#x2F;写电路的输出端1&#x2F;O1-I&#x2F;O4便输出第0行的第0、16、32、48这4个基本单元电路所存的信息。若做写操作，将写人信息送至I&#x2F;O0-I&#x2F;O4端口，并使CS为低电平、WE为低电平，同样这4个输人信息将分别写入到第0行的第0、16、32、48这4个单元之中。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135156790.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904135156790">

<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135227371.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904135227371">

<h6 id="动态RAM-DRAM"><a href="#动态RAM-DRAM" class="headerlink" title="动态RAM(DRAM)"></a>动态RAM(DRAM)</h6><p>常见的动态RAM基本单元电路有三管式和单管式两种，它们的共同特点都是靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。电容上的电荷一般只能维持1~2s,因此即使电源不掉电，信息也会自动消失。为此，必须在2s内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。由于它与静态RAM相比，具有集成度更高、功耗更低等特点，目前被各类计算机广泛应用。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904135533598.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904135533598">

<p>读出时，先对预充电管T4置一预充电信号（在存储矩阵中，每一列共用一个T4管)，使读数据线达高电平VDD。然后由读选择线打开T2,若T1的极间电容Cg存有足够多的电荷（被认为原存“1”)，使T1导通，则因T2、T1导通接地，使读数据线降为零电平，读出“0”信息。若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，由读出线的高低电平可区分其是读“1”，还是读“0”，只是它与原存信息反相。写入时，将写人信号加到写数据线上，然后由写选择线打开T3,这样，C.便能随输入信息充电（写“1”）或放电（写“0”）。</p>
<p>为了提高集成度，将三管电路进一步简化，去掉T1,把信息存在电容Cs上，将T2、T3合并成一个管子T,便得到单管M0S动态RAM基本单元电路，如图4.18所示。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904140145043.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904140145043">

<p>读出时，字线上的高电平使T导通，若C,有电荷，经T管在数据线上产生电流，可视为读出“1”。若Cs无电荷，则数据线上无电流，可视为读出“0”。读操作结束时，Cs的电荷已释放完毕，故是破坏性读出，必须再生。写人时，字线为高电平使T导通，若数据线上为高电平，经T管对0，充电，使其存“1”；若数据线为低电平，则C,经T放电，使其无电荷而存“0”。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164519993.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904164519993">

<p>这是一个1K×1位的存储芯片，图中每一小方块代表由3个M0S管组成的动态RAM基本单元电路。它们排列成32×32的矩阵，每列都有一个刷新放大器(用来形成再生信息)和一个预充电管（图中未画），芯片有10根地址线，采用重合法选择基本单元电路。</p>
<p>读出时，先置以预充电信号，接着按行地址A9-A5经行译码器给出读选择信号，同时由列地址A4~A0。经列译码器给出列选择信号。只有在行、列选择信号共同作用下的基本单元电路才能将其信息经读数据线送到读&#x2F;写控制电路，并从数据线D输出。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904164942057.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904164942057">

<p>写入时，在受行地址控制的行译码器给出的写选择信号的作用下；选中芯片的某一行，并在列地址的作用下，由列译码器的输出控制读&#x2F;写控制电路，只将数据线D的信息送到被选中列的写数据线上，信息即被写人到行列共同选中的基本单元电路中。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165055182.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904165055182">

<p>16K×1位的存储芯片共有16K个单管M0S基本单元电路，它们排列成128×128的矩阵，如图所示。图中的行线就是图4.18中的字线，列线就是图4.18中的数据线。128行分布在读放大器的左、右两侧（左侧为0<del>63行，右侧为64</del>127行）。每根行选择线与128个M0S管的栅极相连。128列共有128个读放大器，它的两侧又分别与64个M0S管相连，每根列线上都有一个列地址选择管。128个列地址选择管的输出又互相并接在一起与I&#x2F;0缓冲器相连，I&#x2F;0缓冲器的一端接输出驱动器，可输出数据；另一端接输入器，供数据输入</p>
<p>读出时，行、列地址受RAS和CAS控制，分两次分别存人行、列地址缓存器。行地址经行译码后选中一行，使该行上所有的M0S管均导通，并分别将其电容C,上的电荷反映到128个读放大器的某一侧（第0-63行反映到读放大器的左侧，第64-127行反映到读放大器的右侧）。读放大器的工作原理像一个撬撬板电路，类似于一个触发器，其左右两侧电平相反。此外列地址经列译码后选中某一列，该列上的列地址选择管导通，即可将读放大器右侧信号经读&#x2F;写线、I&#x2F;0缓冲器输出至Dout端。例如，选中第63行、第0列的单管MOS电路，若其C。有电荷为“1”状态，则反映到第0列读放大器的左侧为“1”，右侧为“0”，经列地址选择管输出至Dout为0，与原存信息反相。同理，第0-62行经读放大器至输出线Dout的信息与原存信息均反相。而读出第64~127行时，因它们的电容C。上的电荷均反映到读放大器的右侧，故经列地址选择管输出至Dout的信息均同相。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165802445.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904165802445">

<p>写人时，行、列地址也要分别送人芯片内的行、列地址缓存器，经译码可选中某行、某列。输入信息D通过数据输人器，经I&#x2F;0缓冲器送至读&#x2F;写线上，但只有被选中的列地址选择管导通，可将读&#x2F;写线上的信息送至该列的读放大器右侧，破坏了读放大器的平衡，使读放大器的右侧与输人信息同相，左侧与输入信息反相，读放大器的信息便可写入到选中行的C,中。例如，选中第64行、第127列，输入信息为“1”，则第127列地址选择管导通，将“1”信息送至第127列的读放大器的右侧。虽然第64行上的128个M0S管均导通，但惟有第64行、第127列的M0S管能将读放大器的右侧信息“1”对C,充电，使其写入“1”。值得注意的是写人读放大器左侧行的信息与输入信息都是反相的，而由读出过程分析又知，对读放大器左侧行进行读操作时，读出的信息也是反相的，故最终结果是正确的。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904165825227.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904165825227">

<h6 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h6><p>由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的渎&#x2F;写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2s,这个时间称为刷新周期，又称再生周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证动态RAM内的信息不丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。</p>
<ul>
<li>集中刷新</li>
</ul>
<p>集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读&#x2F;写操作。例如，对128×128矩阵的存储芯片进行刷新时，若存取周期为0.55，刷新周期为2s(占4000个存取周期)，则对128行集中刷新共儒64us(占128个存取周期)，其余的1936s(共3872个存取周期)用来读&#x2F;写或维持信息，如图所示。由于在这64us时间内不能进行读&#x2F;写操作，故称为“死时间”，又称访存“死区”，所占比率28&#x2F;4000×100%&#x3D;3.2%,称为死时间率。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170137608.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904170137608">

<ul>
<li>分散刷新</li>
</ul>
<p>分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期tc分成两段，前半段tm用来读&#x2F;写或维持信息，后半tr段用来刷新，即c&#x3D;tm+tr。若读&#x2F;写周期为0.5us,则存取周期为1s。仍以128×128矩阵的存储芯片为例，刷新按行进行，每隔128s就可将存储芯片全部刷新一遍，如图所示。这比允许的间隔2ms要短得多，而且也不存在停止读&#x2F;写操作的死时间，但存取周期长了，整个系统速度降低了。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170449800.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904170449800">

<ul>
<li>异步刷新</li>
</ul>
<p>异步刷新是前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为2s的特点。例如，对于存取周期为0.5us,排列成128×128的存储芯片，可采取在2ms内对128行各刷新一遍，即每隔15.6s(2000s÷128≈15.6s)刷新一行，而每行刷新的时间仍为0.5s,如图所示。这样，刷新一行只停业一个存取周期，但对每行来说，刷新间隔时间仍为2ms,而“死时间”缩短为0.5心8。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904170623026.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904170623026">

<h6 id="动态RAM与静态RAM比较"><a href="#动态RAM与静态RAM比较" class="headerlink" title="动态RAM与静态RAM比较"></a>动态RAM与静态RAM比较</h6><p>目前，动态RAM的应用比静态RAM要广泛得多。其原因如下：</p>
<ul>
<li>在同样大小的芯片中，动态RAM的集成度远高于静态RAM,如动态RAM的基本单元电路为一个MOS管，静态RAM的基本单元电路可为4~6个MOS管。</li>
<li>动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少。</li>
<li>动态RAM的功耗比静态RAM小。</li>
<li>动态RAM的价格比静态RAM的价格便宜。当采用同一档次的实现技术时，动态RAM的容量大约是静态RAM容量的4-8倍，静态.RAM的存取周期比动态RAM的存取周期快8-16倍，但价格也贵8~16倍。.</li>
</ul>
<p>动态RAM也有缺点：</p>
<ul>
<li>由于使用动态元件（电容），因此它的速度比静态RAM低。</li>
<li>动态RAM需要再生，故需配置再生电路，也需要消耗一部分功率。通常，容量不大的高速缓冲存储器大多用静态RAM实现。</li>
</ul>
<h5 id="3-2-4只读存储器-ROM"><a href="#3-2-4只读存储器-ROM" class="headerlink" title="3.2.4只读存储器(ROM)"></a>3.2.4只读存储器(ROM)</h5><p>按R0M的原始定义，一且注入原始信息即不能改变，但随着用户的需要，总希望能任意修改ROM内的原始信息。这便出现了PROM、EPROM和EEPROM等。对半导体ROM而言，基本器件为两种：MOS型和TL型。</p>
<ul>
<li>掩模ROM(MROM)<ul>
<li>行列选择线交叉处有MOS管为“1”</li>
<li>行列选择线交叉处无MOS管为“0”</li>
</ul>
</li>
<li>PROM(一次性编程)</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171603204.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904171603204">

<ul>
<li>EPROM(多次编程)</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904171626849.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904171626849">

<ul>
<li><p>EEPROM(多次性编程)</p>
<ul>
<li>电可擦写</li>
<li>局部擦写</li>
<li>全部擦写</li>
</ul>
</li>
<li><p>Flash Memory(闪速型存储器)</p>
</li>
</ul>
<p>进入到20世纪.80年代，又出现了一种闪速存储器(lash Memory),又称快擦型存储器，它是在EPROM和EEPROM工艺基础上产生的一种新型的、具有性能价格比更好、可靠性更高的可擦写非易失性存储器。它既有EPROM的价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性。它具有整片擦除的特点，其擦除、重写的速度快。一块1M位的闪速存储芯片的擦除、重写时间小于5s,比一般标准的EEPROM快得多，已具备了RAM的功能，可与CPU直接连接。它还具有高速编程的特点，例如，采用快速脉冲编程算法对28256闪速存储芯片每字节的编程时间仅需100s。此外，该器件具有存储器访问周期短，功耗低及与计算机接口简单等优点。</p>
<h5 id="3-2-5存储器与CPU的连接"><a href="#3-2-5存储器与CPU的连接" class="headerlink" title="3.2.5存储器与CPU的连接"></a>3.2.5存储器与CPU的连接</h5><h6 id="存储芯片的扩展"><a href="#存储芯片的扩展" class="headerlink" title="存储芯片的扩展"></a>存储芯片的扩展</h6><ul>
<li>位扩展</li>
</ul>
<p>位扩展是指增加存储字长，例如，2片1K×4位的芯片可组成1K×8位的存储器，如图所示。图中2片2114的地址线A9-A0,、CS、WE都分别连在一起，其中一片的数据线作为高4位D7-D4,另一片的数据线作为低4位D3~D0。这样，便构成了一个1K×8位的存储器。（10根地址线，8根数据线）</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172431505.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904172431505">

<ul>
<li>字扩展</li>
</ul>
<p>字扩展是指增加存储器字的数量。例如，用2片1K×8位的存储芯片可组成一个2K×8位的存储器，即存储字增加了一倍，如图所示。在此，将A10用做片选信号。由于存储芯片的片选输入端要求低电平有效，故当A10为低电平时，CS0有效，选中左边的1K×8位芯片；当A10为高电平时，反相后CS1有效，选中右边的1K×8位芯片。（11根地址线，8根数据线）</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172643451.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904172643451">

<ul>
<li>位、字扩展</li>
</ul>
<p>字、位扩展是指既增加存储字的数量，又增加存储字长。图示意用8片1K×4位的芯片组成4K×8位的存储器。（12根地址线，8根数据线）</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904172920491.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904172920491">

<p>由图中可见，每2片构成一组1K×8位的存储器，4组便构成4K×8位的存储器。地址线A11、A10经片选译码器得到4个片选信号CS0、CS1、CS2、CS3,分别选择其中1K×8位的存储芯片。WE为读&#x2F;写控制信号。</p>
<h6 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h6><p>存储芯片与CPU芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。</p>
<ul>
<li>地址线的连接</li>
</ul>
<p>存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU地址线的低位与存储芯片的地址线相连。CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。例如，设CPU地址线为16位A15-A0。,1K×4位的存储芯片仅有10根地址线A9-A0。,此时，可将CPU的低位地址A9-A0与存储芯片地址线A9-A0相连。又如，当用16K×1位存储芯片时，则其地址线有14根A13-A0。,此时，可将CPU的低位地址A13-A0。与存储芯片地址线A13~A0相连。</p>
<ul>
<li>数据线的连接</li>
</ul>
<p>同样，CPU的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p>
<ul>
<li>读&#x2F;写命令线的连接</li>
</ul>
<p>CPU读&#x2F;写命令线一般可直接与存储芯片的读&#x2F;写控制端相连，通常高电平为读，低电平为写。有些CPU的读&#x2F;写命令线是分开的，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p>
<ul>
<li>片选线的连接</li>
</ul>
<p>片选线的连接是CPU与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端CS是否能接收到来自CPU的片选有效信号。片选有效信号与CPU的访存控制信号MREQ(低电平有效)有关，因为只有当CPU要求访存时，才需选择存储芯片。若CPU访问I&#x2F;O，则MRE0为高电平，表示不要求存储器工作。此外，片选有效信号还和地址有关，因为CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。通常需用到一些逻辑电路，如译码器及其他各种门电路，来产生片选有效信号。</p>
<ul>
<li>合理选择存储芯片</li>
</ul>
<p>合理选择存储芯片主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽重使连线简单方便。</p>
<h5 id="3-2-6存储器的校验"><a href="#3-2-6存储器的校验" class="headerlink" title="3.2.6存储器的校验"></a>3.2.6存储器的校验</h5><p>在计算机运行过程中，由于种种原因致使数据在存储过程中可能出现差错。为了能及时发现错误并及时纠正错误，通常可将原数据配成汉明编码。</p>
<h6 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h6><p>任意两组合法代码之间二进制位数的最少差异编码的纠错、检错能力与编码的最小距离有关</p>
<p>L-1&#x3D;D+C(D&gt;&#x3D;C)</p>
<ul>
<li>L:编码的最小距离  L&#x3D;3</li>
<li>D:检测错误的位数 具有一<strong>位</strong>纠错</li>
<li>C:纠正错误的位数</li>
</ul>
<p>汉明码是具有一位纠错能力的编码</p>
<h6 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h6><p>汉明码的三要素</p>
<ul>
<li>汉明码的组成需增添？位检测位</li>
</ul>
<p>$$<br>2^k&gt;&#x3D;n+k+1<br>$$</p>
<ul>
<li>检测位的位置?</li>
</ul>
<p>$$<br>2^i(i&#x3D;0,1,2,3,……)<br>$$</p>
<ul>
<li>检测为的取值？</li>
</ul>
<p>检测位的取值与该位所在的检测“小组”中承担的奇偶校验任务有关</p>
<h5 id="3-2-7提高访存速度的措施"><a href="#3-2-7提高访存速度的措施" class="headerlink" title="3.2.7提高访存速度的措施"></a>3.2.7提高访存速度的措施</h5><p>随着计算机应用领域的不断扩大，处理的信息量越来越多，对存储器的工作速度和容量要求也越来越高。此外，因CPU的功能不断增强，&#x2F;0设备的数量不断增多，致使主存的存取速度已成为计算机系统的瓶颈。可见，提高访存速度也成为迫不及待的任务。为了解决此问题，除了寻找高速元件和采用层次结构以外，调整主存的结构也可提高访存速度。</p>
<ul>
<li>单体多字系统</li>
</ul>
<p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可以在一个存取周期内，从同一地址取出4条指令，然后再逐条将指令送至CPU执行，即每隔1&#x2F;4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183437547.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904183437547">

<p>图中示意了一个单体四字结构的存储器，每字W位。按地址在一个存取周期内可读出4×W位的指令或数据，使主存带宽提高到4倍。显然，采用这种办法的前提是：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p>
<ul>
<li>多体并行系统</li>
</ul>
<p>多体并行系统就是采用多体模块组成的存储器。每个模块有相同的容量和存取速度，各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读&#x2F;写电路，它们能并行工作，又能交叉工作。并行工作即同时访问N个模块，同时启动，同时读出，完全并行地工作（不过，同时读出的N个字在总线上需分时传送)。图4.42是适合于并行工作的高位交叉编址的多体存储器结构示意图，图中程序因按体内地址顺序存放（一个体存满后，再存人下一个体），故又有顺序存储之称。显然，高位地址可表示体号，低位地址为体内地址。按这种编址方式，只要合理调动，使不同的请求源同时访问不同的体，便可实现并行工作。例如，当一个体正与CPU交换信息时，另一个体可同时与外部设备进行直接存储器访问，实现两个体并行工作。这种编址方式由于一个体内的地址是连续的，有利于存储器的扩充。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183724260.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904183724260">

<p>下图是按低位交叉编址的多体模块结构示意图。由于程序连续存放在相邻体中，故又有交叉存储之称。显然低位地址用来表示体号，高位地址为体内地址。这种编址方法又称为模M编址(M等于模块数)，表4.3列出了模4交叉编址的地址号。一般模块数M取2的方幂，使硬件电路比较简单。有的机器为了减少存储器冲突，采用质数个模块，例如，我国银河机的M为31,其硬件实现比较复杂。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904183908836.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904183908836">

<ul>
<li>高性能存储芯片<ul>
<li>SDRAM(同步DRAM):在系统时钟的控制下进行读入和写出，CPU无需等待</li>
<li>RDRAM:有Rambus开发，只要解决存储宽带问题</li>
<li>带Cache的DRAM:在DRAM的芯片内集成了一个由SRAM组成的Cache,有利于猝发式读取</li>
</ul>
</li>
</ul>
<h4 id="3-3高速缓冲存储器"><a href="#3-3高速缓冲存储器" class="headerlink" title="3.3高速缓冲存储器"></a>3.3高速缓冲存储器</h4><h5 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h5><p>在多体并行存储系统中，由于I&#x2F;O设备向主存请求的级别高于CPU访存，这就出现了CPU等待&#x2F;0设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU的工作效率。为了避免CPU与I&#x2F;O设备争抢访存，可在CPU与主存之间加一级缓存，这样，主存可将CPU要取的信息提前送至缓存，一旦主存在与&#x2F;0设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。从另一角度来看，主存速度的提高始终跟不上CPU的发展。据统计，CPU的速度平均每年改进60%，而组成主存的动态RAM速度平均每年只改进7%，结果是CPU和动态RAM之间的速度间隙平均每年增大50%。例如，100MHz的Pentium处理器平均每10ns就执行一条指令，而动态RAM的典型访问时间为60~120ns。这也希望由高速缓存Cache来解决主存与CPU速度的不匹配问题。</p>
<p>Cache的出现使CPU可以不直接访问主存，而与高速Cache交换信息。那么，这是否可能呢？通过大量典型程序的分析，发现CPU从主存取指令或取数据，在一定时间内，只是对主存局部地址区域的访问。这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用（如子程序、循环程序和一些常数），即指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性，这就称为程序访问的局部性原理。根据这一原理，很容易设想，只要将CPU近期要用到的程序和数据提前从主存送到Cache,那么就可以做到CPU在一定时间内只访问Cache.。一般Cache采用高速的SRAM制作，其价格比主存贵，但因其容量远小于主存，因此能很好地解决速度和成本的矛盾。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904184832650.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904184832650">

<h6 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h6><p>任何时刻都有一些主存块处在缓存块中。CPU欲读取主存某字时，有两种可能：一种是所需要的字已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字)；另一种是所需的字不在Cache内，此时需将该字所在的主存整个字块一次调入Cache中(Cache与主存之间是字块传送)。如果主存块已调入缓存块，侧称该主存块与缓存块建立了对应关系。</p>
<p>上述第一种情况为CPU访问Cache命中，第二种情况为CPU访问Cache不命中。由于缓存的块数C远小于主存的块数M,因此，一个缓存块不能惟一地、永久地只对应一个主存块，故每个缓存块需设一个标记，用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位（或m位中的一部分）与缓存块的标记进行比较，以判断所读的信息是否已在缓存中。</p>
<p>Cache的容量与’块长是影响Cache效率的重要因素，通常用“命中率”来衡量Cache的效率。命中率是指CPU要访问的信息已在Cache内的比率。</p>
<h6 id="Cache的基本结构"><a href="#Cache的基本结构" class="headerlink" title="Cache的基本结构"></a>Cache的基本结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904190947078.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904190947078">

<ul>
<li>Cache存储体</li>
</ul>
<p>Cache存储体以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多采用多体结构，且Cache访存的优先级最高。</p>
<ul>
<li>地址映射变换机构</li>
</ul>
<p>地址映射变换机构是将CPU送来的主存地址转换为Cache地址。由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。而地址变换又与主存地址以什么样的函数关系映射到Cache中（称为地址映射）有关</p>
<ul>
<li>替换机构</li>
</ul>
<p>当Cache内容已满，无法接受来自主存块的信息时，就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存，而把新的主存块调入Cache.。有关替换算法详见特别需指出的是，Cache对用户是透明的，即用户编程时所用到的地址是主存地址，用户根术不知道这些主存块是否已调入Cache内。因为，将主存块调入Cache的任务全由机器硬件自动完成。</p>
<ul>
<li>Cache的读写操作</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904195651008.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904195651008">

<p>写操作比较复杂，因为对Cache块内写人的信息，必须与被映射的主存块内的信息完全一致。当程序运行过程中需对某个单元进行写操作时，会出现如何使Cache与主存内容保持一致的问题。目前主要采用以下几种方法。</p>
<ul>
<li>写直达法</li>
</ul>
<p>写直达法(Write-through),又称为存直达法（Store-through),即写操作时数据既写入Cache又写入主存。它能随时保证主存和Cache的数据始终一致，但增加了访存次数。</p>
<ul>
<li>写回法</li>
</ul>
<p>写回法(Write-back),又称为拷回法(Copy-back),即写操作时只把数据写入Cache而不写入主存，但当Cache数据被替换出去时才写回主存。可见写回法Cache中的数据会与主存中的不一致。为了识别Cache中的数据是否与主存一致，Cache中的每一块要增设一个标志位，该位有两个状态：“清”（表示未修改过，与主存一致）和“浊”（表示修改过，与主存不一致)。在Cache替换时，“清”的Cache块不必写回主存，因为此时主存中相应块的内容与Cache块是一致的。在写Cache时，要将该标志位设置为“浊”，替换时此Cache块要写回主存，同时要使标志位为“清”。</p>
<h6 id="Cache的改进"><a href="#Cache的改进" class="headerlink" title="Cache的改进"></a>Cache的改进</h6><p>Cache刚出现时，典型系统只有一个缓存，近年来普遍采用多个Cache。其含义.有两方面：一是增加Cache的级数；二是将统一的Cache变成分立的Cache</p>
<ul>
<li>单一缓存和二级缓存：片内Cache、片外Cache</li>
<li>统一缓存和分立缓存：统一缓存是指指令和数据都存放在同一缓存内的Cache;分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令Cache,一个称为数据Cache。.两种缓存的选用主要考虑如下两个因素。其一，它与主存结构有关，如果计算机的主存是统一的（指令、数据存储在同一主存内），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。其二，它与机器对指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般都采用分立缓存。</li>
</ul>
<h5 id="3-3-2-Cache——主存地址映射"><a href="#3-3-2-Cache——主存地址映射" class="headerlink" title="3.3.2 Cache——主存地址映射"></a>3.3.2 Cache——主存地址映射</h5><p>由主存地址映射到Cache地址称为地址映射。地址映射方式很多，有直接映射（固定的映射关系)、全相联映射（灵活性大的映射关系）、组相联映射（上述两种映射的折中）。</p>
<ul>
<li>直接映射</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201458711.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904201458711">

<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904201608551.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904201608551">

<p>这种方式的优点是实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。由图可见，主存地址高m位被分成两部分：低c位是指Cace的字块地址，高t位(t&#x3D;m一c)是指主存字块标记，它被记录在建立了对应关系的缓存块的“标记”位中。当缓存接到CPU送来的主存地址后，只儒根据中间c位字段（假设为00…01）找到Cache字块1，然后根据字块1的“标记”是否与主存地址的高t位相符来判断，若符合且有效位为“1”（有效位用来识别Cache存储块中的数据是否有效，因为有时Cache中的数据是无效的，例如，在初始时刻Cache应该是“空”的，其中的内容是无意义的)，表示该Cache块已和主存的某块建立了对应关系（即已命中)，则可根据b位地址从Cace中取得信息；若不符合，或有效位为“0”（即不命中)，则从主存读人新的字块来替代旧的字块，同时将信息送往CPU,并修改Cache“标记”。如果原来有效位为“0”，还得将有效位置成“1”。</p>
<p>直接映射方式的缺点是不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p>
<ul>
<li>全相联映射</li>
</ul>
<p>全相联映射允许主存中每一字块映射到Cache中的任何一块位置上，如图所示。这种映射方式可以从已被占满的Cache中替换出任一旧字块。显然，这种方式灵活，命中率也更高，缩小了块冲突率。与直接映射相比，它的主存字块标记从t位增加到：t+c位，这就使Cache“标记”的位数增多，而且访问Cache时主存字块标记需要和Cache的全部“标记”位进行比较，才能判断出所访问主存地址的内容是否已在Cache内。这种比较通常采用“按内容寻址”的相联存储器（见附录4A)来完成。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904202232710.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904202232710">

<p>总之，这种方式所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。</p>
<ul>
<li>组相联映射</li>
</ul>
<p>组相联映射是对直接映射和全相联映射的一种折中。它把Cache分为Q组，每组有R块，并有以下关系：</p>
<p>i&#x3D;j mod Q</p>
<p>其中，i为缓存的组好，j为主存的块号。某一主存块按模Q将其映射到级存的第i组内</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904203103631.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904203103631">

<ul>
<li>直接 ：某一 主存块只能固定映射到某一缓存块 </li>
<li>全相联 ：某一主存块能映射到任一缓存块</li>
<li>组相联  ：某一主存块只能映射到某一缓存组中的任一块</li>
</ul>
<h5 id="3-3-3替换策略"><a href="#3-3-3替换策略" class="headerlink" title="3.3.3替换策略"></a>3.3.3替换策略</h5><ul>
<li>先进先出（First-In-First-Out,FIFO）</li>
</ul>
<p>FIF0算法选择最早调入Cache的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，开销小，但没有根据访存的局部性原理，故不能提高Cache的命中率。因为最早调人的信息可能以后还要用到，或者经常要用到，如循环程序。</p>
<ul>
<li>近期最少使用算法(Least Recently Used,LRU）</li>
</ul>
<p>LRU算法比较好地利用访存局部性原理，替换出近期用得最少的字块。它需要随时记录Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU算法的平均命中率比FIFO的高。</p>
<ul>
<li>随机法</li>
</ul>
<p>随机法是随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块，但它也没有根据访存的局部性原理，故不能提高Cache的命中率。</p>
<h4 id="3-4辅助存储器"><a href="#3-4辅助存储器" class="headerlink" title="3.4辅助存储器"></a>3.4辅助存储器</h4><h5 id="3-4-1概述"><a href="#3-4-1概述" class="headerlink" title="3.4.1概述"></a>3.4.1概述</h5><p>辅助存储器作为主存的后援设备又称为外部存储器，简称外存，它与主存一起组成了存储器系统的主存一辅存层次。与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。而主存具有速度快、成本高、容量小等特点，而且大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。</p>
<p>目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。</p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ul>
<li>不能直接与CPU交换信息</li>
</ul>
<h6 id="磁表面存储技术"><a href="#磁表面存储技术" class="headerlink" title="磁表面存储技术"></a>磁表面存储技术</h6><ul>
<li>记录密度</li>
<li>存储容量</li>
<li>平均寻址时间 </li>
<li>数据传输率 </li>
<li>误码率 辅存的速</li>
</ul>
<h5 id="3-4-2磁记录原理和记录方式"><a href="#3-4-2磁记录原理和记录方式" class="headerlink" title="3.4.2磁记录原理和记录方式"></a>3.4.2磁记录原理和记录方式</h5><ul>
<li>磁记录原理</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204226140.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904204226140">

<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204245123.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904204245123">

<ul>
<li>磁表面存储器的记录方式</li>
</ul>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204359480.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904204359480">

<h5 id="3-4-3硬度磁盘存储器"><a href="#3-4-3硬度磁盘存储器" class="headerlink" title="3.4.3硬度磁盘存储器"></a>3.4.3硬度磁盘存储器</h5><h6 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h6><ul>
<li>固定磁头和移动磁头 </li>
<li>可换盘和固定盘</li>
</ul>
<h6 id="硬磁盘存储器结构"><a href="#硬磁盘存储器结构" class="headerlink" title="硬磁盘存储器结构"></a>硬磁盘存储器结构</h6><img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204604155.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904204604155">

<p>硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片3大部分组成</p>
<ul>
<li>磁盘驱动器</li>
</ul>
<p>磁盘驱动器是主机外的一个独立装置，又称磁盘机。大型磁盘驱动器要占用一个或几个机柜，温盘只是一个比砖还小的小匣子。驱动器主要包括主轴、定位驱动及数据控制等3部分。图示意了磁盘驱动器的主轴系统和定位驱动系统。</p>
<img src="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%89/image-20230904204817860.png" srcset="/img/loading.gif" lazyload class="" title="image-20230904204817860">

<ul>
<li><p>磁盘控制器</p>
<ul>
<li>接收主机发来的命令，转换成磁盘驱动器的控制命令 </li>
<li>实现主机和驱动器之间的数据格式转换 </li>
<li>控制磁盘驱动器读写</li>
</ul>
<p>磁盘控制器是主机与磁盘驱动器之间的接口</p>
</li>
<li><p>盘片：由硬质铝合金材料制成</p>
</li>
</ul>
<h5 id="3-4-4软磁盘存储器"><a href="#3-4-4软磁盘存储器" class="headerlink" title="3.4.4软磁盘存储器"></a>3.4.4软磁盘存储器</h5><table>
<thead>
<tr>
<th></th>
<th>硬盘</th>
<th>软盘</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>磁头</td>
<td>固定、活动、浮动</td>
<td>活动</td>
</tr>
<tr>
<td>盘片</td>
<td>固定盘、盘组 大部分不可换</td>
<td>可换盘片</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>环境</td>
<td>苛刻</td>
<td></td>
</tr>
</tbody></table>
<h5 id="3-4-7光盘存储器"><a href="#3-4-7光盘存储器" class="headerlink" title="3.4.7光盘存储器"></a>3.4.7光盘存储器</h5><p>采用光存储技术 采用非磁性介质 采用磁性介质 </p>
<p>第一代光存储技术 不可擦写</p>
<p>第二代光存储技术  可擦写</p>
<h6 id="光盘的存储原理"><a href="#光盘的存储原理" class="headerlink" title="光盘的存储原理"></a>光盘的存储原理</h6><p>只读型和只写一次型 热作用（物理或化学变化）</p>
<p>可擦写光盘  热磁效应 </p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="category-chain-item">计算机组成原理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="print-no-link">#基础知识</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/09/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%AD/" title="计算机的运算方法(五)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机的运算方法(五)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BA%8C/" title="系统总线(二)">
                        <span class="hidden-mobile">系统总线(二)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
