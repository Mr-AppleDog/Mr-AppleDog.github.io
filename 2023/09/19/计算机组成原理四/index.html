

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="除了CPU和存储器两大模块外，计算机硬件系统的第三个关键部分是输入输出模块，又称输入输出系统。随着计算机系统的不断发展，应用范围的不断扩大，I&#x2F;O设备的数量和种类也越来越多，它们与主机的联络方式及信息的交换方式也各不相同。">
<meta property="og:type" content="article">
<meta property="og:title" content="输入输出系统（四）">
<meta property="og:url" content="http://example.com/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="除了CPU和存储器两大模块外，计算机硬件系统的第三个关键部分是输入输出模块，又称输入输出系统。随着计算机系统的不断发展，应用范围的不断扩大，I&#x2F;O设备的数量和种类也越来越多，它们与主机的联络方式及信息的交换方式也各不相同。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/background/8.jpg">
<meta property="article:published_time" content="2023-09-19T08:45:07.000Z">
<meta property="article:modified_time" content="2023-09-26T12:55:45.540Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/background/8.jpg">
  
  
  
  <title>输入输出系统（四） - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/background/00.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="输入输出系统（四）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-19 16:45" pubdate>
          2023年9月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          122 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">输入输出系统（四）</h1>
            
            
              <div class="markdown-body">
                
                <p>除了CPU和存储器两大模块外，计算机硬件系统的第三个关键部分是输入输出模块，又称输入输出系统。随着计算机系统的不断发展，应用范围的不断扩大，I&#x2F;O设备的数量和种类也越来越多，它们与主机的联络方式及信息的交换方式也各不相同。</p>
<span id="more"></span>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h4><p>输入输出系统的发展大致可分为4个阶段。</p>
<p>1、早期</p>
<p>早期的I&#x2F;O设备种类较少，I&#x2F;O设备与主存交换信息都必须通过CPU</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165053240.png" srcset="/img/loading.gif" lazyload class="" title="image-20230919165053240">

<p>这种交换方式延续了相当长的时间。当时的&#x2F;O设备具有以下几个特点：</p>
<ul>
<li>每个I&#x2F;0设备都必须配有一套独立的逻辑电路与CPU相连，用来实现I&#x2F;0设备与主机之<br>间的信息交换，因此线路十分散乱、庞杂。</li>
<li>输入输出过程是穿插在CPU执行程序过程之中进行的，当I&#x2F;O设备与主机交换信息时，<br>CPU不得不停止各种运算，因此，&#x2F;O设备与CPU是按串行方式工作的，极浪费时间。</li>
<li>每个I&#x2F;O设备的逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，它们彼<br>此依赖，相互牵连，因此，欲增添、撤减或更换&#x2F;0设备是非常困难的。</li>
</ul>
<p>2、接口模块和DMA阶段</p>
<p>这个阶段&#x2F;O设备通过接口模块与主机连接，计算机系统采用了总线结构</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165303547.png" srcset="/img/loading.gif" lazyload class="" title="image-20230919165303547">

<p>通常，在接口中都设有数据通路和控制通路。数据经过接口既起到缓冲作用，又可完成串一并变换。控制通路用以传送CPU向I&#x2F;O设备发出的各种控制命令，或使CPU接受来自I&#x2F;O设备的反馈信号。许多接口还能满足中断请求处理的要求，使I&#x2F;O设备与CPU可按并行方式工作，大大地提高了CPU的工作效率。采用接口技术还可以使多台I&#x2F;O设备分时占用总线，使多台I&#x2F;0设备互相之间也可实现并行工作方式，有利于整机工作效率的提高。虽然这个阶段实现了CPU和I&#x2F;O设备并行工作，但是在主机与I&#x2F;O设备交换信息时，CPU要中断现行程序，即CPU与I&#x2F;0设备还不能做到绝对的并行工作。为了进一步提高CPU的工作效率，又出现了直接存储器存取(Direct Memory Access,DMA)技术，其特点是I&#x2F;O设备与主存之间有一条直接数据通路，I&#x2F;O设备可以与主存直接交换信息，使CPU在I&#x2F;O设备与主存交换信息时能继续完成自身的工作，故资源利用率得到了进一步提高。</p>
<p>3、具有通道结构的阶段</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230919165518859.png" srcset="/img/loading.gif" lazyload class="" title="image-20230919165518859">

<p>在小型和微型计算机中，采用DMA方式可实现高速I&#x2F;O设备与主机之间成组数据的交换，但在大中型计算机中，I&#x2F;O设备配置繁多，数据传送频繁，若仍采用DMA方式会出现一系列问题。</p>
<ul>
<li>如果每台1&#x2F;0设备都配置专用的DMA接口，不仅增加了硬件成本，而且为了解决众多DMA接口同时访问主存的冲突问题，会使控制变得十分复杂。</li>
<li>CPU需要对众多的DMA接口进行管理，同样会占用CPU的工作时间，而且因频繁地进入周期挪用阶段，也会直接影响CPU的整体工作效率</li>
</ul>
<p>因此在大中型计算机系统中，采用&#x2F;0通道的方式来进行数据交换。</p>
<p>通道是用来负责管理I&#x2F;O设备以及实现主存与I&#x2F;O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器。通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，但不是一个完全独立的处理器。它依据CPU的&#x2F;0指令进行启动、停业或改变工作状态，是从属于CPU的一个专用处理器。依赖通道管理的I&#x2F;O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。</p>
<p>4、具有I&#x2F;O处理机的阶段</p>
<p>输入输出系统发展到第四阶段，出现了I&#x2F;O处理机。L&#x2F;O处理机又称为外围处理机(Pr-ipheral Processor),它基本独立于主机工作，既可完成&#x2F;O通道要完成的&#x2F;0控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。具有&#x2F;0处理机的输入输出系统与CPU工作的并行性更高，这说明&#x2F;O系统对主机来说具有更大的独立性。</p>
<h4 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h4><h5 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I&#x2F;O软件"></a>I&#x2F;O软件</h5><p>I&#x2F;O指令是机器指令的一类	I&#x2F;O指令的一般格式：</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>命令码</th>
<th>设备码</th>
</tr>
</thead>
</table>
<p>通道指令</p>
<p>通道指令是对具有通道的I&#x2F;O系统专门设置的指令，这类指令一般用以指明参与传送（写人或读取)的数据组在<strong>主存中的首地址</strong>；指明需要传送的字节数或所传送数据组的<strong>末地址</strong>；指明所选设备的设备码及完成某种操作的<strong>命令码</strong>。这类指令的位数一般较长，如BM370机的通道指令为64位。</p>
<h5 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I&#x2F;O硬件"></a>I&#x2F;O硬件</h5><p>设备	I&#x2F;O接口</p>
<p>设备	设备控制器	通道</p>
<h4 id="I-O设备与主机的联系方式"><a href="#I-O设备与主机的联系方式" class="headerlink" title="I&#x2F;O设备与主机的联系方式"></a>I&#x2F;O设备与主机的联系方式</h4><h6 id="I-O设备编制方式"><a href="#I-O设备编制方式" class="headerlink" title="I&#x2F;O设备编制方式"></a>I&#x2F;O设备编制方式</h6><p>通常将I&#x2F;O设备码看做地址码，对I&#x2F;O地址码的编址可采用两种方式：</p>
<ul>
<li>统一编址</li>
</ul>
<p>统一编址就是将&#x2F;0地址看做是存储器地址的例如，在64K地址的存储空间中，划出8K地址作为I&#x2F;O设备的地址，凡是在这8K地址范围内的访问，就是对I&#x2F;O设备的访问，所用的指令与访存指令相似。</p>
<ul>
<li>不统一编址</li>
</ul>
<p>不统一编址就是指I&#x2F;O地址和存储器地址是分开的，所有对&#x2F;IO设备的访问必须有专用的I&#x2F;0指令。显然统一编址占用了存储空间，减少了主存容量，但无须专用的I&#x2F;O指令。不统一编址由于不占用主存空间，故不影响主存容量，但需设I&#x2F;O专用指令。因此，设计机器时，需根据实际情况权衡考虑选取何种编址方式。</p>
<h6 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h6><p>由于每台设备都赋予一个设备号，因此，当要启动某一设备时，可由I&#x2F;O指令的设备码字段直接指出该设备的设备号。通过接口电路中的设备选择电路，便可选中要交换信息的设备。</p>
<h6 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h6><ul>
<li>并行</li>
<li>串行</li>
</ul>
<h6 id="联络方式"><a href="#联络方式" class="headerlink" title="联络方式"></a>联络方式</h6><ul>
<li>立即响应</li>
</ul>
<p>对于一些工作速度十分缓馒的I&#x2F;O设备，如指示灯的亮与灭、开关的通与断、A&#x2F;D转换器缓变信号的输入等，当它们与CPU发生联系时，通常都已使其处于某种等待状态，因此，只要CPU的I&#x2F;0指令一到，它们便立即响应，故这种设备无须特殊联络信号，称为立即响应方式。</p>
<ul>
<li>异步工作采用应答信号联络</li>
</ul>
<p>当I&#x2F;O设备与主机工作速度不匹配时，通常采用异步工作方式。这种方式在交换信息前，I&#x2F;O设备与CPU各自完成自身的任务，一旦出现联络信号，彼此才准备交换信息。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920133546602.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920133546602">

<ul>
<li>同步工作采用同步时标联络</li>
</ul>
<p>同步工作要求I&#x2F;O设备与CPU的工作速度完全同步。例如，在数据采集过程中，若外部数据以2400bPs的速率传送至接口，则CPU也必须以1&#x2F;2400s的速率接收每一位数。这种联络互相之间还得配有专用电路，用以产生同步时标来控制同步工作。</p>
<h6 id="I-O设备与主机的连接方式"><a href="#I-O设备与主机的连接方式" class="headerlink" title="I&#x2F;O设备与主机的连接方式"></a>I&#x2F;O设备与主机的连接方式</h6><ul>
<li>辐射式</li>
</ul>
<p>每台设备都配有一套控制线路和一组信号线,不便于增删设备</p>
<ul>
<li>总线式</li>
</ul>
<p>便于增删设备</p>
<h4 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I&#x2F;O设备与主机信息传送的控制方式"></a>I&#x2F;O设备与主机信息传送的控制方式</h4><p>I&#x2F;0设备与主机交换信息时，共有5种控制方式：程序查询方式、程序中断方式、直接存储器存取方式(DMA)、I&#x2F;0通道方式、I&#x2F;0处理机方式。</p>
<h6 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h6><p>程序查询方式是由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。采用这种方式实现主机和I&#x2F;O设备交换信息，要求I&#x2F;O接口内设置一个能反映I&#x2F;O设备是否准备就绪的状态标记，CPU通过对此标记的检测，可得知I&#x2F;O设备的准备情况。</p>
<p>当现行程序需启动某I&#x2F;O设备工作时，即将此程序流程插入到运行的程序中。由图中可知，CPU启动I&#x2F;O设备后便开始对I&#x2F;O设备的状态进行查询。若查得I&#x2F;O设备未准备就绪，就继续查询；若查得I&#x2F;O设备准备就绪，就将数据从I&#x2F;O接口送至CPU,再由CPU送至主存。这样一个字一个字地传送，直至这个数据块的数据全部传送结束，CPU又重新回到原现行程序。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134310369.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920134310369">

<p>由这个查询过程可见，只要一启动I&#x2F;O设备，CPU便不断查询I&#x2F;O设备的准备情况，从而终止了原程序的执行。CPU在反复查询过程中，犹如就地“踏步”。另一方面，I&#x2F;O设备准备就绪后，CPU要一个字一个字地从I&#x2F;O设备取出，经CPU送至主存，此刻CPU也不能执行原程序，可见这种方式使CPU和I&#x2F;O设备处于串行工作状态，CPU的工作效率不高。</p>
<h6 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h6><p>徜若CPU在启动I&#x2F;O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I&#x2F;O设备推备就绪并向CPU发出中断请求后才予以响应，这将大大提高CPU的工作效率。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134745159.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920134745159">

<p>由图中可见，CPU启动I&#x2F;O设备后仍继续执行原程序，在第K条指令执行结束后，CPU响应了I&#x2F;O设备的请求，中断了现行程序，转至中断服务程序，待处理完后又返回到原程序断点处，继续从第K+1条指令往下执行。由于这种方式使原程序中断了运行，故称为程序中断方式。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920134903603.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920134903603">

<h6 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h6><p>虽然程序中断方式消除了程序查询方式的“踏步”现象，提高了CPU资源的利用率，但是CPU在响应中断请求后，必须停止现行程序而转入中断服务程序，并且为了完成I&#x2F;O设备与主存交换信息，还不得不占用CPU内部的一些寄存器，这同样是对CPU资源的消耗。如果I&#x2F;O设备能直接与主存交换信息而不占用CPU,那么，CPU的资源利用率显然又可进一步提高，这就出现了直接存储器存取(DMA)的方式。</p>
<p>在DMA方式中，主存与&#x2F;O设备之间有一条数据通路，主存与I&#x2F;0设备交换信息时，无须调用中断服务程序。若出现DMA和CPU同时访问主存，CPU总是将总线占有权让给DMA,通常把DMA的这种占有称为窃取或挪用。窃取的时间一般为一个存取周期，故又把DMA占用的存取周期窃取周期或挪用周期。而且，在DMA窃取存取周期时，CPU尚能继续作内部操作（如乘法运算）。可见，与程序查询和程序中断方式相比，DMA方式进一步提高了CPU的资源利用率。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920135237074.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920135237074">



<h6 id="三种方式的-CPU-工作效率比较"><a href="#三种方式的-CPU-工作效率比较" class="headerlink" title="三种方式的 CPU 工作效率比较"></a>三种方式的 CPU 工作效率比较</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920135309902.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920135309902">







<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>中央处理器和主存构成了主机，除主机外的大部分硬件设备都可称为&#x2F;0设备或外部设备，或外围设备，简称外设,I&#x2F;O设备的组成通常可用图画线框内的结构来描述。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230920185042630.png" srcset="/img/loading.gif" lazyload class="" title="image-20230920185042630">

<p>I&#x2F;O设备大致可分为三类:</p>
<ul>
<li>人机交互设备	键盘、鼠标、打印机、显示器</li>
<li>计算机信息存储设备	磁盘、光盘、磁带</li>
<li>机—-机通信设备	调制解调器等</li>
</ul>
<h6 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h6><ul>
<li>键盘</li>
</ul>
<ol>
<li>按下一个键。</li>
<li>查出按下的是哪个键。</li>
<li>将此键翻译成ASCII码,由计算机接收。</li>
</ol>
<ul>
<li>鼠标</li>
<li>触摸屏</li>
</ul>
<h6 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h6><ul>
<li>显示器</li>
</ul>
<ol>
<li>字符显示——字符发生器</li>
<li>图形显示——主观图像</li>
<li>图像显示——客观图像</li>
</ol>
<ul>
<li>打印机</li>
</ul>
<ol>
<li>击打式点——阵式（逐字、逐行）</li>
<li>非击打式——激光（逐页）喷墨（逐字）</li>
</ol>
<h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ul>
<li>A&#x2F;D、D&#x2F;A		模拟&#x2F;数字（数字模拟）转换器</li>
<li>终端 	由键盘和显示器组成完成显示控制与存储、键盘管理及通信控制</li>
<li>汉字处理	汉字输入、汉字存储、汉字输出</li>
</ul>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>接口可以看做是两个系统或两个部件之间的交接部分，它既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界I&#x2F;O接口通常是指主机与I&#x2F;O设备之间设置的一个硬件电路及其相应的软件控制。不同的I&#x2F;O设备都有其相应的设备控制器，而它们往往都是通过I&#x2F;O接口与主机取得联系的。主机与i?o设备之间设置接口的理由如下：</p>
<ul>
<li>一台机器通常配有多台I&#x2F;O设备，它们各自有其设备号（地址），通过接口可实现I&#x2F;O设备的选择。</li>
<li>I&#x2F;O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲，达到速度匹配。</li>
<li>有些I&#x2F;O设备可能串行传送数据，而CPU一般为并行传送，通过接口可实现数据串~并格式的转换。</li>
<li>I&#x2F;O设备的输人输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换。</li>
<li>CPU启动I&#x2F;O设备工作，要向I&#x2F;O设备发各种控制信号，通过接口可传送控制命令。</li>
<li>I&#x2F;O设备需将其工作状态（如“忙”、“就绪”、“错误”、“中断请求”等）及时向CPU报告</li>
</ul>
<p>通过接口可监视设备的工作状态，并可保存状态信息，供CPU查询。值得注意的是，接口(Interface)和端口(Port)是两个不同的概念。端口是指接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑才能组成接口。CPU通过输人指令，从端口读人信息，通过输出指令，可将信息写人到端口中。</p>
<h4 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h4><h5 id="按总线的连接方式的I-O接口方式"><a href="#按总线的连接方式的I-O接口方式" class="headerlink" title="按总线的连接方式的I&#x2F;O接口方式"></a>按总线的连接方式的I&#x2F;O接口方式</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921133011814.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921133011814">

<ul>
<li>数据线</li>
</ul>
<p>数据线是I&#x2F;O设备与主机之间数据代码的传送线，其根数一般等于存储字长的位数或字符的位数，它通常是双向的，也可以是单向的。若采用单向数据总线，则必须用两组才能实现数据的输人和输出功能，而双向数据总线只需一组即可。</p>
<ul>
<li>设备选择线</li>
</ul>
<p>设备选择线是用来传送设备码的，它的根数取决于I&#x2F;O指令中设备码的位数。如果把设备码看做是地址号，那么设备选择线又可称为地址线。设备选择线可以有一组，也可以有两组，其中一组用于主机向I&#x2F;O设备发送设备码，另一组用于I&#x2F;O设备向主机回送设备码。当然设备选择线也可采用一组双向总线代替两组单向总线。</p>
<ul>
<li>命令线</li>
</ul>
<p>命令线主要用以传输CPU向设备发出的各种命令信号，如启动、清除、屏蔽、读、写等。它是一组单向总线，其根数与命令信号多少有关。</p>
<ul>
<li>状态线</li>
</ul>
<p>状态线是将I&#x2F;O设备的状态向主机报告的信号线，例如，设备是否准备就绪，是否向CPU.发出中断请求等。它也是一组单向总线。</p>
<h5 id="接口的的功能和组成"><a href="#接口的的功能和组成" class="headerlink" title="接口的的功能和组成"></a>接口的的功能和组成</h5><ul>
<li>选址功能</li>
</ul>
<p>由于I&#x2F;O总线与所有设备的接口电路相连，但CPU究竟选择哪台设备，还得通过设备选择线上的设备码来确定。该设备码将送至所有设备的接口，因此，要求每个接口都必须具有选址功能，即当设备选择线上的设备码与本设备码相符时，应发出设备选中信号SEL,这种功能可通过接口内的设备选择电路来实现。</p>
<ul>
<li>传送命令的功能</li>
</ul>
<p>当CPU向I&#x2F;0设备发出命令时，要求I&#x2F;O设备能做出响应，如果I&#x2F;O接口不具备传送命令信息的功能，那么设备将无法响应，故通常在I&#x2F;O接口中设有存放命令的命令寄存器以及命令译码器</p>
<ul>
<li>传送数据的功能</li>
</ul>
<p>既然接口处于主机与I&#x2F;O设备之间，因此数据必须通过接口才能实现主机与I&#x2F;O设备之间的传送。这就要求接口中具有数据通路，完成数据传送。这种数据通路还应具有缓冲能力，即能将数据暂存在接口内。接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR),它用来暂存I&#x2F;O设备与主机准备交换的信息，与I&#x2F;O总线中的数据线是相连的。</p>
<ul>
<li>反映设备状态的功能</li>
</ul>
<p>为了使CPU能及时了解各I&#x2F;O设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。例如，用完成触发器D和工作触发器B来标志设备所处的状态。</p>
<ol>
<li>当D&#x3D;0,B&#x3D;0时，表示I&#x2F;O设备处于暂停状态。</li>
<li>当D&#x3D;1,B&#x3D;0时，表示I&#x2F;O设备已经准备就绪。</li>
<li>当D&#x3D;0,B&#x3D;1时，表示I&#x2F;O设备正处于准备状态。</li>
</ol>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921134020211.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921134020211">

<h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><ol>
<li>按数据传送方式分类</li>
</ol>
<ul>
<li>并行接口	Intel 8255</li>
<li>串行接口	Intel 8251</li>
</ul>
<p>​	2.按功能选择的灵活性分类</p>
<ul>
<li>可编程接口	Intel8255、Intel 8251</li>
<li>不可编程接口	Intel8212</li>
</ul>
<p>​	3.按通用性分类</p>
<ul>
<li>通用接口	Intel8255、Intel 8251</li>
<li>专用接口Intel8279、Intel 8275</li>
</ul>
<p>​	4.按数据传送的控制方式分类</p>
<ul>
<li>中断接口	Intel 8259</li>
<li>DMA接口	Intel 8257</li>
</ul>
<h3 id="程序查询方式-1"><a href="#程序查询方式-1" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921135908938.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921135908938">

<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921135932696.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921135932696">

<p>当I&#x2F;O设备较多时，CPU需按各个I&#x2F;O设备在系统中的优先级别进行遂级查询，其流程图所示。图中设备的优先顺序按1至N降序排列。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921175143457.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921175143457">

<ol>
<li>由于这种方式传送数据时要占用CPU中的寄存器，故首先需将寄存器原内容保护起来(若该寄存器中存有用信息)。</li>
<li>由于传送往往是一批数据，因此需先设置I&#x2F;O设备与主机交换数据的计数值。</li>
<li>设置欲传送数据在主存缓冲区的首地址。</li>
<li>CPU启动I&#x2F;O设备。</li>
<li>将I&#x2F;O接口中的设备状态标志取至CPU并测试I&#x2F;O设备是否准备就绪。如果未准备就绪，则等待，直到准备就绪为止。当准备就绪时，接着可实现传送。对输入而言，准备就绪意味着接口电路中的数据缓冲寄存器已装满欲传送的数据，称为输入缓冲满，CPU即可取走数据；对输出而言，准备就绪意味着接口电路中的数据已被设备取走，故称为输出缓冲空，这样CPU可再次将数据送到接口，设备可再次从接口接收数据。</li>
<li>CPU执行I&#x2F;O指令，或从I&#x2F;O接口的数据缓冲寄存器中读出一个数据，或把一个数据写入I&#x2F;O接口中的数据缓冲寄存器内，同时将接口中的状态标志复位。</li>
<li>修改主存地址。</li>
<li>修改计数值，若原设置计数值为原码，则依次减1；若原设置计数值为负数的补码，则依次加1（有关原码、补码的）。</li>
<li>判断计数值。若计数值不为0，表示一批数据尚未传送完，重新启动外设继续传送；若计数值为0，则表示一批数据已传送完毕。</li>
<li>结束I&#x2F;O传送，继续执行现行程序。</li>
</ol>
<h4 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h4><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921175621004.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921175621004">

<p>图中设备选择电路用以识别本设备地址，当地址线上的设备号与本设备号相符时，SEL有效，可以接收命令；数据缓冲寄存器用于存放欲传送的数据；D是完成触发器，B是工作触发器。以输入设备为例，该接口的工作过程如下：</p>
<ol>
<li>当CPU通过1&#x2F;O指令启动输人设备时，指令的设备码字段通过地址线送至设备选择电路。</li>
<li>若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</li>
<li>I&#x2F;O指令的启动命令经过“与非”门将工作触发器B置“1”，将完成触发器D置“0”。</li>
<li>由B触发器启动设备工作。</li>
<li>输人设备将数据送至数据缓冲寄存器。</li>
<li>由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。</li>
<li>D触发器以“准备就绪”状态通知CPU,表示“数据缓冲满”。</li>
<li>CPU执行输人指令，将数据缓冲寄存器中的数据送至CPU的通用寄存器，再存人主存相关单元。</li>
</ol>
<h3 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p>计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断”。中断是现代计算机能有效合理地发挥效能和提高效率的一个十分重要的功能。通常又把实现这种功能所需的软硬件技术统称为中断技术。</p>
<h4 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I&#x2F;O中断的产生"></a>I&#x2F;O中断的产生</h4><p>在I&#x2F;O设备与主机交换信息时，由于设备本身机电特性的影响，其工作速度较低，与CPU无法匹配，因此，CPU启动设备后，往往需要等待一段时间才能实现主机与I&#x2F;O设备之间的信息交换。如果在设备准备的同时，CPU不作无谓的等待，而继续执行现行程序，只有当I&#x2F;O设备准备就绪向CPU提出请求后，再暂时中断CPU现行程序转人I&#x2F;O服务程序，这便产生了I&#x2F;O中断。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921185718159.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921185718159">

<h4 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h4><h5 id="中断请求触发器和中断屏蔽触发器"><a href="#中断请求触发器和中断屏蔽触发器" class="headerlink" title="中断请求触发器和中断屏蔽触发器"></a>中断请求触发器和中断屏蔽触发器</h5><p>每台外部设备都必须配置一个中断请求触发器INTR,当其为“1”时，表示该设备向CPU提出中断请求。但是设备欲提出中断请求时，其设备本身必须准备就绪，即接口内的完成触发器D的状态必须为“1”。</p>
<p>由于计算机应用的范围越来越广泛，向CPU提出中断请求的原因也越来越多，除了各种I&#x2F;O设备外，还有其他许多突发性事件都是引起中断的因素，为此，把凡能向CPU提出中断请求的各种因素统称为中断源。当多个中断源向CPU提出中断请求时，CPU必须坚持一个原则，即在任何瞬间只能接受一个中断源的请求。所以，当多个中断源同时提出请求时，CPU必须对各中断源的请求进行排队，且只能接受级别最高的中断源的请求，不允许级别低的中断源中断正在运行的中断服务程序。这样，在I&#x2F;O接口中需设置一个屏蔽触发器MASK,当其为“1”时，表示被屏的中断服务程序。这样，在I&#x2F;O接口中需设置一个屏蔽触发器MASK,当其为“1”时，表示被屏蔽，即封锁其中断源的请求。可见中断请求触发器和中断屏蔽触发器在I&#x2F;O接口中是成对出现的。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211335034.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921211335034">

<h5 id="排队器"><a href="#排队器" class="headerlink" title="排队器"></a>排队器</h5><p>如上所述，当多个中断源同时向CPU提出请求时，CPU只能按中断源的不同性质对其排队，给予不同等级的优先权，并按优先等级的高低予以响应。就I&#x2F;O中断而言，速度越高的I&#x2F;O设备，优先级越高</p>
<p>图下面的一排门电路是链式排队器的核心。每个接口中有一个反相器和一个“与非”门（如图中点画线框内所示），它们之间犹如链条一样串接在一起，故称为链式排队器。该电路中级别最高的中断源是1号，其次是2号、3号、4号。不论是哪个中断源（一个或多个）提出中断请求，排队器输出端INTP只有一个高电平。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211632244.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921211632244">

<h5 id="中断向量地址形成部件（设备编码器）"><a href="#中断向量地址形成部件（设备编码器）" class="headerlink" title="中断向量地址形成部件（设备编码器）"></a>中断向量地址形成部件（设备编码器）</h5><p>CPU一且响应了&#x2F;0中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同的设备有不同的中断服务程序，每个服务程序都有一个人口地址，CPU必须找到这个入口地址。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921211847534.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921211847534">

<h4 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I&#x2F;O中断处理过程"></a>I&#x2F;O中断处理过程</h4><h5 id="CPU响应中断的条件和时间"><a href="#CPU响应中断的条件和时间" class="headerlink" title="CPU响应中断的条件和时间"></a>CPU响应中断的条件和时间</h5><p>CPU响应I&#x2F;O设备提出中断请求的条件是必须满足CPU中的允许中断触发器EINT为“1”。该触发器可用开中断指令置位（称为开中断）：也可用关中断指令或硬件自动使其复位（称为关中断)。</p>
<p>I&#x2F;O设备准备就绪的时间（即D&#x3D;1)是随机的，而CPU是在统一的时刻(每条指令执行阶段结束前)向接口发中断查询信号，以获取&#x2F;0的中断请求。因此，CPU响应中断的时间一定是在每条指令执行阶段的结束时刻。</p>
<h5 id="I-O处理中断的过程"><a href="#I-O处理中断的过程" class="headerlink" title="I&#x2F;O处理中断的过程"></a>I&#x2F;O处理中断的过程</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921214815629.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921214815629">

<p>下面以输人设备为例，结合图，说明I&#x2F;O中断处理的全过程。当CPU通过I&#x2F;O指令的地址码选中某设备后，则</p>
<ol>
<li>由CPU发启动I&#x2F;O设备命令，将接口中的B置“1”，D置“0”。</li>
<li>接口启动输入设备开始工作。</li>
<li>输人设备将数据送人数据缓冲寄存器。</li>
<li>输人设备向接口发出“设备工作结束”信号，将D置“1”，B置“0”，标志设备准备就绪。</li>
<li>当设备准备就绪(D&#x3D;1),且本设备未被屏蔽(MASK&#x3D;0)时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。</li>
<li>设备中断请求触发器INTR被置“1”，标志设备向CPU提出中断请求。与此同时，INTR送至排队器，进行中断判优。</li>
<li>若CPU允许中断(EINT&#x3D;1),设备又被排队选中，即进入中断响应阶段，由中断响应信号NTA将排队器输出送至编码器形成向量地址。</li>
<li>向量地址送至PC，作为下一条指令的地址。</li>
<li>由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进人中断服务阶段，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。</li>
<li>中断服务程序的最后一条指令是中断返回指令，当其执行结束时，即中断返回至原程序的断点处。</li>
</ol>
<h4 id="中断服务程序流程"><a href="#中断服务程序流程" class="headerlink" title="中断服务程序流程"></a>中断服务程序流程</h4><h5 id="中断服务的流程"><a href="#中断服务的流程" class="headerlink" title="中断服务的流程"></a>中断服务的流程</h5><p>不同设备的服务程序是不相同的，可它们的程序流程又是类似的，一般中断服务程序的流程分四大部分：保护现场、中断服务、恢复现场和中断返回。</p>
<ul>
<li>保护现场</li>
</ul>
<p>保护现场有两个含义，其一是保存程序的断点；其二是保存通用寄存器和状态寄存器的内容。前者由中断隐指令完成，后者由中断服务程序完成。具体而言，可在中断服务程序的起始部分安排若干条存数指令，将寄存器的内容存至存储器中保存，或用进栈指令(PUSH)将各寄存器的内容推入堆栈保存，即将程序中断时的“现场”保存起来。</p>
<ul>
<li>中断服务</li>
</ul>
<p>这是中断服务程序的主体部分，对于不同的中断请求源，其中断服务操作内容是不同的，例如，打印机要求CPU将需打印的一行字符代码，通过接口送入打印机的缓冲存储器中以供打印机打印。又如，显示设备要求CPU将需显示的一屏字符代码通过接口送人显示器的显示存储器中。</p>
<ul>
<li>恢复现场</li>
</ul>
<p>这是中断服务程序的结尾部分，要求在退出服务程序前，将原程序中断时的“现场”恢复到原来的寄存器中。通常可用取数指令或出栈指令(POP),将保存在存储器（或堆栈）中的信息送回到原来的寄存器中。</p>
<ul>
<li>中断返回</li>
</ul>
<p>中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<h5 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h5><ul>
<li>单重中断 不允许中断现行的中断服务程序</li>
<li>多重中断 允许级别更高的中断源中断现行的中断服务程序</li>
</ul>
<h5 id="单重中断和多重中断的服务程序流程"><a href="#单重中断和多重中断的服务程序流程" class="headerlink" title="单重中断和多重中断的服务程序流程"></a>单重中断和多重中断的服务程序流程</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230921215635101.png" srcset="/img/loading.gif" lazyload class="" title="image-20230921215635101">

<p>计算机在处理中断的过程中，有可能出现新的中断请求，此时如果CPU暂停现行的中断服务程序，转去处理新的中断请求，这种现象称为中断嵌套，或多重中断。倘若CPU在执行中断服务程序时，对新的中断请求不予理睬，这种中断称为单重中断。这两种处理方式的中断服务程序路有区别，上图分别为单重中断和多重中断服务程序流程。比较上图可以发现，其区别在于“开中断”的设置时间不同。</p>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><h4 id="DMA方式特点"><a href="#DMA方式特点" class="headerlink" title="DMA方式特点"></a>DMA方式特点</h4><h5 id="DMA-和程序中断两种方式的数据通路"><a href="#DMA-和程序中断两种方式的数据通路" class="headerlink" title="DMA 和程序中断两种方式的数据通路"></a>DMA 和程序中断两种方式的数据通路</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926201541917.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926201541917">

<p>由于主存和DMA接口之间有一条数据通路，因此主存和设备交换信息时，不通过CPU,也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高。这一特点特别适合于高速I&#x2F;O或辅存与主存之间的信息交换。因为高速I&#x2F;O设备若每次申请与主机交换信息时，都要等待CPU做出中断响应后再进行，很可能因此使数据丢失。值得注意的是，若出现高速I&#x2F;O(通过DMA接口)和CPU同时访问主存，CPU必须将总线(如地址线、数据线)占有权让给DMA接口使用，即DMA采用周期窃取的方式占用一个存取周期。</p>
<h5 id="DMA-与主存交换数据的三种方式"><a href="#DMA-与主存交换数据的三种方式" class="headerlink" title="DMA 与主存交换数据的三种方式"></a>DMA 与主存交换数据的三种方式</h5><ul>
<li>停止 CPU 访问主存</li>
</ul>
<p>当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202217133.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926202217133">

<ul>
<li>周期挪用（或周期窃取）</li>
</ul>
<p>在这种方法中，每当I&#x2F;O设备发出DMA请求时，IO设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。I&#x2F;O设备请求DMA传送会遇到三种情祝。一种是CPU此时不需要访问主存（如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需要访问主存)，故I&#x2F;O设备与CPU不发生冲突。第二种情况是I&#x2F;O设备请求DMA传送时，CPU正在访问主存，此时必须待存取周期结束，CPU才能将总线占有权让出。第三种情况是I&#x2F;O设备要求访问主存时，CPU也要求访问主存，这就出现了访问冲突。此刻，I&#x2F;O访存优先于CPU访问主存，因为I&#x2F;O不立即访问主存就可能丢失数据，这时I&#x2F;O要窃取一、二个存取周期，意味着CPU在执行访问主存指令过程中插入了DMA请求，并挪用了一、二个存取周期，使CPU延缓了一、二个存取周期再访问主存。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202243779.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926202243779">

<ul>
<li>DMA 与 CPU 交替访问</li>
</ul>
<p>这种方法适合于CPU的工作周期比主存存取周期长的情况。例如，CPU的工作周期为1.2u3,主存的存取周期小于0.6us,那么可将一个CPU周期分为C和C2两个分周期，其中C,专供DMA访存，C2专供CPU访存，</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202301140.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926202301140">

<h4 id="DMA-接口的功能和组成"><a href="#DMA-接口的功能和组成" class="headerlink" title="DMA 接口的功能和组成"></a>DMA 接口的功能和组成</h4><h5 id="DMA-接口功能"><a href="#DMA-接口功能" class="headerlink" title="DMA 接口功能"></a>DMA 接口功能</h5><p>利用DMA方式传送数据时，数据的传输过程完全由DMA接口电路控制，故DMA接口又有DMA控制器之称。DMA接口应具有如下几个功能。</p>
<ul>
<li>向CPU申请DMA传送。</li>
<li>在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响CPU正常活动或引起总线竞争。</li>
<li>在DMA期间管理系统总线，控制数据传送。</li>
<li>确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度。</li>
<li>在数据块传送结束时，给出DMA操作完成的信号。</li>
</ul>
<h5 id="DMA-接口组成"><a href="#DMA-接口组成" class="headerlink" title="DMA 接口组成"></a>DMA 接口组成</h5><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926202653060.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926202653060">

<ul>
<li>主存地址寄存器(AR)</li>
</ul>
<p>AR用于存放主存中需要交换数据的地址。在DMA传送数据前，必须通过程序将数据在主存中的首地址送到主存地址寄存器。在DMA传送过程中，每交换一次数据，将地址寄存器内容加1，直到一批数据传送完毕为止。</p>
<ul>
<li>字计数器(WC)</li>
</ul>
<p>WC用于记录传送数据的总字数，通常以交换字数的补码值预置。在DMA传送过程中，每传送一个字，字计数器如1，直到计数器为0，即最高位产生进位时，表示该批数据传送完毕（若交换字数以原码值预置，则每传送一个字，字计数器减1，直到计数器为0时，表示该批数据传送结束)。于是DMA接口向CPU发中断请求信号。</p>
<ul>
<li>数据缓冲寄存器(BR)</li>
</ul>
<p>BR用于暂存每次传送的数据。通常DMA接口与主存之间采用字传送，而DMA与设备之间可能是字节或位传送。因此DMA接口中还可能包括有装配或拆卸字信息的硬件逻辑，如数据移位缓冲寄存器、字节计数器等。</p>
<ul>
<li>DMA控制逻辑</li>
</ul>
<p>DMA控制逻辑负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。每当设备准备好一个数据字（或一个字传送结束），就向DMA接口提出申请(DREQ),DMA控制逻辑便向CPU请求DMA服务，发出总线使用权的请求信号(HRQ)。待收到CPU发出的响应信号HLDA后，DMA控制逻辑便开始负责管理DMA传送的全过程，包括对主存地址寄存器和字计数器的修改、识别总线地址、指定传送类型（输入或输出）以及通知设备已经被授予一个DMA周期(DACK)等。</p>
<ul>
<li>中断机构</li>
</ul>
<p>当字计数器溢出（全“0”）时，表示一批数据交换完毕，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作.DMA操作的后处理。必须注意，这里的中断与5.5节介绍的I&#x2F;O中断的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一批数据传送结束。它们是I&#x2F;O系统中不同的中断事件。</p>
<ul>
<li>设备地址寄存器(DAR)</li>
</ul>
<p>DAR存放I&#x2F;O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号、盘面号和柱面号。具体内容取决于设备的数据格式和地址的编址方式。</p>
<h4 id="DMA-的工作过程"><a href="#DMA-的工作过程" class="headerlink" title="DMA 的工作过程"></a>DMA 的工作过程</h4><h5 id="DMA-传送过程"><a href="#DMA-传送过程" class="headerlink" title="DMA 传送过程"></a>DMA 传送过程</h5><p>DMA的数据传送过程分为预处理、数据传送和后处理3个阶段。</p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>在DMA接口开始工作之前，CPU必须给它预置如下信息。</p>
<ol>
<li>给DMA控制逻辑指明数据传送方向是输人（写主存）还是输出（读主存）。</li>
<li>向DMA设备地址寄存器送人设备号，并启动设备。</li>
<li>向DMA主存地址寄存器送入交换数据的主存起始地址。</li>
<li>对字计数器赋予交换数据的个数。</li>
</ol>
<p>上述工作由CPU执行几条输入输出指令完成，即程序的初始化阶段。这些工作完成后，CPU继续执行原来的程序，当I&#x2F;O设备推备好发送的数据（输人）或上次接收的数据已经处理完毕（输出）时，它便通过DMA接口向CPU提出占用总线的申请，若有多个DMA同时申请，则按轻重缓急由硬件排队判优逻辑决定优先等。待I&#x2F;O设备得到主存总线的控制权后，数据的传送便由该DMA接口进行管理。</p>
<h6 id="DMA-传送过程示意"><a href="#DMA-传送过程示意" class="headerlink" title="DMA 传送过程示意"></a>DMA 传送过程示意</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203301196.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926203301196">

<p>以数据输入为例：</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203631295.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926203631295">

<ol>
<li>当设备准备好一个字时，发出选通信号，将该字读到DMA的数据级冲寄存器(BR)中，表示数据缓冲寄存器“满”（如果I&#x2F;O设备是面向字符的，则一次读入一个字节，组装成一个字）。</li>
<li>与此同时设备向DMA接口发请求(DREQ)。</li>
<li>DMA接口向CPU申请总线控制权(HRQ)。</li>
<li>CPU发回HLDA信号，表示允许将总线控制权交给DMA接口。</li>
<li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器写。</li>
<li>通知设备已被授予一个DMA周期(DACK),并为交换下一个字做准备。</li>
<li>将DMA数据缓冲寄存器的内容送数据总线。</li>
<li>主存将数据总线上的信息写至地址总线指定的存储单元中。</li>
<li>修改主存地址和字计数值。</li>
<li>判断数据块是否传送结束，若未结束，则继续传送；若已结束，（宇计数器溢出），则向CPU申请程序中断，标志数据块传送结束。</li>
</ol>
<p>以数据输出为例：</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926203744324.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926203744324">

<ol>
<li>当DMA数据缓冲寄存器已将输出数据送至&#x2F;0设备后，表示数据缓冲寄存器已“空”。</li>
<li>设备向DMA接口发请求(DREQ)。</li>
<li>DMA接口向CPU申请总线控制权(HRQ)。</li>
<li>CPU发回HLDA信号，表示允许将总线控制权交给DMA接口使用。</li>
<li>将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器读。</li>
<li>通知设备已被授予一个DMA周期(DACK),并为交换下一个字做准备。</li>
<li>主存将相应地址单元的内容通过数据总线读入到DMA的数据缓冲寄存器中。</li>
<li>将DMA数据缓神寄存器的内容送到输出设备，若为字符设备，则需将其拆成字符输出。</li>
<li>修改主存地址和字计数值。</li>
<li>判断数据块是否已传送完毕，若未完毕，继续传送；若已传送完毕，则向CPU申请程序中断。</li>
</ol>
<h6 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h6><p>当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，做一些DMA的结束工作的后处理部分。这包括校验送入主存的数据是否正确；决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化，若不需要传送，则停止外设；测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序。</p>
<h5 id="DMA-接口与系统的连接方式"><a href="#DMA-接口与系统的连接方式" class="headerlink" title="DMA 接口与系统的连接方式"></a>DMA 接口与系统的连接方式</h5><h6 id="具有公共请求线的-DMA-请求"><a href="#具有公共请求线的-DMA-请求" class="headerlink" title="具有公共请求线的 DMA 请求"></a>具有公共请求线的 DMA 请求</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204157036.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926204157036">

<p>为具有公共请求线的DMA请求方式，若干个DMA接口通过一条公用的DMA请求线向CPU申请总线控制权。CPU发出响应信号，用链式查询方式通过DMA接口，首先选中的设备获得总线控制权，即可占用总线与主存传送信息。</p>
<h6 id="独立的-DMA-请求"><a href="#独立的-DMA-请求" class="headerlink" title="独立的 DMA 请求"></a>独立的 DMA 请求</h6><img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204213449.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926204213449">

<p>)是独立的DMA请求方式，每一个DMA接口各有一对独立的DMA请求线和DMA响应线，它由CPU的优先级判别机构裁决首先响应哪个请求，并在响应线上发出响应信号，被获得响应信号的DMA接口便可控制总线与主存传送数据。</p>
<p>与程序中断方式相比，DMA方式有如下特点。</p>
<ul>
<li>从数据传送看，程序中断方式靠程序传送，DMA方式靠硬件传送。</li>
<li>从CPU响应时间看，程序中断方式是在一条指令执行结束时响应，而DMA方式可在指令周期内的任一存取周期结束时响应。</li>
<li>程序中断方式有处理异常事件的能力，DMA方式没有这种能力，主要用于大批数据的传送，如硬盘存取、图像处理、高速数据采集系统等，可提高数据吞吐量。</li>
<li>程序中断方式需要中断现行程序，故需保护现场；DMA方式不中断现行程序，无须保护现场。</li>
<li>DMA的优先级比程序中断的优先级高。</li>
</ul>
<h4 id="DMA-接口的类型"><a href="#DMA-接口的类型" class="headerlink" title="DMA 接口的类型"></a>DMA 接口的类型</h4><h5 id="选择型"><a href="#选择型" class="headerlink" title="选择型"></a>选择型</h5><p>这种类型的DMA接口的基本组成，它的主要特点是在物理上可连接多个设备，在逻辑上只允许连接一个设备，即在某一段时间内，DMA接口只能为一个设备服务，关键是在预处理时将所选设备的设备号送人设备地址寄存器。</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204614841.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926204614841">

<h5 id="多路型"><a href="#多路型" class="headerlink" title="多路型"></a>多路型</h5><p>多路型DMA接口不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作，各个设备采用字节交叉的方式通过DMA接口进行数据传送。在多路型DMA接口中，为每个与它连接的设备都设置了一套寄存器，分别存放各自的传送参数。分</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204638266.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926204638266">

<p>多路型 DMA 接口的工作原理</p>
<img src="/2023/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%9B/image-20230926204937986.png" srcset="/img/loading.gif" lazyload class="" title="image-20230926204937986">

<p>上图是多路型DMA接口工作原理示意图。图中磁盘、磁带、打印机同时工作。磁盘、磁带、打印机分别每隔30us、45us、150us向DM接口发DMA请求，磁盘的优先级高于磁带，磁带的优先级高于打印机。</p>
<p>假设DMA接口完成一次DMA数据传送需5s,由图可见，打印机首先发请求，故DMA接口首先为打印机服务(T1);接着磁盘、磁带同时又有DMA请求，DMA接口按优先级别先响应磁盘请求(T2),再响应磁带请求(T3),每次DMA传送都是一个字节。这样，在90多微秒的时间里，DMA接口为打印机服务一次(T1),为磁盘服务4次(T2、T4、T6、T7),为磁带服务3次(T3、T5、T8)。可见DMA接口还有很多空闲时间，可再容纳更多的设备。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="category-chain-item">计算机组成原理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="print-no-link">#基础知识</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/18/mysql%E7%AF%87/" title="mysql基础篇">
                        <span class="hidden-mobile">mysql基础篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
